diff --git a/backend/ARCHITECTURE_REVIEW.md b/backend/ARCHITECTURE_REVIEW.md
new file mode 100644
index 0000000000000000000000000000000000000000..0084411a0efee8c0f4a4ddf2b8f5dc9714e9f2c7
--- /dev/null
+++ b/backend/ARCHITECTURE_REVIEW.md
@@ -0,0 +1,47 @@
+# Backend Architecture Review

- +## Overview
  +The backend centers on `SafetyFunctions` (AppDaemon app) that bootstraps configuration, registers components, and wires managers for faults, notifications, and recovery. Safety mechanisms are implemented as subclasses of `SafetyComponent` and exposed via entries in `COMPONENT_DICT`, while `FaultManager` orchestrates symptom state and fault aggregation with `NotificationManager` and `RecoveryManager` handling outputs and corrective actions.
- +## Strengths
  +- **Single orchestration path:** `SafetyFunctions.initialize` drives setup in a clear order—load config, build components, construct managers, register callbacks, then enable mechanisms—making startup behavior easy to trace. 【F:SafetyFunctions.py†L65-L165】
  +- **Manager separation of concerns:** Fault detection (`FaultManager`), notification dispatching (`NotificationManager`), and recovery execution (`RecoveryManager`) are encapsulated in their own classes, which keeps responsibilities bounded even though they are tightly coupled at runtime. 【F:shared/fault_manager.py†L32-L122】【F:shared/notification_manager.py†L1-L146】【F:shared/recovery_manager.py†L1-L93】
  +- **Reusable mechanism base:** `SafetyComponent` centralizes debouncing, entity validation, and Home Assistant scheduling so individual safety mechanisms can stay small and focused on domain logic. 【F:shared/safety_component.py†L93-L525】
- +## Architectural Gaps / Risks
  +- **Static component registry:** Adding a new safety mechanism requires editing `COMPONENT_DICT` and passing configuration with a matching key, which couples deployment to code changes and blocks runtime discovery. A plugin-like registration mechanism would make components more modular. 【F:SafetyFunctions.py†L55-L127】
  +- **Configuration as raw dictionaries:** The bootstrap path reads multiple nested dicts and proceeds unless they are entirely missing. There is no schema validation for items like fault definitions, notification targets, or mechanism parameters, so malformed entries fail only at runtime (e.g., `FaultManager.found_mapped_fault` merely logs when a symptom maps to zero or multiple faults). 【F:SafetyFunctions.py†L84-L127】【F:shared/fault_manager.py†L169-L198】
  +- **Tight coupling between layers:** Managers call each other directly (e.g., faults trigger notifications and recovery via registered callbacks, and `SafetyComponent` reaches into `FaultManager` for state) rather than publishing events. This coupling makes it harder to test components in isolation or swap implementations. 【F:SafetyFunctions.py†L145-L165】【F:shared/safety_component.py†L370-L417】【F:shared/fault_manager.py†L123-L204】
  +- **Scheduling and debouncing baked into code:** Retry intervals and debounce thresholds are hardcoded (e.g., forcing a re-run after 30 seconds) instead of coming from mechanism configuration, which limits tuning per mechanism and pushes timing changes into code edits. 【F:shared/safety_component.py†L488-L514】
  +- **Global singleton utilities without lifecycle hooks:** `DerivativeMonitor` is instantiated for each component but implemented as a singleton; there is no explicit teardown or registration guard, so entity sampling may persist beyond a component’s lifecycle and complicate tests. 【F:shared/safety_component.py†L122-L132】【F:shared/derivative_monitor.py†L13-L74】
- +## Recommendations
  +- **Introduce a registration API for components:** Replace the static `COMPONENT_DICT` with a registry that components can register with at import time (or via entry points). This would allow new mechanisms to ship as separate modules or packages without touching the main app. 【F:SafetyFunctions.py†L55-L127】
  +- **Adopt explicit configuration schemas:** Validate `app_config` and `user_config` with a schema library (e.g., `pydantic`/`jsonschema`) before initialization to catch missing mappings and invalid types early, and to enforce the one-symptom-to-one-fault mapping assumption before runtime. 【F:SafetyFunctions.py†L84-L127】【F:shared/fault_manager.py†L169-L198】
  +- **Event-driven integration:** Introduce a small event bus or mediator so safety mechanisms emit events that fault, notification, and recovery services subscribe to. This would reduce direct dependencies and enable substituting implementations (e.g., mocking notifications in tests) without touching mechanism code. 【F:SafetyFunctions.py†L145-L165】【F:shared/safety_component.py†L370-L417】
  +- **Externalize timing parameters:** Move debounce limits, re-evaluation delays, and derivative sampling intervals into per-mechanism configuration with sensible defaults. This keeps behavior consistent with configuration and avoids scattering magic numbers like the fixed 30-second retry delay. 【F:shared/safety_component.py†L488-L514】【F:shared/derivative_monitor.py†L57-L108】
  +- **Lifecycle management for shared utilities:** Provide explicit register/unregister hooks for `DerivativeMonitor` (and similar shared helpers) so components can opt in, clean up scheduled jobs, and avoid stale Home Assistant entities during shutdowns or reloads. 【F:shared/derivative_monitor.py†L13-L108】
- +## Safety Mechanism Abstraction Deep-Dive
  +- **Component/safety mechanism contract is workable but implicit:** `SafetyComponent` exposes `init_safety_mechanism`, `enable_safety_mechanism`, and `sm_recalled` but leaves concrete semantics to subclasses. Because `SafetyMechanism` itself only holds entities, enabled state, and callback wiring, there is no shared notion of lifecycle or capability (e.g., “polling vs. edge-triggered” or “requires debounce”). Documenting a minimal interface (expected attributes on `SafetyMechanism`, required entries in `self.safety_mechanisms`, and when `sm_recalled` runs) would make new components more predictable. 【F:shared/safety_component.py†L93-L239】【F:shared/safety_mechanism.py†L30-L103】
  +- **Decorator drives most behavior; consider moving scheduling knobs into the mechanism definition:** `safety_mechanism_decorator` handles debouncing, fault updates, and rescheduling via `run_in` when `force_sm` is returned, but the retry interval is hardcoded (30s) and the decorator is unaware of whether a mechanism is edge-triggered or periodic. Allow mechanisms to declare their retry cadence and debounce thresholds (perhaps stored on the `SafetyMechanism` instance) and have the decorator read them instead of using literals. That keeps the decorator reusable while making behavior configurable. 【F:shared/safety_component.py†L417-L525】
  +- **Initialization pattern is consistent but opaque to recovery:** Components populate `self.safety_mechanisms` and `self.debounce_states` during `init_safety_mechanism`, then `SafetyFunctions` registers them with `FaultManager` and calls `init_safety_mechanisms`. Recovery paths later call back into the mechanism by looking up a bound method on the module (`getattr(symptom_data.module, symptom_data.sm_name)`), so the recovery manager never sees the `SafetyMechanism` instance. Passing the mechanism object (or a lightweight handle) into recovery would allow reuse of shared state (e.g., thresholds or cached readings) and avoid re-deriving context inside recovery actions. 【F:SafetyFunctions.py†L110-L165】【F:shared/fault_manager.py†L203-L246】【F:shared/recovery_manager.py†L131-L231】
  +- **Recovery actions as static callables limit coupling back to the mechanism:** Because `RecoveryManager` only stores callable references and parameters, recovery actions cannot consult the originating mechanism without global lookups. If you want recoveries to reuse mechanism utilities (e.g., validation, derivative monitor), inject the mechanism or its component into the `RecoveryAction` params at build time so recoveries can call instance methods safely. Alternatively, model recoveries as methods on the component and bind them when constructing `RecoveryAction` to remove the need for global access. 【F:shared/recovery_manager.py†L131-L231】【F:shared/types_common.py†L53-L122】
  +- **Add guardrails to decorator entry/exit:** The decorator assumes `self.debounce_states[sm.name]` is initialized and that `sm_return.additional_info` is present. Defensive checks (with clear logs) would make misconfigured mechanisms fail noisily rather than with `KeyError`/`TypeError`. A small helper to initialize missing debounce state on first run would also let you call decorated mechanisms from recovery without prior `init_safety_mechanism` bookkeeping. 【F:shared/safety_component.py†L446-L514】
- +## Notification Feature Review
  +- **Flow is cohesive but centralized:** `FaultManager` calls `notify_interface` when setting or clearing faults, and `NotificationManager` both formats messages and performs side effects (dashboard updates, lights/alarms, mobile notifications). This keeps the flow simple but makes it harder to swap out delivery channels or run in “notification-dry-run” mode for tests. 【F:shared/fault_manager.py†L201-L407】【F:shared/notification_manager.py†L42-L189】
  +- **Configuration and channel handling are rigid:** Notification behavior is driven by static `level_methods` and a fixed base URL, with no schema validation or per-level overrides for dashboards, lights, or mobile payloads. Levels 3 and 4 have no additional actions, and missing configuration simply logs a warning rather than failing early. Promote a typed config (channel targets, templates, enable/disable flags) and allow declarative per-level behaviors instead of hardcoding mapping tables. 【F:shared/notification_manager.py†L42-L242】
  +- **State tracking lacks persistence and deduplication controls:** Active notifications are stored in-memory and overwritten on each send; `_clear_company_app` depends on matching tags but there is no TTL, retry/backoff, or rate limiting to avoid alert storms. Consider adding persistence (or reconstruction from HA state), idempotent updates keyed by fault tag, and guardrails like cooldowns or batching for noisy symptoms. 【F:shared/notification_manager.py†L52-L305】
  +- **Recovery messaging is an afterthought:** Recovery text is appended to whatever notification happens to be active, without ensuring the original payload exists or differentiating between fault and recovery content. Treat recovery and resolution as first-class notification types with their own templates and delivery rules so users see clear, time-ordered updates. 【F:shared/notification_manager.py†L323-L355】
- +## Recovery Feature Review
  +- **Validation pipeline is thoughtful but leans on live mechanisms:** `RecoveryManager.recovery` computes a `RecoveryResult` from the configured `rec_fun`, checks for conflicts, and only then executes notifications, actuator changes, and listeners. The dry-run validation calls each enabled safety mechanism with `entities_changes` so it can catch regressions before touching HA state, which is a good safety net. 【F:shared/recovery_manager.py†L286-L418】【F:shared/safety_component.py†L462-L525】
  +- **Dry test shares code paths with production execution:** The dry run relies on invoking the real safety mechanism function (via the decorator’s “dry mode”) and assumes each SM can simulate against the proposed entity changes without mutating real state. Because the decorator still runs the underlying SM logic and returns a result, any side effects in the SM (or reliance on live HA readings) could leak into validation. Consider pure simulation hooks on `RecoveryAction` or a side-effect-free evaluator separate from the production SM. 【F:shared/recovery_manager.py†L257-L285】【F:shared/safety_component.py†L462-L525】
  +- **Conflict detection is brittle and may skip hazards:** Recovery conflict checks compare recovery action names using substring matching and identity comparison (`symptom_name is not prefaul_name`), so overlapping names or Python’s string interning could cause missed conflicts. Replace the name containment check with explicit recovery-to-symptom mapping and compare symptom identifiers with equality to ensure conflicts are detected consistently. 【F:shared/recovery_manager.py†L95-L178】【F:shared/recovery_manager.py†L257-L285】
  +- **Recovery actions stay detached from mechanisms:** Recovery execution looks up callbacks by symptom name and sets HA state directly, but the recovery manager has no access to the originating `SafetyMechanism` instance. That prevents reuse of shared validation, derivative monitors, or mechanism-local thresholds during recovery. Passing the mechanism (or a typed handle) into `RecoveryAction` params and recording a richer status object than the current `TO_PERFORM` flag would make recoveries more contextual and testable. 【F:shared/recovery_manager.py†L180-L438】【F:shared/safety_component.py†L462-L525】【F:shared/types_common.py†L159-L171】
- +## Overall Backend Assessment
  +- **Architecture summary:** The codebase orients around a single AppDaemon app (`SafetyFunctions`) that builds a registry-driven set of `SafetyComponent` subclasses, wires them to `FaultManager`, and delegates notifications and recovery to dedicated managers. The separation of responsibilities is clear, but integration is mostly direct calls rather than events, and many behaviors are driven by hardcoded timings and dictionaries instead of typed configuration. 【F:SafetyFunctions.py†L55-L165】【F:shared/safety_component.py†L93-L525】【F:shared/fault_manager.py†L32-L407】
  +- **Design quality score: 6.5/10.** Strengths include consistent initialization flow, a reusable mechanism base class, and thoughtful safety features like dry-run recovery. Weaknesses center on static registries, limited config validation, tight coupling, and brittle conflict checks that could hide failures. With schema-backed configs, event-driven wiring, and stronger guardrails around recovery and notifications, the architecture could reach production-grade robustness. 【F:SafetyFunctions.py†L65-L165】【F:shared/fault_manager.py†L95-L407】【F:shared/recovery_manager.py†L95-L418】【F:shared/notification_manager.py†L42-L305】
  +- **Professionalism verdict:** The code demonstrates solid intent and reasonable structure, but the reliance on mutable dictionaries, lack of type-hinted contracts, and runtime coupling patterns keep it in “experienced hobbyist / early-stage” territory rather than a polished production service. Investing in typed schemas, dependency inversion (event bus or interfaces), and automated tests around recovery dry runs and notification idempotency would move it toward a professional standard. 【F:shared/safety_component.py†L93-L525】【F:shared/notification_manager.py†L42-L355】【F:shared/recovery_manager.py†L95-L418】
