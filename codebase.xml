<?xml version="1.0" encoding="UTF-8"?>
<files>
	<file path='.gitignore'>
		# Byte-compiled / optimized / DLL files
		__pycache__/
		*.py[cod]
		*$py.class
		
		# C extensions
		*.so
		
		# Distribution / packaging
		.Python
		build/
		develop-eggs/
		dist/
		downloads/
		eggs/
		.eggs/
		lib/
		lib64/
		parts/
		sdist/
		var/
		wheels/
		share/python-wheels/
		*.egg-info/
		.installed.cfg
		*.egg
		MANIFEST
		
		# PyInstaller
		#  Usually these files are written by a python script from a template
		#  before PyInstaller builds the exe, so as to inject date/other infos into it.
		*.manifest
		*.spec
		
		# Installer logs
		pip-log.txt
		pip-delete-this-directory.txt
		
		# Unit test / coverage reports
		htmlcov/
		.tox/
		.nox/
		.coverage
		.coverage.*
		.cache
		nosetests.xml
		coverage.xml
		*.cover
		*.py,cover
		.hypothesis/
		.pytest_cache/
		cover/
		
		# Translations
		*.mo
		*.pot
		
		# Django stuff:
		*.log
		local_settings.py
		db.sqlite3
		db.sqlite3-journal
		
		# Flask stuff:
		instance/
		.webassets-cache
		
		# Scrapy stuff:
		.scrapy
		
		# Sphinx documentation
		docs/_build/
		
		# PyBuilder
		.pybuilder/
		target/
		
		# Jupyter Notebook
		.ipynb_checkpoints
		
		# IPython
		profile_default/
		ipython_config.py
		
		# pyenv
		#   For a library or package, you might want to ignore these files since the code is
		#   intended to run in multiple environments; otherwise, check them in:
		# .python-version
		
		# pipenv
		#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
		#   However, in case of collaboration, if having platform-specific dependencies or dependencies
		#   having no cross-platform support, pipenv may install dependencies that don't work, or not
		#   install all needed dependencies.
		#Pipfile.lock
		
		# poetry
		#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
		#   This is especially recommended for binary packages to ensure reproducibility, and is more
		#   commonly ignored for libraries.
		#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
		#poetry.lock
		
		# pdm
		#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
		#pdm.lock
		#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
		#   in version control.
		#   https://pdm.fming.dev/#use-with-ide
		.pdm.toml
		
		# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
		__pypackages__/
		
		# Celery stuff
		celerybeat-schedule
		celerybeat.pid
		
		# SageMath parsed files
		*.sage.py
		
		# Environments
		.env
		.venv
		env/
		venv/
		ENV/
		env.bak/
		venv.bak/
		
		# Spyder project settings
		.spyderproject
		.spyproject
		
		# Rope project settings
		.ropeproject
		
		# mkdocs documentation
		/site
		
		# mypy
		.mypy_cache/
		.dmypy.json
		dmypy.json
		
		# Pyre type checker
		.pyre/
		
		# pytype static type analyzer
		.pytype/
		
		# Cython debug symbols
		cython_debug/
		
		# PyCharm
		#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
		#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
		#  and can be added to the global gitignore or merged into this file.  For a more nuclear
		#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
		#.idea/</file>
	<file path='.gitmodules'>
		[submodule "BMAD-METHOD"]
			path = BMAD-METHOD
			url = https://github.com/Arkaqius/BMAD-METHOD.git</file>
	<file path='backend\.coveragerc'>
		[run]
		omit = 
		    tests/*</file>
	<file path='backend\app_cfg.yaml'>
		SafetyFunctions:
		  # App definitions
		  module: SafetyFunctions
		  class: SafetyFunctions
		  log_level: ERROR
		  use_dictionary_unpacking: true
		
		  # General config of app
		  app_config:
		    faults:
		      RiskyTemperature:
		        name: "Unsafe temperature"
		        level: 2
		        related_sms:
		          - "sm_tc_1"
		      RiskyTemperatureForecast:
		        name: "Unsafe temperature forecast"
		        level: 3
		        related_sms:
		          - "sm_tc_2"
		
		  # User specyfic config
		  user_config:
		    notification:
		      light_entity: 'light.warning_light'
		    common_entities:
		      outside_temp : 'sensor.dom_temperature'
		    safety_components:
		      TemperatureComponent:
		        - Office:
		            CAL_LOW_TEMP_THRESHOLD: 18.0
		            CAL_FORECAST_TIMESPAN: 2.0 # hours # app cfg
		            temperature_sensor: "sensor.office_temperature"
		            temperature_sensor_rate: "sensor.office_temperature_rate" # sampling_rate = 1min
		            window_sensor: binary_sensor.office_window_contact_contact
		        - Bedroom:
		            CAL_LOW_TEMP_THRESHOLD: 18.0
		            CAL_FORECAST_TIMESPAN: 2.0 # hours # app cfg
		            temperature_sensor: "sensor.bedroom_temperature"
		            temperature_sensor_rate: "sensor.bedroom_temperature_rate" # sampling_rate = 1min
		            window_sensor: binary_sensor.bedroom_windowleft_sensor_contact
		        - Bathroom:
		            CAL_LOW_TEMP_THRESHOLD: 18.0
		            CAL_FORECAST_TIMESPAN: 2.0 # hours # app cfg
		            temperature_sensor: "sensor.bathroom_temperature"
		            temperature_sensor_rate: "sensor.bathroom_temperature_rate" # sampling_rate = 1min
		            window_sensor: binary_sensor.bathroom_window_contact_contact
		        - Livingroom:
		            CAL_LOW_TEMP_THRESHOLD: 18.0
		            CAL_FORECAST_TIMESPAN: 2.0 # hours # app cfg
		            temperature_sensor: "sensor.livingroom_temperature"
		            temperature_sensor_rate: "sensor.livingroom_temperature_rate" # sampling_rate = 1min
		            window_sensor: binary_sensor.livingroom_door_contact_contact
		        - Kitchen:
		            CAL_LOW_TEMP_THRESHOLD: 18.0
		            CAL_FORECAST_TIMESPAN: 2.0 # hours # app cfg
		            temperature_sensor: "sensor.corridor_temperature"
		            temperature_sensor_rate: "sensor.corridor_temperature_rate" # sampling_rate = 1min
		            window_sensor: binary_sensor.kitchen_window_contact_contact
		        - Entrance:
		            CAL_LOW_TEMP_THRESHOLD: 18.0
		            CAL_FORECAST_TIMESPAN: 2.0 # hours # app cfg
		            temperature_sensor: "sensor.entrance_temperature"
		            temperature_sensor_rate: "sensor.entrance_temperature_rate" # sampling_rate = 1min
		            window_sensor: None
		        - Garage:
		            CAL_LOW_TEMP_THRESHOLD: 10.0
		            CAL_FORECAST_TIMESPAN: 2.0 # hours # app cfg
		            temperature_sensor: "sensor.garage_temperature"
		            temperature_sensor_rate: "sensor.garage_temperature_rate" # sampling_rate = 1min
		            window_sensor: binary_sensor.garage_gatedoorlow_contact_contact
		        - Kidsroom:
		            CAL_LOW_TEMP_THRESHOLD: 18.0
		            CAL_FORECAST_TIMESPAN: 2.0 # hours # app cfg
		            temperature_sensor: "sensor.kidsroom_temperature"
		            temperature_sensor_rate: "sensor.kidsroom_temperature_rate" # sampling_rate = 1min
		            window_sensor: binary_sensor.kidsroom_window_contact_contact
		        - Upperbathroom:
		            CAL_LOW_TEMP_THRESHOLD: 18.0
		            CAL_FORECAST_TIMESPAN: 2.0 # hours # app cfg
		            temperature_sensor: "sensor.upperbathroom_temperature"
		            temperature_sensor_rate: "sensor.upperbathroom_temperature_rate" # sampling_rate = 1min
		            window_sensor: sensor.upperbathroom_window_contact_contact_battery</file>
	<file path='backend\SafetyFunctions.py'>
		"""
		This module integrates various safety functions into the Home Assistant environment, focusing on the management of safety-related components, fault conditions, and recovery processes. It defines the `SafetyFunctions` class, which serves as the main entry point for initializing and managing the safety mechanisms within Home Assistant.
		
		Features and Components:
		- **Safety Mechanisms**: Supports the implementation of domain-specific safety mechanisms, such as temperature monitoring through the `TemperatureComponent`.
		- **Fault and symptom Management**: Utilizes `FaultManager` to handle fault and symptom conditions, allowing for systematic detection, notification, and recovery from potential safety issues.
		- **Notifications**: Leverages `NotificationManager` for sending alerts or messages in response to safety events or fault conditions.
		- **Recovery Actions**: Incorporates `RecoveryManager` to define and execute recovery actions for mitigating detected fault conditions.
		- **Configuration Parsing**: Employs configuration parsing (via `cfg_pr`) to initialize safety mechanisms, fault conditions, and recovery actions based on predefined settings.
		
		Key Functionalities:
		- **Initialization**: On initialization, the module sets up safety mechanisms, fault conditions, symptom conditions, and recovery managers according to configurations specified in Home Assistant's app configuration.
		- **Safety Mechanism Registration**: Registers the `FaultManager` with each safety mechanism component, ensuring integrated fault and recovery management.
		- **State Monitoring and Management**: Monitors the state of various components and updates Home Assistant's state machine with the health status of the safety app.
		
		Usage:
		The `SafetyFunctions` class is designed to be used as an AppDaemon app within Home Assistant. It requires configuration settings for symptoms, faults, notifications, and any domain-specific safety mechanisms to be provided in the AppDaemon app's YAML configuration file.
		
		Example Configuration (YAML):
		```yaml
		SafetyFunctions:
		  module: safety_functions_module
		  class: SafetyFunctions
		  symptoms: {...}
		  faults: {...}
		  notification: {...}
		
		This module exemplifies a holistic approach to safety management within Home Assistant,
		offering a framework for the development and integration of comprehensive safety features.
		
		Note:
		
		- Ensure that all required configurations are provided and correctly formatted.
		- The module is designed for extensibility, allowing for the integration of additional safety mechanisms as needed.
		
		"""
		
		from typing import Any
		import appdaemon.plugins.hass.hassapi as hass
		from shared.safety_component import SafetyComponent
		from shared.temperature_component import TemperatureComponent
		from shared.fault_manager import FaultManager
		from shared.notification_manager import NotificationManager
		from shared.recovery_manager import RecoveryManager
		from shared.types_common import Fault, Symptom, RecoveryAction
		from shared.common_entities import CommonEntities
		from shared.derivative_monitor import DerivativeMonitor
		import shared.cfg_parser as cfg_pr
		
		DEBUG = False
		
		if DEBUG:
		    from remote_pdb import RemotePdb  # type: ignore
		
		COMPONENT_DICT: dict[str, SafetyComponent] = {
		    "TemperatureComponent": TemperatureComponent  # type: ignore
		}
		
		
		class SafetyFunctions(hass.Hass):
		    """
		    Main class for managing safety functions in the Home Assistant environment.
		    """
		
		    def initialize(self) -> None:
		        """
		        Initialize the SafetyFunctions app and its components.
		        This method sets up safety mechanisms, fault conditions, recovery actions, and health state.
		        """
		        # Disable all the no-member violations in this function
		        # pylint: disable=attribute-defined-outside-init
		        # 10. Initialize health entity
		        self.set_state("sensor.safety_app_health", state="init")
		
		        if DEBUG:
		            RemotePdb("172.30.33.4", 5050).set_trace()
		
		        # 10.1. Internal storage for safety components
		        self.sm_modules: dict = {}
		        self.symptoms: dict[str, Symptom] = {}
		        self.recovery_actions: dict[str, RecoveryAction] = {}
		        self.derivative_monitor = DerivativeMonitor(self)
		
		        # 10.2. Get configuration data
		        self.fault_dict: dict = self.args["app_config"]["faults"]
		        self.safety_components_cfg: dict = self.args["user_config"]["safety_components"]
		        self.notification_cfg: dict = self.args["user_config"]["notification"]
		        self.common_entities_cfg: dict = self.args["user_config"]["common_entities"]
		
		        # Combine configuration for export later
		        combined_config = {
		            "faults": self.fault_dict,
		            "safety_components": self.safety_components_cfg,
		            "notification": self.notification_cfg,
		            "common_entities": self.common_entities_cfg,
		        }
		
		        # 10.3. Stop if configurations are invalid
		        if not self.fault_dict or not self.safety_components_cfg:
		            self.log(
		                "No faults or safety components defined. Stopping the app.",
		                level="WARNING",
		            )
		            self.set_state("sensor.safety_app_health", state="invalid_cfg")
		            self.stop_app(self.name)
		            return
		
		        # 20. Initialize common entities
		        self.common_entities: CommonEntities = CommonEntities(
		            self, self.common_entities_cfg
		        )
		
		        # 30. Initialize components and collect symptoms/recovery actions
		        for component_name, component_cls in COMPONENT_DICT.items():
		            if component_name in self.safety_components_cfg:
		                component_instance = component_cls(self, self.common_entities)
		                self.sm_modules[component_name] = component_instance
		
		                component_cfg = self.safety_components_cfg[component_name]
		                symptoms_data, recovery_data = component_instance.get_symptoms_data(
		                    self.sm_modules, component_cfg
		                )
		
		                self.symptoms.update(symptoms_data)
		                self.recovery_actions.update(recovery_data)
		
		        # 40. Get faults data
		        self.faults = cfg_pr.get_faults(self.fault_dict)
		
		        # 50. Initialize fault manager
		        self.fm: FaultManager = FaultManager(
		            self, self.sm_modules, self.symptoms, self.faults
		        )
		
		        # 60. Initialize notification manager
		        self.notify_man: NotificationManager = NotificationManager(
		            self, self.notification_cfg
		        )
		
		        # 70. Initialize recovery manager
		        self.reco_man: RecoveryManager = RecoveryManager(
		            self, self.fm, self.recovery_actions, self.common_entities, self.notify_man
		        )
		
		        # 80. Register callbacks for faults
		        self.fm.register_callbacks(self.reco_man.recovery, self.notify_man.notify)
		
		        # 90. Register fault manager to components
		        for sm in self.sm_modules.values():
		            sm.register_fm(self.fm)
		
		        # 100. Register entities for faults
		        health_attributes: dict[str, Any] = self.register_entities()
		
		        # 110. Initialize safety mechanisms
		        self.fm.init_safety_mechanisms()
		
		        # 120. Enable all symptoms
		        self.fm.enable_all_symptoms()
		
		        # 130 Emit config and set state to running
		        self.set_state(
		            "sensor.safety_app_health", state="running", attributes=health_attributes
		        )
		        self.log("Safety app started successfully", level="DEBUG")
		
		    def register_entities(self) -> dict[str, Any]:
		        """
		        Registers all entities required by the Safety Functions app in Home Assistant.
		
		        This includes:
		        - Initializing the `sensor.system_state` entity with a default safe state.
		        - Registering fault entities for each fault in the system.
		        - Exporting the app health entity attributes.
		
		        Ensures that the entities are properly initialized and available for monitoring in Home Assistant.
		        """
		        # Register system state entity
		        self.set_state(
		            "sensor.safetySystem_state",
		            state="safe",  # Default state on initialization
		            attributes={
		                "friendly_name": "System State",
		                "icon": "mdi:shield-check",
		                "attribution": "Managed by SafetyFunction",
		                "description": "Overall safety system state based on fault conditions.",
		            },
		        )
		
		        # Register fault entities
		        for name, fault in self.faults.items():
		            self.set_state(
		                "sensor.fault_" + name,
		                state="Not_tested",
		                attributes={
		                    "friendly_name": f"Fault: {name}",
		                    "attribution": "Managed by SafetyFunction",
		                    "description": f"Status of the {name} fault.",
		                    "level": f'level_{fault.level}'
		                },
		            )
		
		        # Register health entity
		        combined_config = {
		            "faults": self.fault_dict,
		            "safety_components": self.safety_components_cfg,
		            "notification": self.notification_cfg,
		            "common_entities": self.common_entities_cfg,
		        }
		        health_attributes = {
		            "friendly_name": "Safety App Health",
		            "configuration": combined_config,
		            "symptoms": {
		                name: vars(symptom) for name, symptom in self.symptoms.items()
		            },
		            "recovery_actions": {
		                name: {
		                    "name": action.name,
		                    "params": action.params,
		                    "status": action.current_status.name,
		                }
		                for name, action in self.recovery_actions.items()
		            },
		        }
		
		        return health_attributes</file>
	<file path='backend\shared\__init__.py'/>
	<file path='backend\shared\cfg_parser.py'>
		"""
		This module provides utilities for loading fault and symptom configurations from dictionaries, typically derived from YAML configuration files.
		It supports getting Fault and symptom objects, which are essential components of the safety management system within a Home Assistant environment.
		These utilities facilitate the dynamic setup of safety mechanisms based on external configurations.
		"""
		
		from shared.fault_manager import Fault
		
		
		def get_faults(faults_dict: dict) -> dict[str, Fault]:
		    """
		    Parses a dictionary of fault configurations and initializes Fault objects for each.
		
		    Each fault configuration must include 'related_sms' (related safety mechanisms) and
		    a 'level' level. The function creates a Fault object for each entry and collects them
		    into a dictionary keyed by the fault name.
		
		    Args:
		        faults_dict: A dictionary with fault names as keys and dictionaries containing
		                     'related_sms' and 'level' as values.
		
		    Returns:
		        A dictionary mapping fault names to initialized Fault objects.
		    ret_val: dict[str, Fault] = {}
		    """
		    ret_val: dict[str, Fault] = {}
		    for fault_name, fault_data in faults_dict.items():
		        ret_val[fault_name] = Fault(
		            fault_name, fault_data["related_sms"], fault_data["level"]
		        )
		    return ret_val</file>
	<file path='backend\shared\common_entities.py'>
		import appdaemon.plugins.hass.hassapi as hass  # type: ignore
		
		
		class CommonEntities:
		
		    def __init__(self, hass_app: hass, cfg: dict[str, str]) -> None:
		        self.hass_app: hass = hass_app
		        self.outside_temp_sensor: str = cfg["outside_temp"]
		
		    def get_outisde_temperature(self) -> str | None:
		        if self.hass_app:
		            return self.hass_app.get_state(self.outside_temp_sensor)
		        return None</file>
	<file path='backend\shared\derivative_monitor.py'>
		"""
		This module defines the DerivativeMonitor class, which is a singleton class designed to monitor entity changes
		and calculate first and second derivatives. This is useful for tracking rate of change and acceleration of entity values,
		such as temperature trends, in a Home Assistant-based safety system.
		
		Classes:
		- DerivativeMonitor: A singleton class to register entities, calculate derivatives, and provide access to derivative data.
		"""
		
		from typing import Optional, Dict, Any
		from appdaemon.plugins.hass.hassapi import Hass  # type: ignore
		from threading import Lock
		import collections
		
		
		class DerivativeMonitor:
		    """
		    Singleton class for monitoring entity state changes and calculating first and second derivatives.
		    Allows entities to be registered with specific sampling times and saturation limits. Derivatives
		    are calculated periodically based on the sampling time provided at registration.
		    """
		
		    _instance = None
		    _lock = Lock()
		
		    def __new__(cls, *args, **kwargs):
		        """Ensures that only one instance of DerivativeMonitor is created."""
		        if cls._instance is None:
		            with cls._lock:
		                if cls._instance is None:
		                    cls._instance = super(DerivativeMonitor, cls).__new__(cls)
		        return cls._instance
		
		    def __init__(self, hass_app: Hass) -> None:
		        """Initializes the singleton instance if not already initialized."""
		        if not hasattr(self, "initialized"):
		            self.hass_app = hass_app
		            self.entities: Dict[str, Dict[str, Any]] = {}
		            self.derivative_data: Dict[str, Dict[str, Optional[float]]] = {}
		            self.filter_window_size = (
		                4  # Default window size for moving average filtering
		            )
		            self.initialized = True
		            self.hass_app.log("DerivativeMonitor initialized.", level="DEBUG")
		
		    def register_entity(
		        self,
		        entity_id: str,
		        sample_time: int,
		        low_saturation: float,
		        high_saturation: float,
		    ) -> None:
		        """
		        Registers an entity to monitor with specified sampling time and saturation limits,
		        and creates Home Assistant entities for the first and second derivatives.
		
		        Args:
		            entity_id (str): The ID of the entity to monitor.
		            sample_time (int): Sampling time in seconds for fetching and calculating derivatives.
		            low_saturation (float): Lower saturation limit for derivative values.
		            high_saturation (float): Upper saturation limit for derivative values.
		        """
		        self.hass_app.log(
		            f"Registering entity {entity_id} for derivative monitoring.", level="DEBUG"
		        )
		        self.entities[entity_id] = {
		            "sample_time": sample_time,
		            "low_saturation": low_saturation,
		            "high_saturation": high_saturation,
		            "prev_value": None,
		            "first_derivative": None,
		            "second_derivative": None,
		            "last_sample_time": None,
		            "first_derivative_history": collections.deque(
		                maxlen=self.filter_window_size
		            ),
		            "second_derivative_history": collections.deque(
		                maxlen=self.filter_window_size
		            ),
		        }
		        self.entities[entity_id]["first_derivative_history"].append(0.00)
		        self.entities[entity_id]["second_derivative_history"].append(0.00)
		        # Create derivative entities in Home Assistant with additional attributes
		        self.hass_app.set_state(
		            f"{entity_id}_rate",
		            state=None,
		            attributes={
		                "friendly_name": f"{entity_id} Rate",
		                "unit_of_measurement": "°C/min"
		            },
		        )
		        self.hass_app.set_state(
		            f"{entity_id}_rateOfRate",
		            state=None,
		            attributes={
		                "friendly_name": f"{entity_id} Rate",
		                "unit_of_measurement": "°C/min"
		            },
		        )
		        self.hass_app.log(
		            f"Derivative entities created for {entity_id}.", level="DEBUG"
		        )
		        self.schedule_sampling(entity_id, sample_time)
		
		    def schedule_sampling(self, entity_id: str, sample_time: int) -> None:
		        """
		        Schedules periodic sampling for the specified entity based on its sampling time.
		
		        Args:
		            entity_id (str): The ID of the entity to sample.
		            sample_time (int): Sampling time in seconds.
		        """
		        self.hass_app.log(
		            f"Scheduling sampling for {entity_id} every {sample_time} seconds.",
		            level="DEBUG",
		        )
		        self.hass_app.run_every(
		            self._calculate_diff, "now", sample_time, entity_id=entity_id, sample_time = sample_time
		        )
		
		    def _calculate_diff(self, **kwargs: Dict[str, Any]) -> None:
		        """
		        Calculates the first and second derivatives for a registered entity's state
		        and updates the corresponding Home Assistant entities.
		
		        Args:
		            kwargs (dict): Contains "entity_id" key identifying the entity to process.
		        """
		        entity_id: Dict[str, Any] | None = kwargs.get("entity_id")
		        if not entity_id or entity_id not in self.entities:
		            self.hass_app.log(
		                f"Entity {entity_id} not registered for derivatives.", level="ERROR"
		            )
		            return
		        
		        sample_time: Dict[str, Any] | None = kwargs.get("sample_time")
		
		        self.hass_app.log(f"Calculating derivatives for {entity_id}.", level="DEBUG")
		        entity_config: Dict[str, Any] = self.entities[entity_id]
		        current_value: float | None = self._get_entity_value(entity_id)
		        if current_value is None:
		            self.hass_app.log(
		                f"No value available for {entity_id}. Skipping calculation.",
		                level="DEBUG",
		            )
		            return
		
		        # Calculate first and second derivatives
		        prev_value = entity_config["prev_value"]
		        if prev_value is not None:
		            first_derivative = (current_value - prev_value) * 60.0 / sample_time 
		            first_derivative = max(
		                entity_config["low_saturation"],
		                min(first_derivative, entity_config["high_saturation"]),
		            )
		            prev_first_derivative = entity_config["first_derivative"]
		            second_derivative = (
		                None
		                if prev_first_derivative is None
		                else (first_derivative - prev_first_derivative) * 60.0 / sample_time 
		            )
		            if second_derivative is not None:
		                second_derivative = max(
		                    entity_config["low_saturation"],
		                    min(second_derivative, entity_config["high_saturation"]),
		                )
		
		            # Add to history for filtering
		            if first_derivative:
		                entity_config["first_derivative_history"].append(first_derivative)
		            if second_derivative:
		                entity_config["second_derivative_history"].append(second_derivative)
		
		            # Apply moving average filtering and round to 2 digits
		            filtered_first_derivative = round(
		                sum(entity_config["first_derivative_history"])
		                / len(entity_config["first_derivative_history"]),
		                3,
		            )
		            filtered_second_derivative = round(
		                sum(entity_config["second_derivative_history"])
		                / len(entity_config["second_derivative_history"]),
		                3,
		            )
		
		            entity_config["first_derivative"] = filtered_first_derivative
		            entity_config["second_derivative"] = filtered_second_derivative
		
		            self.hass_app.log(
		                f"Calculated for {entity_id}: First Derivative={filtered_first_derivative}, Second Derivative={filtered_second_derivative}.",
		                level="DEBUG",
		            )
		        entity_config["prev_value"] = current_value
		
		        # Update derivative states in Home Assistant
		        self.hass_app.set_state(
		            f"{entity_id}_rate", state=entity_config["first_derivative"]
		        )
		        # Lets dont update second div
		        # self.hass_app.set_state(
		        #     f"{entity_id}_rateOfRate", state=entity_config["second_derivative"]
		        # )
		        self.hass_app.log(
		            f"Updated Home Assistant states for {entity_id}.", level="DEBUG"
		        )
		
		    def _get_entity_value(self, entity_id: str) -> Optional[float]:
		        """
		        Retrieves the current value of the specified entity.
		
		        Args:
		            entity_id (str): The ID of the entity to retrieve.
		
		        Returns:
		            Optional[float]: The entity's current state as a float, or None if retrieval fails.
		        """
		        try:
		            value = float(self.hass_app.get_state(entity_id))
		            self.hass_app.log(
		                f"Retrieved value for {entity_id}: {value}.", level="DEBUG"
		            )
		            return value
		        except (TypeError, ValueError):
		            self.hass_app.log(
		                f"Unable to retrieve or convert state for {entity_id}.", level="ERROR"
		            )
		            return None
		
		    def get_first_derivative(self, entity_id: str) -> Optional[float]:
		        """
		        Retrieves the first derivative for the specified entity.
		
		        Args:
		            entity_id (str): The ID of the entity.
		
		        Returns:
		            Optional[float]: The latest first derivative or None if unavailable.
		        """
		        self.hass_app.log(f"Getting first derivative for {entity_id}.", level="DEBUG")
		        return self.entities.get(entity_id)["first_derivative"]
		
		    def get_second_derivative(self, entity_id: str) -> Optional[float]:
		        """
		        Retrieves the second derivative for the specified entity.
		
		        Args:
		            entity_id (str): The ID of the entity.
		
		        Returns:
		            Optional[float]: The latest second derivative or None if unavailable.
		        """
		        self.hass_app.log(f"Getting second derivative for {entity_id}.", level="DEBUG")
		        return self.entities.get(entity_id)["second_derivative"]</file>
	<file path='backend\shared\fault_manager.py'>
		"""
		Fault Management Module for Home Assistant Safety System
		
		This module defines the core components and logic necessary for managing faults and symptoms within a Home Assistant-based safety system. It facilitates the detection, tracking, and resolution of fault conditions, integrating closely with safety mechanisms to proactively address potential issues before they escalate into faults.
		
		Classes:
		
		symptom: Represents symptom conditions that are potential precursors to faults.
		Fault: Represents faults within the system, which are conditions requiring attention.
		FaultManager: Manages faults and symptoms, orchestrating detection and response.
		The module supports a many-to-one mapping of symptoms to faults, allowing multiple symptom conditions to contribute to or influence the state of a single fault. This design enables a nuanced and responsive fault management system capable of handling complex scenarios and dependencies within the safety system architecture.
		
		Primary functionalities include:
		
		Initializing and tracking the states of faults and symptoms based on system configuration and runtime observations.
		Dynamically updating fault states in response to changes in associated symptom conditions.
		Executing defined recovery actions and notifications as part of the fault resolution process.
		Generating a unique faulttag for each fault instance to uniquely identify and manage notifications and recovery actions associated with specific faults.
		The faulttag feature is used across the system to create a unique identifier for each fault by hashing the fault name and additional context information. This allows consistent tracking and correlation of notifications, fault states, and recovery actions, ensuring accurate fault management.
		
		This module is integral to the safety system's ability to maintain operational integrity and respond effectively to detected issues, ensuring a high level of safety and reliability.
		
		Note: This module is designed for internal use within the Home Assistant safety system and relies on configurations and interactions with other system components, including safety mechanisms and recovery action definitions.
		"""
		
		from typing import Optional, Callable
		from shared.types_common import FaultState, SMState, Symptom, Fault
		import appdaemon.plugins.hass.hassapi as hass
		import hashlib
		
		
		class FaultManager:
		    """
		    Manages the fault and symptom conditions within the safety management system.
		
		    This includes initializing fault and symptom objects, enabling symptoms, setting and
		    clearing fault states, and managing notifications and recovery actions associated with faults.
		
		    Attributes:
		        notify_man (NotificationManager): The manager responsible for handling notifications.
		        recovery_man (RecoveryManager): The manager responsible for executing recovery actions.
		        faults (dict[str, Fault]): A dictionary of fault objects managed by this manager.
		        symptoms (dict[str, symptom]): A dictionary of symptom objects managed by this manager.
		        sm_modules (dict): A dictionary mapping module names to module objects containing safety mechanisms.
		
		    Args:
		        notify_man (NotificationManager): An instance of the NotificationManager.
		        recovery_man (RecoveryManager): An instance of the RecoveryManager.
		        sm_modules (dict): A dictionary mapping module names to loaded module objects.
		        symptom_dict (dict): A dictionary with symptom configurations.
		        fault_dict (dict): A dictionary with fault configurations.
		    """
		
		    def __init__(
		        self,
		        hass: hass,
		        sm_modules: dict,
		        symptom_dict: dict,
		        fault_dict: dict,
		    ) -> None:
		        """
		        Initialize the Fault Manager.
		
		        :param config_path: Path to the YAML configuration file.
		        """
		        self.notify_interface: (
		            Callable[[str, int, FaultState, dict | None], None] | None
		        ) = None
		        self.recovery_interface: Callable[[Symptom], None] | None = None
		        self.faults: dict[str, Fault] = fault_dict
		        self.symptoms: dict[str, Symptom] = symptom_dict
		        self.sm_modules: dict = sm_modules
		        self.hass: hass.Hass = hass
		
		    def register_callbacks(
		        self,
		        recovery_interface: Callable[[Symptom], None],
		        notify_interface: Callable[[str, int, FaultState, dict | None], None],
		    ) -> None:
		        self.recovery_interface = recovery_interface
		        self.notify_interface = notify_interface
		
		    def init_safety_mechanisms(self) -> None:
		        """
		        Initializes safety mechanisms for each symptom condition.
		
		        This function iterates over all symptoms defined in the system, initializing their respective
		        safety mechanisms as specified by the safety mechanism's name (`sm_name`). It also sets the initial state
		        of the symptoms to DISABLED if initialization is successful, or to ERROR otherwise.
		        """
		        for symptom_name, symptom_data in self.symptoms.items():
		            result: bool = symptom_data.module.init_safety_mechanism(
		                symptom_data.sm_name, symptom_name, symptom_data.parameters
		            )
		            if result:
		                symptom_data.sm_state = SMState.DISABLED
		            else:
		                symptom_data.sm_state = SMState.ERROR
		
		    def get_all_symptom(self) -> dict[str, Symptom]:
		        """
		        Function to return all register symptoms
		        """
		        return self.symptoms
		
		    def enable_all_symptoms(self) -> None:
		        """
		        Enables all symptom safety mechanisms that are currently disabled.
		
		        This method iterates through all symptoms stored in the system, and for each one that is in a DISABLED
		        state, it attempts to enable the safety mechanism associated with it. The enabling function is dynamically
		        invoked based on the `sm_name`. If the enabling operation is successful, the symptom state is updated
		        to ENABLED, otherwise, it remains in ERROR.
		
		        During the enabling process, the system also attempts to fetch and update the state of the safety mechanisms
		        directly through the associated safety mechanism's function, updating the system's understanding of each
		        symptom's current status.
		        """
		        for symptom_name, symptom_data in self.symptoms.items():
		            if symptom_data.sm_state == SMState.DISABLED:
		                self.enable_sm(sm_name=symptom_name, sm_state=SMState.ENABLED)
		
		    def set_symptom(
		        self, symptom_id: str, additional_info: Optional[dict] = None
		    ) -> None:
		        """
		        Sets a symptom to its active state, indicating a potential fault condition.
		
		        This method updates the symptom's state to SET, triggers any associated faults.
		
		        Args:
		            symptom_id (str): The identifier of the symptom to set.
		            additional_info (dict | None, optional): Additional information or context for the symptom. Defaults to None.
		
		        Raises:
		            KeyError: If the specified symptom_id does not exist in the symptoms dictionary.
		        """
		        # Update symptom registry
		        self.symptoms[symptom_id].state = FaultState.SET
		
		        # Call Related Fault
		        self._set_fault(symptom_id, additional_info)
		
		    def clear_symptom(self, symptom_id: str, additional_info: dict) -> None:
		        """
		        Clears a symptom state, indicating that the condition leading to a potential fault has been resolved.
		
		        This method updates the specified symptom's state to CLEARED. It then attempts to clear any
		        associated fault states if applicable. This is an important part of the fault management process,
		        allowing the system to recover from potential issues and restore normal operation.
		
		        The method also triggers notifications and recovery actions if specified for the cleared symptom,
		        based on the provided additional information. This ensures that any necessary follow-up actions
		        are taken to fully address and resolve the condition.
		
		        Args:
		            symptom_id (str): The identifier of the symptom to be cleared.
		            additional_info (dict | None, optional): Additional information or context relevant to the symptom being cleared. Defaults to None.
		
		        Raises:
		            KeyError: If the specified symptom_id does not exist in the symptoms dictionary, indicating an attempt to clear an undefined symptom.
		        """
		        # Update symptom registry
		        self.symptoms[symptom_id].state = FaultState.CLEARED
		
		        # Call Related Fault
		        self._clear_fault(symptom_id, additional_info)
		
		    def disable_symptom(self, symptom_id: str, additional_info: dict) -> None:
		        """
		        TODO
		        """
		        # Update symptom registry
		        self.symptoms[symptom_id].state = FaultState.NOT_TESTED
		
		        # Call Related Fault
		        self._clear_fault(symptom_id, additional_info)
		
		    def check_symptom(self, symptom_id: str) -> FaultState:
		        """
		        Checks the current state of a specified symptom.
		
		        This method returns the current state of the symptom identified by the given `symptom_id`.
		        The state indicates whether the symptom is active (SET), has been cleared (CLEARED), or
		        has not been tested (NOT_TESTED). This allows other parts of the system to query the status
		        of symptoms and make decisions based on their current states.
		
		        Args:
		            symptom_id (str): The identifier of the symptom whose state is to be checked.
		
		        Returns:
		            FaultState: The current state of the specified symptom. Possible states are defined
		                        in the FaultState Enum (NOT_TESTED, SET, CLEARED).
		
		        Raises:
		            KeyError: If the specified symptom_id does not exist in the symptoms dictionary, indicating
		                    an attempt to check an undefined symptom.
		        """
		        return self.symptoms[symptom_id].state
		
		    def _set_fault(self, symptom_id: str, additional_info: Optional[dict]) -> None:
		        """
		        Sets the state of a fault based on a triggered symptom condition.
		
		        This private method is called when a symptom condition is detected (set) and aims to aggregate
		        such symptom conditions to determine if a corresponding fault state should also be set. It involves
		        updating the fault's state to SET, triggering notifications, and executing any defined recovery actions
		        specific to the symptom. The method aggregates several symptoms to evaluate the overall state of
		        a related fault, ensuring comprehensive fault management.
		
		        This process is central to the fault management system's ability to respond to potential issues
		        proactively, allowing for the mitigation of faults through early detection and response.
		
		        Args:
		            symptom_id (str): The identifier of the symptom that triggered this fault setting process.
		            additional_info (dict | None, optional): Additional information or context relevant to the fault being set. This information may be used in notifications and recovery actions. Defaults to None.
		
		        Note:
		            This method should only be called internally within the fault management system, as part of handling
		            symptom conditions. It assumes that a mapping exists between symptoms and faults, allowing for
		            appropriate fault state updates based on symptom triggers.
		        """
		        # Get sm name based on symptom_id
		        sm_name: str = self.symptoms[symptom_id].sm_name
		
		        # Collect all faults mapped from that symptom
		        fault: Fault | None = self.found_mapped_fault(symptom_id, sm_name)
		        if fault:
		            # Generate a unique fault tag using the hash method
		            fault_tag: str = self._generate_fault_tag(fault.name, additional_info)
		            # Save previous value
		            fault.previous_val = fault.state
		            # Set Fault
		            fault.state = FaultState.SET
		            self.update_system_state_entity()  # Update the system state entity
		            self.hass.log(f"Fault {fault.name} was set", level="DEBUG")
		
		            # Determinate additional info
		            info_to_send: dict | None = self._determinate_info(
		                "sensor.fault_" + fault.name, additional_info, FaultState.SET
		            )
		
		            # Prepare the attributes for the state update
		            attributes: dict = info_to_send if info_to_send else {}
		
		            # Set HA entity
		            self.hass.set_state(
		                "sensor.fault_" + fault.name, state="Set", attributes=attributes
		            )
		
		            # Call notifications
		            if self.notify_interface:
		                self.notify_interface(
		                    fault.name,
		                    fault.level,
		                    FaultState.SET,
		                    additional_info,
		                    fault_tag,
		                )
		            else:
		                self.hass.log("No notification interface", level="WARNING")
		
		            # Call recovery actions (specific for symptom)
		            if self.recovery_interface:
		                self.recovery_interface(self.symptoms[symptom_id], fault_tag)
		            else:
		                self.hass.log("No recovery interface", level="WARNING")
		
		    def _determinate_info(
		            self, entity_id: str, additional_info: Optional[dict], fault_state: FaultState
		        ) -> Optional[dict]:
		            """
		            Determine the information to send based on the current state and attributes of the entity,
		            merging or clearing it with additional information provided based on the fault state.
		
		            Args:
		                entity_id (str): The Home Assistant entity ID to check.
		                additional_info (Optional[dict]): Additional details to merge with or clear from the entity's current attributes.
		                fault_state (FaultState): The state of the fault, either Set or Cleared.
		
		            Returns:
		                Optional[dict]: The updated information as a dictionary, or None if there is no additional info.
		            """
		            # If no additional info is provided, return None
		            if not additional_info:
		                return None
		
		            # Retrieve the current state object for the entity
		            state = self.hass.get_state(entity_id, attribute="all")
		            # If the entity does not exist, simply return the additional info if the fault is being set
		            if not state:
		                return additional_info if fault_state == FaultState.SET else {}
		
		            # Get the current attributes of the entity; if none exist, initialize to an empty dict
		            current_attributes = state.get("attributes", {})
		            if fault_state == FaultState.SET:
		                # Prepare the information to send by merging or updating current attributes with additional info
		                info_to_send = current_attributes.copy()
		                for key, value in additional_info.items():
		                    if key in current_attributes and current_attributes[key] not in [
		                        None,
		                        "None",
		                        "",
		                    ]:
		                        # If the current attribute exists and is not None, check if the value needs updating
		                        current_value = current_attributes[key]
		                        # If the current attribute is a comma-separated string, append new value if it's not already included
		                        if isinstance(
		                            current_value, str
		                        ) and value not in current_value.split(", "):
		                            current_value += ", " + value
		                        info_to_send[key] = current_value
		                    else:
		                        # If the current attribute is None or does not exist, set it to the new value
		                        info_to_send[key] = value
		                return info_to_send
		            elif fault_state == FaultState.CLEARED:
		                # Clear specified keys from the current attributes by setting their values to empty strings
		                info_to_send = current_attributes.copy()
		                for key in additional_info.keys():
		                    if key in info_to_send:
		                        # Check if other values need to remain (if it was a list converted to string)
		                        if ", " in info_to_send[key]:
		                            # Remove only the specified value and leave others if any
		                            new_values = [
		                                val
		                                for val in info_to_send[key].split(", ")
		                                if val != additional_info[key]
		                            ]
		                            info_to_send[key] = ", ".join(new_values)
		                        else:
		                            # Set the key's value to an empty string instead of removing it
		                            info_to_send[key] = ""
		                    else:
		                        # If the key does not exist, add it with an empty string value
		                        info_to_send[key] = ""
		                return info_to_send
		
		            return None
		
		    def _clear_fault(self, symptom_id: str, additional_info: dict) -> None:
		        """
		        Clears the state of a fault based on the resolution of a triggering symptom condition.
		
		        This private method is invoked when a symptom condition that previously contributed to setting a fault
		        is resolved (cleared). It assesses the current state of related symptoms to determine whether the associated
		        fault's state can also be cleared. This involves updating the fault's state to CLEARED and triggering appropriate
		        notifications. The method ensures that faults are accurately reflected and managed based on the current status
		        of their contributing symptom conditions.
		
		        Clearing a fault involves potentially complex logic to ensure that all contributing factors are considered,
		        making this method a critical component of the system's ability to recover and return to normal operation after
		        a fault condition has been addressed.
		
		        Args:
		            symptom_id (str): The identifier of the symptom whose resolution triggers the clearing of the fault.
		            additional_info (dict | None, optional): Additional information or context relevant to the fault being cleared. This information may be used to inform notifications. Defaults to None.
		
		        Note:
		            As with `_set_fault`, this method is designed for internal use within the fault management system. It assumes
		            the existence of a logical mapping between symptoms and their corresponding faults, which allows the system
		            to manage fault states dynamically based on the resolution of symptom conditions.
		        """
		
		        # Get sm name based on symptom_id
		        sm_name: str = self.symptoms[symptom_id].sm_name
		
		        # Collect all faults mapped from that symptom
		        fault: Fault | None = self.found_mapped_fault(symptom_id, sm_name)
		
		        if fault and not any(
		            symptom.state == FaultState.SET
		            for symptom in self.symptoms.values()
		            if symptom.sm_name == sm_name
		        ):  # If Fault was found and if other fault related symptoms are not raised
		            # Generate a unique fault tag using the hash method
		            fault_tag: str = self._generate_fault_tag(fault.name, additional_info)
		            # Save previous value
		            fault.previous_val = fault.state
		            # Clear Fault
		            fault.state = FaultState.CLEARED
		            self.hass.log(f"Fault {fault.name} was cleared", level="DEBUG")
		
		            # Determinate additional info
		            info_to_send = self._determinate_info(
		                "sensor.fault_" + fault.name, additional_info, FaultState.CLEARED
		            )
		
		            # Prepare the attributes for the state update
		            attributes = info_to_send if info_to_send else {}
		
		            # Clear HA entity
		            self.hass.set_state(
		                "sensor.fault_" + fault.name, state="Cleared", attributes=attributes
		            )
		            self.update_system_state_entity()  # Update the system state entity
		
		            if fault.previous_val == FaultState.SET:
		                # Call notifications
		                if self.notify_interface:
		                    self.notify_interface(
		                        fault.name,
		                        fault.level,
		                        FaultState.CLEARED,
		                        additional_info,
		                        fault_tag,
		                    )
		                else:
		                    self.hass.log("No notification interface", level="WARNING")
		
		            # Call recovery actions (specific for symptom)
		            if self.recovery_interface:
		                self.recovery_interface(self.symptoms[symptom_id], fault_tag)
		            else:
		                self.hass.log("No recovery interface", level="WARNING")
		
		    def check_fault(self, fault_id: str) -> FaultState:
		        """
		        Checks the current state of a specified fault.
		
		        This method returns the current state of the fault identified by the given `fault_id`.
		        The state indicates whether the fault is active (SET), has been resolved (CLEARED),
		        or has not yet been tested (NOT_TESTED). This functionality allows other components
		        of the system to query the status of faults and adjust their behavior accordingly.
		
		        Args:
		            fault_id (str): The identifier of the fault whose state is to be checked.
		
		        Returns:
		            FaultState: The current state of the specified fault, indicating whether it is
		                        NOT_TESTED, SET, or CLEARED.
		
		        Raises:
		            KeyError: If the specified fault_id does not exist in the faults dictionary,
		                    indicating an attempt to check an undefined fault.
		        """
		        return self.faults[fault_id].state
		
		    def found_mapped_fault(self, symptom_id: str, sm_id: str) -> Optional[Fault]:
		        """
		        Finds the fault associated with a given symptom identifier.
		
		        This private method searches through the registered faults to find the one that is
		        mapped from the specified symptom. This mapping is crucial for the fault management
		        system to correctly associate symptom conditions with their corresponding fault states.
		        It ensures that faults are accurately updated based on the status of triggering symptoms.
		
		        Note that this method assumes a many-to-one mapping between symptoms and faults. If multiple
		        faults are found to be associated with a single symptom, this indicates a configuration or
		        logical error within the fault management setup.
		
		        Args:
		            symptom_id (str): The identifier of the symptom for which the associated fault is sought.
		            sm_id (str) : The identifier of the sm
		
		        Returns:
		            Optional[Fault]: The fault object associated with the specified symptom, if found. Returns
		                            None if no associated fault is found or if multiple associated faults are detected,
		                            indicating a configuration error.
		
		        Note:
		            This method is intended for internal use within the fault management system. It plays a critical
		            role in linking symptom conditions to their corresponding faults, facilitating the automated
		            management of fault states based on system observations and symptom activations.
		        """
		
		        # Collect all faults mapped from that symptom
		        matching_objects: list[Fault] = [
		            fault for fault in self.faults.values() if sm_id in fault.related_symptoms
		        ]
		
		        # Validate there's exactly one occurrence
		        if len(matching_objects) == 1:
		            return matching_objects[0]
		
		        elif len(matching_objects) > 1:
		            self.hass.log(
		                f"Error: Multiple faults found associated with symptom_id '{symptom_id}', indicating a configuration error.",
		                level="ERROR",
		            )
		        else:
		            self.hass.log(
		                f"Error: No faults associated with symptom_id '{symptom_id}'. This may indicate a configuration error.",
		                level="ERROR",
		            )
		
		        return None
		
		    def enable_sm(self, sm_name: str, sm_state: SMState) -> None:
		        """
		        Enables or disables a safety mechanism based on the provided state.
		
		        This method is used to control the state of a specific safety mechanism identified by `sm_name`.
		        It attempts to enable or disable the safety mechanism according to the provided `sm_state`.
		
		        During the enabling process, the system also attempts to fetch and update the state of the safety mechanisms
		        directly through the associated safety mechanism's function, updating the system's understanding of each
		        symptom's current status.
		
		        Args:
		            sm_name (str): The identifier for the safety mechanism to be enabled or disabled.
		            sm_state (SMState): The desired state for the safety mechanism. Must be a valid `SMState` enumeration value.
		
		        Raises:
		            ValueError: If `sm_state` is not a recognized value of the `SMState` enumeration.
		
		        Note:
		            This method also clears all pre-existing fault states associated with the specified safety mechanism
		            when disabling it, setting them to `NOT_TESTED`.
		        """
		        symptom_data: Symptom = self.symptoms[sm_name]
		
		        if sm_state == SMState.ENABLED:
		            # Attempt to enable the safety mechanism
		            result: bool = symptom_data.module.enable_safety_mechanism(
		                sm_name, sm_state
		            )
		
		            if result:
		                symptom_data.sm_state = SMState.ENABLED
		
		                # Fetch and update the state of the safety mechanism directly
		                sm_fcn = getattr(symptom_data.module, symptom_data.sm_name)
		                sm_fcn(symptom_data.module.safety_mechanisms[symptom_data.name])
		            else:
		                symptom_data.sm_state = SMState.ERROR
		
		        elif sm_state == SMState.DISABLED:
		            # Disable the safety mechanism
		            symptom_data.module.enable_safety_mechanism(sm_name, sm_state)
		            symptom_data.sm_state = SMState.DISABLED
		            # Clear all related faults to NOT_TESTED state when disabling the safety mechanism
		            self.disable_symptom(symptom_id=sm_name, additional_info={})
		
		        else:
		            # Handle an unexpected state
		            self.hass.log(
		                f"Error: Unknown SMState '{sm_state}' for safety mechanism '{sm_name}'.",
		                level="ERROR",
		            )
		
		    def _generate_fault_tag(
		        self, fault: str, additional_info: Optional[dict] = None
		    ) -> str:
		        """
		        Generates a unique fault tag by hashing the fault name and additional information.
		
		        Parameters:
		            fault: The fault's name.
		            additional_info: Additional information about the fault, such as location.
		
		        Returns:
		            A unique fault tag as a string.
		        """
		        # Combine fault name and additional info into a single string
		        fault_str = fault
		        if additional_info:
		            # Sort the dictionary items to ensure consistent hash generation
		            sorted_info = sorted(additional_info.items())
		            for key, value in sorted_info:
		                fault_str += f"|{key}:{value}"
		
		        # Generate a hash of the combined string
		        fault_hash = hashlib.sha256(fault_str.encode()).hexdigest()
		        return fault_hash
		    
		    def get_system_fault_level(self) -> int:
		        """
		        Determines the highest severity level of active faults in the system.
		
		        The severity level is based on the `level` attribute of faults.
		        If no faults are active, the system's fault level is considered 0.
		
		        Returns:
		            int: The highest severity level of active faults, or 0 if no faults are active.
		        """
		        highest_level = 0
		        for fault in self.faults.values():
		            if fault.state == FaultState.SET:
		                highest_level = max(highest_level, fault.level)
		        return highest_level
		    
		    def update_system_state_entity(self) -> None:
		        """
		        Updates the Home Assistant entity representing the overall system state.
		
		        The state reflects the highest severity level of active faults.
		        """
		        highest_fault_level = self.get_system_fault_level()
		        attributes = {
		            "fault_count": len(
		                [fault for fault in self.faults.values() if fault.state == FaultState.SET]
		            ),
		            "highest_fault_level": highest_fault_level,
		        }
		        self.hass.set_state(
		            "sensor.system_state",
		            state=str(highest_fault_level),  # Use the fault level as the state
		            attributes=attributes,
		        )</file>
	<file path='backend\shared\notification_manager.py'>
		"""
		Notification Manager Module for Home Assistant Safety System
		
		This module contains the NotificationManager class, designed to handle various types of notifications within a Home Assistant-based safety system. It facilitates the delivery of notifications through Home Assistant's notification services, dashboard updates, and other notification mechanisms such as lights and alarms. The NotificationManager is configurable, allowing for dynamic notification behaviors based on the severity of detected faults and system states.
		
		The NotificationManager class provides a structured way to manage and execute notifications based on predefined levels of urgency. It maps different notification levels to specific methods that handle the logic for each notification type, ensuring that users are informed of system states and faults in a timely and appropriate manner.
		
		Features include:
		
		Configurable notification levels, allowing for tailored responses to different fault conditions.
		Integration with Home Assistant services for sending notifications to devices, updating dashboard states, and controlling home automation entities like lights and alarms.
		Support for additional information in notifications, enabling detailed fault descriptions to be communicated to the user.
		Use of a unique faulttag to manage notifications effectively, ensuring that notifications related to the same fault instance can be tracked and correlated properly.
		The faulttag feature is utilized to uniquely identify notifications associated with specific fault instances, facilitating efficient management of notification lifecycles, such as setting, updating, and clearing notifications. This ensures that users receive coherent and timely information regarding the status of faults.
		
		This module plays a crucial role in the safety system's ability to notify users of faults and system states, contributing to the overall responsiveness and reliability of the system.
		
		Classes:
		
		    NotificationManager: Manages the configuration and execution of notifications within the safety system.
		"""
		from typing import Optional, Callable
		import appdaemon.plugins.hass.hassapi as hass  # type: ignore
		from shared.types_common import FaultState
		
		
		class NotificationManager:
		    """
		    A manager for sending notifications within a Home Assistant-based safety system, using various
		    methods like alerts to mobile devices, dashboard updates, and control of home automation entities
		    (e.g., lights, alarms) based on event severity.
		
		    Attributes:
		        hass_app (hass.Hass): An instance of the Home Assistant application for service calls.
		        notification_config (dict): Configuration for notification preferences, including entity IDs.
		
		    Args:
		        hass_app (hass.Hass): The Home Assistant application instance.
		        notification_config (dict): Configuration for different notification levels and entities.
		    """
		
		    def __init__(self, hass_app: hass.Hass, notification_config: dict):
		        """
		        Initializes the NotificationManager with Home Assistant and notification configurations.
		
		        Parameters:
		            hass_app: Home Assistant application instance for making service calls.
		            notification_config: Configurations for notification levels and corresponding entities.
		        """
		        self.hass_app = hass_app
		        self.notification_config = notification_config
		        self.active_notification: dict[str, dict] = {}
		
		        # Map notification levels to their respective methods
		        self.level_methods: dict[int, Callable | None] = {
		            1: self._notify_level_1_additional,
		            2: self._notify_level_2_additional,
		            3: None,
		            4: None,
		        }
		
		    def notify(
		        self,
		        fault: str,
		        level: int,
		        fault_status: "FaultState",
		        additional_info: Optional[dict],
		        fault_tag: str
		    ) -> None:
		        """
		        Sends or clears notifications based on fault status, using fault name and location as unique tags.
		
		        Parameters:
		            fault: The fault's name, used as a unique tag for the notification.
		            level: Notification level, dictating the notification type.
		            additional_info: Additional fault details (optional) for the notification message.
		            fault_status: Status of the fault ('active' or 'cleared').
		        """
		
		        location = (
		            additional_info.get("Location") if additional_info else "Unknown Location"
		        )
		        message: str = f"Fault: {fault}\n"
		
		        if additional_info:
		            for key, value in additional_info.items():
		                if key != "Location":  # Avoid duplicating the location in the message
		                    message += f"{key}: {value}\n"
		
		        if fault_status == FaultState.SET:
		            self._process_active_fault(level, message, fault_tag)
		            self.hass_app.log(
		                f"Notification set for {fault} at {location} with message: {message}",
		                level="DEBUG",
		            )
		        elif fault_status == FaultState.CLEARED:
		            # Instead of sending a new "cleared" notification, we just clear the existing one.
		            self._process_cleared_fault(level, fault_tag)
		            self.hass_app.log(
		                f"Notification cleared for {fault} at {location}",
		                level="DEBUG",
		            )
		        else:
		            self.hass_app.log(f"Invalid fault status '{fault_status}'", level="WARNING")
		
		    def _process_active_fault(self, level: int, message: str, fault_tag: str) -> None:
		        self._notify_company_app(level, message, fault_tag, FaultState.SET)
		        additional_actions = self.level_methods.get(level)
		        if additional_actions:
		            additional_actions()
		        else:
		            self.hass_app.log(
		                f"Notification level {level} has no additional actions",
		                level="DEBUG",
		            )
		
		    def _process_cleared_fault(self, level: int, fault_tag: str) -> None:
		        # Just clear the existing notification without sending a new message.
		        self._clear_company_app(level, fault_tag)
		
		    def _set_dashboard_notification(self, message: str, level: int) -> None:
		        """
		        Displays a notification message on the Home Assistant dashboard based on severity level.
		
		        Parameters:
		            message: The message to be displayed.
		            level: The message's severity level, influencing its presentation.
		        """
		        # This function assumes that you have an entity in Home Assistant that represents
		        # a text field on a dashboard. You would need to create this entity and configure it
		        # to display messages        dashboard_entity = self.notification_config.get(f"dashboard_{level}_entity")
		        if dashboard_entity:
		            self.hass_app.set_state(dashboard_entity, state=message)
		            self.hass_app.log(
		                f"Dashboard entity {dashboard_entity} was changed to {message}",
		                level="DEBUG",
		            )
		        else:
		            self.hass_app.log(
		                f"No dashboard entity configured for level '{level}'", level="WARNING"
		            )
		
		    def _notify_level_1_additional(self) -> None:
		        """
		        Triggers an immediate response for level 1 notifications by sounding an alarm and turning lights red.
		        This method represents the highest priority action, indicating an immediate emergency.
		
		        Args:
		            message (str): The detailed message for the notification, not directly used in this method but
		                           required for consistency with the interface.
		        """
		        self.hass_app.call_service(
		            "alarm_control_panel/alarm_trigger",
		            entity_id=self.notification_config["alarm_entity"],
		        )
		        self.hass_app.call_service(
		            "light/turn_on",
		            entity_id=self.notification_config["light_entity"],
		            color_name="red",
		        )
		        self.hass_app.log(
		            "Performed _notify_level_1_additional",
		            level="DEBUG",
		        )
		
		    def _notify_level_2_additional(self) -> None:
		        """
		        Handles level 2 notifications by turning lights yellow, symbolizing a hazard that may not require
		        immediate evacuation but still demands attention.
		
		        Args:
		            message (str): The detailed message for the notification, not directly used in this method but
		                           required for consistency with the interface.
		        """
		        self.hass_app.call_service(
		            "light/turn_on",
		            entity_id=self.notification_config["light_entity"],
		            color_name="yellow",
		        )
		        self.hass_app.log(
		            "Performed _notify_level_2_additional",
		            level="DEBUG",
		        )
		
		    def _prepare_notification_data(
		        self, level: int, message: str, fault_tag: str
		    ) -> dict:
		        """
		        Prepares the notification data based on the level and fault details.
		
		        Args:
		            level (int): The urgency level of the notification.
		            fault (str): The fault identifier.
		            message (str): The message to be sent.
		
		        Returns:
		            dict: The notification data ready to be sent.
		        """
		        base_url = "/home-safety/home_safety_overview"
		        common_data = {"persistent": True, "clickAction": base_url, "tag": fault_tag}
		
		        notification_configs = {
		            1: {
		                "title": "Immediate Emergency!",
		                "message": message,
		                "data": {
		                    **common_data,
		                    "color": "#FF0000",  # Red
		                    "vibrationPattern": "100, 1000, 100, 1000, 100",
		                    "sticky": True,
		                    "notification_icon": "mdi:exit-run",
		                    "importance": "high",
		                },
		            },
		            2: {
		                "title": "Hazard!",
		                "message": message,
		                "data": {
		                    **common_data,
		                    "color": "#FFA500",  # Orange
		                    "sticky": True,
		                    "notification_icon": "mdi:hazard-lights",
		                },
		            },
		            3: {
		                "title": "Warning!",
		                "message": message,
		                "data": {
		                    **common_data,
		                    "color": "#FFFF00",  # Yellow
		                    "sticky": True,
		                    "notification_icon": "mdi:home-alert",
		                },
		            },
		            # No direct user notification for level 4
		        }
		        return notification_configs.get(level, {})
		
		    def _notify_company_app(
		        self, level: int, message: str, fault_tag: str, fault_state: FaultState
		    ) -> None:
		        """
		        Sends a company app notification based on the specified level and fault details.
		
		        Args:
		            level (int): The notification level.
		            fault (str): The fault identifier.
		            message (str): The detailed message for the notification.
		        """
		        if level == 4:
		            # No notification is sent for level 4.
		            return
		
		        notification_data = self._prepare_notification_data(level, message, fault_tag)
		        if notification_data:
		            self._handle_notify_reg(fault_tag, fault_state, notification_data)
		            self._send_notification(notification_data)
		            self.hass_app.log(
		                f'Notification for {fault_tag}: {notification_data["title"]} | '
		                f'{notification_data["message"]} | {notification_data["data"]}',
		                level="DEBUG",
		            )
		        else:
		            self.hass_app.log(
		                f"No notification configuration for level {level}", level="WARNING"
		            )
		
		    def _handle_notify_reg(
		        self, fault_tag: str, fault_state: FaultState, notification_data: dict
		    ) -> None:
		        if fault_state == FaultState.SET:
		            self.active_notification[fault_tag] = notification_data
		        else:
		            # Remove the fault from active notifications
		            if fault_tag in self.active_notification:
		                del self.active_notification[fault_tag]
		
		    def _clear_company_app(self, level: int, fault_tag: str) -> None:
		        """
		        Clears the previously-set notification for this fault (by tag), without sending a new message.
		        """
		        # Remove it from the active notifications dictionary if present.
		        if fault_tag in self.active_notification:
		            del self.active_notification[fault_tag]
		
		        # If you're using the generic `notify.notify` service:
		        if level != 4:
		            # The tag must match the tag you originally used in _prepare_notification_data
		            self.hass_app.call_service(
		                "notify/notify",
		                data={
		                    "tag": fault_tag,
		                    "clear_notification": True
		                }
		            )
		            self.hass_app.log(
		                f"Cleared notification (tag='{fault_tag}') via clear_notification request.",
		                level="DEBUG",
		            )
		
		    def _send_notification(self, notification_data: dict[str, str]) -> None:
		        """
		        Sends a notification using the Home Assistant notification service.
		
		        Args:
		            notification_data: A dictionary containing the title, message, and additional data for the notification.
		                - title (str): The title of the notification.
		                - message (str): The main message body of the notification.
		                - data (dict): Additional data for the notification, such as tag, color, and other attributes.
		        """
		        self.hass_app.call_service(
		            "notify/notify",
		            title=notification_data["title"],
		            message=notification_data["message"],
		            data=notification_data["data"],
		        )
		
		    def _add_recovery_action(self, notification_msg: str, fault_tag: str) -> None:
		        """
		        Adds a recovery action message to an existing active notification.
		
		        Args:
		            notification_msg: The recovery message to add.
		            fault_name: The fault identifier for which to add the recovery message.
		        """
		        for tag, notification in self.active_notification.items():
		            if tag == fault_tag:
		                self._add_rec_msg(notification, notification_msg)
		
		    def _add_rec_msg(self, notification: dict, notification_msg: str) -> None:
		        """
		        Appends a recovery message to an existing notification's message and resends the notification.
		
		        Args:
		            notification: The notification data dictionary to update.
		            notification_msg: The recovery message to append.
		        """
		        notification["message"] += f" {notification_msg}"
		        self._send_notification(notification)
		
		    def _clear_symptom_msg(self, notification: dict, notification_msg: str) -> None:
		        """
		        Appends a recovery message to an existing notification's message and resends the notification.
		
		        Args:
		            notification: The notification data dictionary to update.
		            notification_msg: The recovery message to append.
		        """
		        notification["message"] = f"{notification_msg}"
		        self._send_notification(notification)</file>
	<file path='backend\shared\recovery_manager.py'>
		"""
		Recovery Manager Module for Home Assistant Safety System
		
		This module defines the RecoveryManager class, a central component of a safety management system designed to handle the recovery process from fault conditions. 
		The RecoveryManager oversees executing recovery actions in response to detected faults, playing a pivotal role in maintaining the operational integrity and safety of the system.
		
		Overview: The RecoveryManager is built with flexibility in mind, enabling it to manage a wide array of fault conditions through customizable recovery actions. 
		Each recovery action is encapsulated as a callable function, which can be dynamically invoked by the RecoveryManager along with relevant context or parameters necessary for addressing specific faults.
		
		Key Features:
		
		Dynamic Recovery Action Execution: Allows for the invocation of any callable as a recovery action, offering the flexibility to implement a variety of recovery strategies tailored to specific fault scenarios.
		Context-Aware Fault Mitigation: Supports passing additional information to recovery actions, enabling context-aware processing and more effective fault mitigation strategies.
		Simplified Fault Recovery Interface: Provides a straightforward method (recovery) for triggering recovery actions, simplifying the integration of the RecoveryManager into larger safety management systems.
		Integration with Fault Tagging: Uses the faulttag feature to uniquely identify fault instances during recovery actions. This ensures that notifications, recovery, and fault tracking are handled consistently 
		across the system, preventing confusion and ensuring coherent management of fault states.
		Usage: The RecoveryManager is intended to be used within larger safety management or fault handling systems where specific recovery actions are defined for various types of faults. By encapsulating recovery 
		logic within callable functions and associating them with particular fault conditions, system designers can create a comprehensive fault recovery framework capable of addressing a broad spectrum of operational anomalies.
		
		This module's approach to fault recovery empowers developers to construct robust and adaptable safety mechanisms, enhancing the resilience and reliability of automated systems. The faulttag feature helps uniquely identify each fault scenario, aiding in efficient fault resolution and ensuring accurate system state tracking throughout the recovery process.
		"""
		
		from typing import Any, Optional
		import appdaemon.plugins.hass.hassapi as hass  # type: ignore
		from shared.types_common import (
		    RecoveryAction,
		    Symptom,
		    SMState,
		    FaultState,
		    Fault,
		    RecoveryActionState,
		    RecoveryResult,
		)
		from shared.common_entities import CommonEntities
		from shared.fault_manager import FaultManager
		from shared.notification_manager import NotificationManager
		
		
		class RecoveryManager:
		    """
		    Manages the recovery processes for faults within the safety management system.
		
		    This class is responsible for executing recovery actions associated with faults. It acts upon
		    the specified recovery actions by invoking callable functions designed to mitigate or resolve
		    the conditions leading to the activation of faults. The RecoveryManager plays a critical role
		    in the system's ability to respond to and recover from fault conditions, thereby maintaining
		    operational integrity and safety.
		
		    The RecoveryManager is designed to be flexible, allowing recovery actions to be defined as
		    callable functions with associated additional information, facilitating customized recovery
		    strategies for different fault scenarios.
		    """
		
		    def __init__(
		        self,
		        hass_app: hass.Hass,
		        fm: FaultManager,
		        recovery_actions: dict,
		        common_entities: CommonEntities,
		        nm: NotificationManager,
		    ) -> None:
		        """
		        Initializes the RecoveryManager with the necessary application context and recovery configuration.
		
		        The constructor sets up the RecoveryManager by assigning the Home Assistant application context and
		        a dictionary that contains configuration details for various recovery actions. This configuration
		        dictionary is expected to map fault identifiers or types to specific callable functions that
		        represent the recovery actions for those faults.
		
		        Args:
		            hass_app (hass.Hass): The Home Assistant application context, providing access to system-wide
		                functionality and enabling the RecoveryManager to interact with other components and entities
		                within the Home Assistant environment.
		            fm (FaultManager): The FaultManager instance for managing fault conditions.
		            recovery_actions (dict): A dictionary mapping fault names to their corresponding recovery actions.
		            common_entities (CommonEntities): An instance containing common entities required for recovery actions.
		            nm (NotificationManager): The NotificationManager instance for managing notifications related to recovery actions.
		
		        This setup allows the RecoveryManager to dynamically execute the appropriate recovery actions
		        based on the faults detected within the system, promoting a flexible and responsive fault management
		        framework.
		        """
		        self.hass_app: hass.Hass = hass_app
		        self.recovery_actions: dict[str, RecoveryAction] = recovery_actions
		        self.common_entities: CommonEntities = common_entities
		        self.fm: FaultManager = fm
		        self.nm: NotificationManager = nm
		
		        self._init_all_rec_entities()
		
		    def _init_all_rec_entities(self) -> None:
		        for _, recovery_actions in self.recovery_actions.items():
		            self._set_rec_entity(recovery_actions)
		
		    def _isRecoveryConflict(self, symptom: Symptom) -> bool:
		        """
		        Determines if there is a conflict between the given symptom's recovery actions and existing faults.
		
		        This method checks whether executing the recovery actions for a given symptom would
		        conflict with any existing faults. It considers the priority of the faults and matching
		        recovery actions to ensure that the recovery process does not introduce new issues.
		
		        Args:
		            symptom (symptom): The symptom object representing the fault to check for conflicts.
		
		        Returns:
		            bool: True if a conflict exists, False otherwise.
		        """
		        matching_actions: list[str] = self._get_matching_actions(symptom)
		
		        if matching_actions:
		            rec_fault: Fault | None = self.fm.found_mapped_fault(
		                symptom.name, symptom.sm_name
		            )
		            if rec_fault:
		                rec_fault_prio: int = rec_fault.level
		                conflict_status: bool = self._check_conflict_with_matching_actions(
		                    matching_actions, rec_fault_prio, symptom
		                )
		                self.hass_app.log(
		                    f"Conflict status for {symptom} is {conflict_status}", level="DEBUG"
		                )
		                return conflict_status
		
		        return False
		
		    def _get_matching_actions(self, symptom: Symptom) -> list[str]:
		        """
		        Retrieves a list of recovery action names that match the given symptom.
		
		        This method searches for and returns the names of recovery actions that correspond
		        to the given symptom. It is used to identify potential conflicts or applicable
		        recovery strategies based on the symptom's characteristics.
		
		        Args:
		            symptom (symptom): The symptom object representing the fault to match.
		
		        Returns:
		            list[str]: A list of matching recovery action names.
		        """
		        return [
		            name
		            for name, action in self.recovery_actions.items()
		            if action.name in self.recovery_actions[symptom.name].name
		        ]
		
		    def _check_conflict_with_matching_actions(
		        self, matching_actions: list[str], rec_fault_prio: int, symptom: Symptom
		    ) -> bool:
		        """
		        Checks for conflicts between the given symptom's recovery actions and existing faults based on priorities.
		
		        This method evaluates whether the recovery actions for a given symptom would conflict with
		        other existing faults by comparing their priorities. It ensures that higher-priority faults
		        are not adversely affected by the recovery actions for lower-priority faults.
		
		        Args:
		            matching_actions (list[str]): A list of matching recovery action names.
		            rec_fault_prio (int): The priority of the recovery fault.
		            symptom (Symptom): The symptom object representing the fault to check for conflicts.
		
		        Returns:
		            bool: True if a conflict exists, False otherwise.
		        """
		        for found_symptom_name in matching_actions:
		            # Skip the current symptom to avoid self-comparison
		            if found_symptom_name == symptom.name:
		                continue
		
		            found_symptom: Symptom = self.fm.symptoms[found_symptom_name]
		            if found_symptom:
		                found_fault: Fault | None = self.fm.found_mapped_fault(
		                    found_symptom.name, found_symptom.sm_name
		                )
		                if found_fault and found_fault.level > rec_fault_prio:
		                    return True
		
		        return False
		
		    def _perform_recovery(
		        self,
		        symptom: Symptom,
		        notifications: list,
		        entities_changes: dict[str, str],
		        fault_tag: str,
		    ) -> None:
		        """
		        Executes the recovery actions for the given symptom, including notifications and entity changes.
		
		        This method performs the actual recovery process for a given symptom by executing the
		        associated recovery actions. It handles sending notifications and making necessary changes
		        to system entities to resolve the fault condition.
		
		        Args:
		            symptom (symptom): The symptom object representing the fault to recover from.
		            notifications (list): A list of notifications to send as part of the recovery process.
		            entities_changes (dict[str, str]): A dictionary mapping entity names to their new values as part of the recovery process.
		        """
		        rec: RecoveryAction | None = self._find_recovery(symptom.name)
		        if rec:
		            rec.current_status = RecoveryActionState.TO_PERFORM
		            self._set_rec_entity(rec)
		            # Set entitity actions as recovery
		            for entity, value in entities_changes.items():
		                try:
		                    self.hass_app.set_state(entity, state=value)
		                except Exception as err:
		                    self.hass_app.log(
		                        f"Exception during setting {entity} to {value} value. {err}",
		                        level="ERROR",
		                    )
		            for notification in notifications:
		                fault: Fault | None = self.fm.found_mapped_fault(
		                    symptom.name, symptom.sm_name
		                )
		                if fault:
		                    self.nm._add_recovery_action(notification, fault_tag)
		        else:
		            self.hass_app.log(
		                f"Recovery action for {symptom.name} was not found!", level="ERROR"
		            )
		
		    def _find_recovery(self, symptom_name: str) -> RecoveryAction | None:
		        """
		        Finds and returns the recovery action associated with the given symptom name.
		
		        This method searches for and retrieves the recovery action that corresponds to the
		        specified symptom name. It is used to locate the appropriate recovery strategy
		        for a given fault condition.
		
		        Args:
		            symptom_name (str): The name of the symptom to find the recovery action for.
		
		        Returns:
		            RecoveryAction | None: The recovery action associated with the symptom name, or None if not found.
		        """
		        for name, rec in self.recovery_actions.items():
		            if name == symptom_name:
		                return rec
		        return None
		
		    def _set_rec_entity(self, recovery: RecoveryAction) -> None:
		        """
		        Sets the state of the recovery entity in the Home Assistant context.
		
		        This method updates the state of the specified recovery entity in the Home Assistant
		        system. It is used to reflect the current status of the recovery process for monitoring
		        and tracking purposes.
		
		        Args:
		            recovery (RecoveryAction): The recovery action to set the state for.
		        """
		        sensor_name: str = f"sensor.recovery_{recovery.name}".lower()
		        sensor_value: str = str(recovery.current_status.name)
		        self.hass_app.set_state(sensor_name, state=sensor_value)
		
		    def _is_dry_test_failed(
		        self, prefaul_name: str, entities_changes: dict[str, str]
		    ) -> bool:
		        """
		        Runs a dry test to determine if the given entity changes will trigger new faults.
		
		        This method performs a simulation (dry test) to check whether the proposed changes to
		        system entities will cause new faults to be triggered. It ensures that recovery actions
		        do not inadvertently introduce new issues.
		
		        Args:
		            prefaul_name (str): The name of the symptom to test.
		            entities_changes (dict[str, str]): A dictionary mapping entity names to their new values to test.
		
		        Returns:
		            bool: True if the entity changes will trigger new faults, False otherwise.
		        """
		        for symptom_name, symptom_data in self.fm.get_all_symptom().items():
		            if symptom_data.sm_state == SMState.ENABLED:
		                # Force each sm to get state if possible
		                sm_fcn = getattr(symptom_data.module, symptom_data.sm_name)
		                isFaultTrigged = sm_fcn(
		                    symptom_data.module.safety_mechanisms[symptom_data.name],
		                    entities_changes,
		                )
		                if isFaultTrigged and symptom_name is not prefaul_name:
		                    return True
		        return False
		
		    def recovery(self, symptom: Symptom, fault_tag) -> None:
		        """
		        Executes the appropriate recovery action for the given symptom.
		
		        Args:
		            symptom (Symptom): The symptom object representing the fault to recover from.
		        """
		        self.hass_app.log(
		            f"Starting recovery process for symptom: {symptom.name}", level="DEBUG"
		        )
		
		        if symptom.state == FaultState.CLEARED:
		            self.hass_app.log(
		                f"Symptom {symptom.name} is in CLEARED state. Handling cleared state.",
		                level="DEBUG",
		            )
		            self._handle_cleared_state(symptom)
		            return
		
		        potential_recovery_action: RecoveryResult | None = (
		            self._get_potential_recovery_action(symptom)
		        )
		        if not potential_recovery_action:
		            return
		
		        if not self._validate_recovery_action(symptom, potential_recovery_action):
		            return
		
		        self.hass_app.log(
		            f"Validation successful. Executing recovery action for symptom: {symptom.name}",
		            level="DEBUG",
		        )
		        self._execute_recovery(symptom, potential_recovery_action, fault_tag)
		        self.hass_app.log(
		            f"Recovery process completed for symptom: {symptom.name}", level="DEBUG"
		        )
		
		    def _handle_cleared_state(self, symptom: Symptom) -> None:
		        """Handles the cleared state of a symptom by clearing recovery actions."""
		        self.hass_app.log(
		            f"Clearing recovery actions for symptom: {symptom.name}", level="DEBUG"
		        )
		        self._recovery_clear(symptom)
		
		    def _get_potential_recovery_action(
		        self, symptom: Symptom
		    ) -> Optional[RecoveryResult]:
		        """Retrieves the potential recovery action for a given symptom."""
		        if symptom.name not in self.recovery_actions:
		            self.hass_app.log(
		                f"No recovery actions defined for symptom: {symptom.name}",
		                level="DEBUG",
		            )
		            return None
		
		        self.hass_app.log(
		            f"Retrieving potential recovery action for symptom: {symptom.name}",
		            level="DEBUG",
		        )
		        potential_recovery_action: RecoveryAction = self.recovery_actions[symptom.name]
		        potential_recovery_result: Optional[RecoveryResult] = (
		            potential_recovery_action.rec_fun(
		                self.hass_app,
		                symptom,
		                self.common_entities,
		                **potential_recovery_action.params,
		            )
		        )
		
		        if not potential_recovery_result:
		            self.hass_app.log(
		                f"No changes determined for recovery of symptom: {symptom.name}",
		                level="DEBUG",
		            )
		        else:
		            self.hass_app.log(
		                f"Potential recovery result obtained for symptom: {symptom.name}",
		                level="DEBUG",
		            )
		
		        return potential_recovery_result
		
		    def _validate_recovery_action(
		        self, symptom: Symptom, recovery_result: RecoveryResult
		    ) -> bool:
		        """Validates if the recovery action can be safely executed without conflicts."""
		        self.hass_app.log(
		            f"Validating potential recovery action for symptom: {symptom.name}",
		            level="DEBUG",
		        )
		
		        if self._is_dry_test_failed(symptom.name, recovery_result.changed_sensors):
		            self.hass_app.log(
		                f"Recovery action for symptom {symptom.name} will trigger another fault. Aborting recovery.",
		                level="DEBUG",
		            )
		            return False
		
		        if self._isRecoveryConflict(symptom):
		            self.hass_app.log(
		                f"Recovery action for symptom {symptom.name} conflicts with existing faults. Aborting recovery.",
		                level="DEBUG",
		            )
		            return False
		
		        self.hass_app.log(
		            f"Recovery action for symptom {symptom.name} validated successfully.",
		            level="DEBUG",
		        )
		        return True
		
		    def _execute_recovery(
		        self, symptom: Symptom, recovery_result: RecoveryResult, fault_tag: str
		    ) -> None:
		        """Executes the recovery action for a given symptom."""
		        self.hass_app.log(
		            f"Executing recovery for symptom: {symptom.name}", level="DEBUG"
		        )
		        self._perform_recovery(
		            symptom,
		            recovery_result.notifications,
		            recovery_result.changed_actuators,
		            fault_tag,
		        )
		        self.hass_app.log(
		            f"Recovery performed for symptom: {symptom.name}. Setting up listeners for changes.",
		            level="DEBUG",
		        )
		        self._listen_to_changes(
		            symptom,
		            recovery_result.changed_sensors | recovery_result.changed_actuators,
		        )
		        self.hass_app.log(f"Listeners set for symptom: {symptom.name}", level="DEBUG")
		
		    def _recovery_clear(self, symptom: Symptom) -> None:
		        """
		        Clears the recovery action for the given symptom.
		
		        This method clears the internal register and updates the system state to indicate that
		        the recovery action for the specified symptom has been completed and should no longer
		        be performed.
		
		        Args:
		            symptom (symptom): The symptom object representing the fault to clear the recovery action for.
		        """
		        if symptom.name in self.recovery_actions:
		            # Clear internal register
		            self.recovery_actions[symptom.name].current_status = (
		                RecoveryActionState.DO_NOT_PERFORM
		            )
		            # Set HA entity
		            self._set_rec_entity(self.recovery_actions[symptom.name])
		
		    def _listen_to_changes(self, symptom: Symptom, entities_changes: dict) -> None:
		        """
		        Sets up listeners for state changes in the specified entities to monitor recovery action completion.
		
		        This method establishes listeners on the specified entities to detect when the state changes
		        as part of the recovery process. It ensures that the system can respond to and track the completion
		        of recovery actions.
		
		        Args:
		            symptom (symptom): The symptom object representing the fault being recovered from.
		            entities_changes (dict): A dictionary mapping entity names to their new values to monitor.
		        """
		        for name in entities_changes:
		            self.hass_app.listen_state(self._recovery_performed, name, symptom=symptom)
		
		    def _recovery_performed(
		        self, _: Any, __: Any, ___: Any, ____: Any, cb_args: dict
		    ) -> None:
		        """
		        Callback function invoked when a recovery action is performed.
		
		        This method is called when a state change is detected in one of the monitored entities,
		        indicating that a recovery action has been performed. It clears the recovery action for
		        the corresponding symptom.
		
		        Args:
		            _ (Any): Placeholder for the first callback argument (not used).
		            __ (Any): Placeholder for the second callback argument (not used).
		            ___ (Any): Placeholder for the third callback argument (not used).
		            ____ (Any): Placeholder for the fourth callback argument (not used).
		            cb_args (dict): A dictionary containing callback arguments, including the symptom to clear.
		        """
		        self._recovery_clear(cb_args["symptom"])</file>
	<file path='backend\shared\safety_component.py'><![CDATA[
		"""
		This module provides foundational structures and functionalities for implementing advanced safety mechanisms within Home Assistant applications. It introduces a systematic approach to handling, debouncing, and managing state changes of Home Assistant entities, enabling the creation of sophisticated safety and fault management strategies.
		
		Components:
		- `DebounceState`: A named tuple that stores the current state of a debouncing process, including the debounce counter and a flag indicating the necessity of action.
		- `DebounceAction`: An enumeration that defines possible outcomes of the debouncing process, such as setting a symptom condition, clearing it, or taking no action.
		- `DebounceResult`: A named tuple that encapsulates the result of a debouncing process, comprising the action to be taken and the updated counter value.
		- `SafetyComponent`: A base class for creating domain-specific safety components. It provides methods for entity validation, debouncing logic, and interaction with a fault manager to set or clear symptom conditions based on dynamic sensor data.
		- `safety_mechanism_decorator`: A decorator designed to wrap safety mechanism functions, adding pre- and post-execution logic around these functions for enhanced logging and execution control.
		
		Features:
		- Flexible monitoring and debouncing of entity states to prevent rapid toggling and ensure reliable fault detection.
		- Integration with a fault management system, allowing for dynamic response to fault conditions and the ability to set or clear faults programmatically.
		- Extensibility for developing custom safety mechanisms tailored to specific needs and scenarios within the smart home environment.
		
		Usage:
		The module's components are intended to be used as building blocks for developing custom safety mechanisms within Home Assistant. By subclassing `SafetyComponent` and utilizing `DebounceState`, `DebounceAction`, and `DebounceResult`, developers can create robust safety features that respond intelligently to changes in the Home Assistant environment.
		
		Example:
		A developer might create a `TemperatureSafetyComponent` subclass that monitors temperature sensors and uses the debouncing logic to manage heating elements within the home, ensuring a safe and comfortable environment.
		
		This module streamlines the creation of safety mechanisms, emphasizing reliability, flexibility, and integration with Home Assistant's dynamic ecosystem.
		"""
		
		from typing import (
		    Type,
		    Any,
		    get_origin,
		    get_args,
		    Callable,
		    Optional,
		    NamedTuple,
		    Literal,
		)
		from enum import Enum
		
		from shared.fault_manager import FaultManager
		from shared.types_common import FaultState
		import appdaemon.plugins.hass.hassapi as hass  # type: ignore
		from shared.types_common import Symptom, RecoveryAction, SMState
		from shared.common_entities import CommonEntities
		from shared.derivative_monitor import DerivativeMonitor
		
		NO_NEEDED = False
		
		
		class DebounceState(NamedTuple):
		    """
		    Purpose: Acts as a memory for a particular safety mechanism. It stores the current state of the debouncing process for a specific mechanism,
		    including the debounce counter and a flag indicating whether action should be forced for debouncing purposes.
		
		    Usage: This state is maintained across calls to process_symptom to keep track of how many times a condition has been met or not met,
		    helping to stabilize the detection over time by preventing rapid toggling due to transient states.
		
		    Attributes:
		        debounce (int): A counter used to stabilize the detection of a condition over time, preventing rapid toggling.
		        force_sm (bool): A flag indicating whether sm shall be forced for debouncing purpose
		    """
		
		    debounce: int
		    force_sm: bool
		
		
		# Define the named tuple with possible outcomes
		class DebounceAction(Enum):
		    """
		    Enumeration of debouncing actions that can be taken after evaluating a symptom condition.
		
		    Attributes:
		        NO_ACTION (int): Indicates that no action should be taken.
		        symptom_SET (int): Indicates a symptom condition should be set.
		        symptom_HEALED (int): Indicates a symptom condition has been cleared or healed.
		    """
		
		    NO_ACTION = 0
		    symptom_SET = 1
		    symptom_HEALED = -1
		
		
		class DebounceResult(NamedTuple):
		    """
		    Represents the result of a debouncing process, encapsulating the action to be taken and the updated counter value.
		
		    Attributes:
		        action (DebounceAction): The action determined by the debouncing process.
		        counter (int): The updated debounce counter after evaluating the symptom condition.
		    """
		
		    action: DebounceAction
		    counter: int
		
		
		class SafetyComponent:
		    """
		    A base class for creating and managing safety mechanisms within the Home Assistant environment.
		
		    It provides the infrastructure for monitoring entity states, validating entities, debouncing state changes,
		    and interacting with a fault management system. Subclasses can implement specific safety logic, such as
		    monitoring for hazardous conditions and taking corrective actions.
		
		    Attributes:
		        hass_app: Reference to the Home Assistant application instance.
		        fault_man: Optional instance of a fault manager for managing fault conditions.
		
		    Methods:
		        register_fm: Registers a fault manager instance with the safety component.
		        validate_entity: Validates an entity against a specified type.
		        validate_entities: Validates multiple entities against their expected types.
		        safe_float_convert: Safely converts a string to a float.
		        _debounce: Implements debouncing logic for state changes.
		        process_symptom: Processes potential symptom conditions based on debouncing logic.
		    """
		
		    component_name: str = "UNKNOWN"  # Default value for the parent class
		
		    def __init__(self, hass_app: hass.Hass, common_entities: CommonEntities) -> None:
		        """
		        Initialize the safety component.
		
		        :param hass_app: The Home Assistant application instance.
		        """
		        self.hass_app: hass.Hass = hass_app
		        self.fault_man: Optional[FaultManager] = None
		        self.common_entities: CommonEntities = common_entities
		        self.init_common_data()
		        self.derivative_monitor = DerivativeMonitor(hass_app)
		
		    def init_common_data(self) -> None:
		        # Initialize dictionaries that need to be unique to each instance
		        self.safety_mechanisms: dict = {}
		        self.debounce_states: dict = {}
		
		    def get_symptoms_data(
		        self, modules: dict, component_cfg: list[dict[str, Any]]
		    ) -> tuple[dict[str, Symptom], dict[str, RecoveryAction]]:
		        """
		        Abstract method to retrieve symptom configurations and generate corresponding symptom and recovery action objects.
		
		        Args:
		            modules (dict): A dictionary of system modules.
		            component_cfg (list[dict[str, Any]]): A list of dictionaries, each containing a location as the key and a configuration dictionary for that location.
		
		        Returns:
		            tuple: A tuple containing:
		                - dict[str, Symptom]: A dictionary mapping symptom names to Symptom objects.
		                - dict[str, RecoveryAction]: A dictionary mapping symptom names to RecoveryAction objects.
		
		        Raises:
		            NotImplementedError: This method must be implemented in subclasses.
		        """
		        raise NotImplementedError
		
		    def init_safety_mechanism(self, sm_name: str, name: str, parameters: dict) -> bool:
		        """
		        Abstract method to initialize a safety mechanism based on the provided name and parameters.
		
		        Args:
		            sm_name (str): The name of the safety mechanism (e.g., "sm_tc_1" or "sm_tc_2").
		            name (str): The unique identifier for this safety mechanism.
		            parameters (dict): Configuration parameters specific to the safety mechanism.
		
		        Returns:
		            bool: True if initialization is successful, False otherwise.
		
		        Raises:
		            NotImplementedError: This method must be implemented in subclasses.
		        """
		        raise NotImplementedError
		
		    def enable_safety_mechanism(self, name: str, state: SMState) -> bool:
		        """
		        Abstract method to enable or disable a specific safety mechanism.
		
		        Args:
		            name (str): The unique identifier for the safety mechanism.
		            state (SMState): The desired state for the safety mechanism (ENABLED or DISABLED).
		
		        Returns:
		            bool: True if the state change is successful, False otherwise.
		
		        Raises:
		            NotImplementedError: This method must be implemented in subclasses.
		        """
		        raise NotImplementedError
		
		    def register_fm(self, fm: FaultManager) -> None:
		        """
		        Registers a FaultManager instance with this component, enabling interaction with the fault management system.
		
		        This method associates a FaultManager object with the component, allowing it to set or clear fault conditions
		        based on the outcomes of safety mechanism evaluations. The registered FaultManager is essential for the component
		        to communicate fault states and recovery actions within the broader safety management system.
		
		        Args:
		            fm (FaultManager): An instance of FaultManager that will be used by this component to manage fault conditions.
		
		        Note:
		            It's important to register a FaultManager before invoking safety mechanisms that require fault state management
		            to ensure the component can appropriately respond to and manage fault conditions.
		        """
		        self.fault_man = fm
		
		    def validate_entity(
		        self, entity_name: str, entity: Any, expected_type: Type
		    ) -> bool:
		        """
		        Validate a single entity against the expected type.
		
		        :param entity: The entity to validate.
		        :param expected_type: The expected type (e.g., type, List[type], etc.).
		        :return: True if the entity is valid, False otherwise.
		        """
		        # Check for generic types like List[type]
		        if get_origin(expected_type):
		            if not isinstance(entity, get_origin(expected_type)):  # type: ignore
		                self.hass_app.log(
		                    f"Entity {entity_name} should be a {get_origin(expected_type).__name__}",  # type: ignore
		                    level="ERROR",
		                )
		                return False
		            element_type = get_args(expected_type)[0]
		            if not all(isinstance(item, element_type) for item in entity):
		                self.hass_app.log(
		                    f"Elements of entity {entity_name} should be {element_type.__name__}",
		                    level="ERROR",
		                )
		                return False
		        # Non-generic types
		        elif not isinstance(entity, expected_type):
		            self.hass_app.log(
		                f"Entity {entity_name} should be {expected_type.__name__}",
		                level="ERROR",
		            )
		            return False
		
		        return True
		
		    def validate_entities(
		        self, sm_args: dict[str, Any], expected_types: dict[str, Type]
		    ) -> bool:
		        """
		        Validate multiple entities against their expected types based on kwargs.
		
		        This method checks whether each required entity (as specified in `expected_types`)
		        is present in `sm_args` and whether each entity conforms to its expected type.
		
		        Example usage:
		            sm_args = {
		                'window_sensors': ["binary_sensor.window1", "binary_sensor.window2"],
		                'temperature_sensor': "sensor.room_temperature",
		                'threshold': 25.0
		            }
		
		            expected_types = {
		                'window_sensors': List[str],  # Expect a list of strings
		                'temperature_sensor': str,    # Expect a string
		                'threshold': float            # Expect a float
		            }
		
		            if not self.validate_entities(sm_args, expected_types):
		                # Handle validation failure
		                return False
		
		        :param sm_args: The actual keyword arguments passed to the method.
		                        It should contain all the entities required for the safety mechanism.
		        :param expected_types: A dictionary mapping expected variable names to their expected types.
		                               This dict defines what type each entity in `sm_args` should be.
		        :return: True if all required entities are present in `sm_args` and valid, False otherwise.
		        """
		        for entity_name, expected_type in expected_types.items():
		            if entity_name not in sm_args:
		                self.hass_app.log(
		                    f"Missing required argument: {entity_name}", level="ERROR"
		                )
		                return False
		            if not self.validate_entity(
		                entity_name, sm_args[entity_name], expected_type
		            ):
		                # The specific error message will be logged in validate_entity
		                return False
		        return True
		
		    @staticmethod
		    def get_num_sensor_val(hass_app: hass, sensor_id: str) -> float | None:
		        """Fetch and convert temperature from a sensor."""
		        try:
		            return float(hass_app.get_state(sensor_id))
		        except (ValueError, TypeError) as e:
		            hass_app.log(f"Conversion error: {e}", level="WARNING")
		            return None
		
		    @staticmethod
		    def change_all_entities_state(entities: list[str], state: str) -> dict[str, str]:
		        """Create a dictionary to change the state of entities."""
		        return {entity: state for entity in [entities]}  # type: ignore
		
		    def _debounce(
		        self, current_counter: int, pr_test: bool, debounce_limit: int = 3
		    ) -> DebounceResult:
		        """
		        Generic debouncing function that updates the counter based on the state
		        and returns an action indicating whether a symptom should be set, cleared, or no action taken.
		
		        Args:
		            current_counter (int): The current debounce counter for the mechanism.
		            pr_test (bool): The result of the symptom test. True if the condition is detected, False otherwise.
		            debounce_limit (int, optional): The limit at which the state is considered stable. Defaults to 3.
		
		        Returns:
		            DebounceResult: A named tuple containing the action to be taken (DebounceAction) and the updated counter (int).
		        """
		        if pr_test:
		            new_counter: int = min(debounce_limit, current_counter + 1)
		            action: (
		                Literal[DebounceAction.symptom_SET] | Literal[DebounceAction.NO_ACTION]
		            ) = (
		                DebounceAction.symptom_SET
		                if new_counter >= debounce_limit
		                else DebounceAction.NO_ACTION
		            )
		        else:
		            new_counter = max(-debounce_limit, current_counter - 1)
		            action = (
		                DebounceAction.symptom_HEALED
		                if new_counter <= -debounce_limit
		                else DebounceAction.NO_ACTION
		            )
		
		        return DebounceResult(action=action, counter=new_counter)
		
		    def process_symptom(
		        self,
		        symptom_id: str,
		        current_counter: int,
		        pr_test: bool,
		        additional_info: dict,
		        debounce_limit: int = 2,
		    ) -> tuple[int, bool]:
		        """
		        Handles the debouncing of a symptom condition based on a symptom test (pr_test).
		
		        This method manages the symptom state by updating the debounce counter and
		        interacting with the Fault Manager as needed. The symptom state is determined
		        by the result of the pr_test and the current state of the debounce counter.
		        This method is responsible for calling the necessary interfaces from the Fault
		        Manager to set or clear symptom conditions.
		
		        The method returns two values: the updated debounce counter and a boolean
		        indicating whether to inhibit further triggers. If inhibition is true,
		        further triggers are ignored except for time-based events used for debouncing purposes.
		
		        Args:
		            symptom_id (int): The identifier for the symptom condition.
		            current_counter (int): The current value of the debounce counter.
		            pr_test (bool): The result of the symptom test. True if the symptom
		                            condition is detected, False otherwise.
		            debounce_limit (int, optional): The threshold for the debounce counter
		                                            to consider the state stable. Defaults to 3.
		
		        Returns:
		            tuple:
		                - int: The updated debounce counter value.
		                - bool: A flag indicating whether to safety mechanism shall be forced to trigger.
		                        True to force, False to not.
		
		        Raises:
		            None
		        """
		
		        if not self.fault_man:
		            self.hass_app.log("Fault manager not initialized!", level="ERROR")
		            return current_counter, False
		
		        # Prepare retVal
		        force_sm: bool = False
		        debounce_result: DebounceResult = DebounceResult(
		            action=DebounceAction.NO_ACTION, counter=current_counter
		        )
		
		        # Get current symptom state
		        symptom_cur_state: FaultState = self.fault_man.check_symptom(symptom_id)
		        # Check if any actions is needed
		        if (
		            (pr_test and symptom_cur_state == FaultState.CLEARED)
		            or (not pr_test and symptom_cur_state == FaultState.SET)
		            or (symptom_cur_state == FaultState.NOT_TESTED)
		        ):
		            debounce_result = self._debounce(current_counter, pr_test, debounce_limit)
		
		            if debounce_result.action == DebounceAction.symptom_SET:
		                # Call Fault Manager to set symptom
		                self.fault_man.set_symptom(symptom_id, additional_info)
		                self.hass_app.log(
		                    f"symptom {symptom_id} with {additional_info} was set",
		                    level="DEBUG",
		                )
		                force_sm = False
		            elif debounce_result.action == DebounceAction.symptom_HEALED:
		                # Call Fault Manager to heal symptom
		                self.fault_man.clear_symptom(symptom_id, additional_info)
		                self.hass_app.log(
		                    f"symptom {symptom_id} with {additional_info} was cleared",
		                    level="DEBUG",
		                )
		                force_sm = False
		            elif debounce_result.action == DebounceAction.NO_ACTION:
		                force_sm = True
		        else:
		            # Debouncing not necessary at all (Test failed and symptom already raised or
		            #  test passed and fault already cleared)
		            pass
		
		        self.hass_app.log(
		            f"Leaving  process_symptom for {symptom_id} with counter:{debounce_result.counter} and force_sm {force_sm}",
		            level="DEBUG",
		        )
		        return debounce_result.counter, force_sm
		
		    def sm_recalled(self, **kwargs: dict) -> None:
		        """
		        This method should be overridden in the subclass to handle the re-execution of safety mechanisms.
		        If not overridden, it raises a NotImplementedError to signal that the subclass must implement this method.
		
		        Args:
		            **kwargs: A dictionary containing key parameters needed to re-invoke the safety mechanism.
		        """
		        raise NotImplementedError(
		            f"{self.__class__.__name__} must implement its own version of sm_recalled."
		        )
		
		
		def safety_mechanism_decorator(func: Callable) -> Callable:
		    """
		    The safety_mechanism_decorator is a decorator designed to enhance the execution of safety mechanism functions by
		    adding pre- and post-execution logic.    This decorator simplifies the handling of safety mechanisms, particularly
		    when they need to be called either explicitly by the system or scheduled for repeated execution.
		
		    Key Features:
		        Logging: Logs the start and end of the function execution, providing visibility into the operation of the safety mechanism.
		        Conditional Execution: Checks whether the safety mechanism is enabled before execution. If it is disabled, the function exits early without performing any actions.
		        Debouncing and Symptom Processing: Handles debouncing logic to stabilize the detection of safety conditions over time. This prevents rapid toggling of states due to transient conditions.
		        Scheduler Integration: If the safety mechanism requires re-evaluation after a delay, the decorator schedules the sm_recalled function to run the safety mechanism again.
		            This is particularly useful for mechanisms that need to assess conditions over time, such as monitoring temperature changes.
		
		    Workflow:
		        Initial Logging: Logs that the safety mechanism function has started.
		        Check if Enabled: The function checks if the safety mechanism is enabled. If not, it logs this and exits.
		        Execute Function: Calls the safety mechanism function and processes the result.
		        Debouncing Logic: Uses the process_symptom method to update the debounce counter and determine if any action needs to be taken (e.g., setting or clearing a fault condition).
		        Force Re-Evaluation: If the safety mechanism needs to be evaluated again (due to the debouncing logic), the decorator schedules the sm_recalled function to re-execute the safety mechanism after a short delay.
		        Final Logging: Logs the completion of the safety mechanism function.
		
		    This decorator effectively manages the complex scheduling requirements of safety mechanisms by ensuring that they are called at appropriate intervals and that their execution is properly logged and controlled. It provides a robust solution for integrating safety mechanisms into a dynamic environment like Home Assistant, where conditions can change rapidly and require careful monitoring.
		
		    Args:
		        func (Callable): The safety mechanism function to be decorated.
		
		    Returns:
		        Callable: A wrapped version of the input function with added pre- and post-execution logic.
		    """
		
		    def safety_mechanism_wrapper(
		        self: "SafetyComponent",
		        sm: Any,
		        entities_changes: dict[str, str] | None = None,
		    ) -> Any:
		        """
		        Wrapper function for the safety mechanism.
		
		        :param self: The instance of the class where the function is defined.
		        :param sm: Safety mechanism instance.
		        :param entities_changes: Changes in entities, if any.
		        :return: The result of the safety mechanism function.
		        """
		        self.hass_app.log(f"{func.__name__} was started!", level="DEBUG")
		
		        if not sm.isEnabled:
		            self.hass_app.log(
		                f"{func.__name__} is disabled, skipping execution.", level="DEBUG"
		            )
		            return False
		
		        if not entities_changes:
		            # Retrieve the current debounce state for this mechanism
		            current_state: DebounceState = self.debounce_states[sm.name]
		
		            # Get sm result!
		            sm_return = func(self, sm, entities_changes)
		
		            # Perform SM logic
		            new_debounce: tuple[int, bool] = self.process_symptom(
		                symptom_id=sm.name,
		                current_counter=current_state.debounce,
		                pr_test=sm_return.result,
		                additional_info=sm_return.additional_info,
		            )
		
		            # Update the debounce state with the new values
		            self.debounce_states[sm.name] = DebounceState(
		                debounce=new_debounce[0], force_sm=new_debounce[1]
		            )
		            if new_debounce[1]:
		                self.hass_app.log(
		                    f"Scheduling {func.__name__} to run again in 5 seconds.",
		                    level="DEBUG",
		                )
		                # If force_sm is true, schedule to run the function again after 30 seconds TODO Cyclic time shall comes from SafetyMechanism config
		                self.hass_app.run_in(
		                    self.sm_recalled,
		                    30,
		                    sm_method=func.__name__,
		                    sm_name=sm.name,
		                    entities_changes=entities_changes,
		                )
		
		        else:
		            self.hass_app.log(
		                f"{func.__name__} running in dry mode with changes: {entities_changes}",
		                level="DEBUG",
		            )
		            sm_return = func(self, sm, entities_changes)
		
		        self.hass_app.log(f"{func.__name__} was ended!", level="DEBUG")
		        return sm_return.result
		
		    return safety_mechanism_wrapper
		
		
		class SafetyMechanismResult(NamedTuple):
		    result: bool
		    additional_info: Optional[dict[str, Any]] = None]]></file>
	<file path='backend\shared\safety_mechanism.py'>
		"""
		This module defines the SafetyMechanism class for integrating safety-related features into Home Assistant applications.
		It provides a framework for monitoring changes in entity states and executing custom callback functions in response to those changes.
		This enables the creation and management of dynamic safety mechanisms tailored to specific needs within a smart home environment.
		
		The SafetyMechanism class within this module serves as a foundational component for developing safety mechanisms.
		By monitoring specified entities within the Home Assistant environment, it allows for the implementation of custom logic to respond to state changes,
		facilitating automated safety responses and alerts. This mechanism supports a wide range of use cases, from simple notifications to complex safety procedures
		involving multiple entities and conditions.
		
		Key Features:
		- Dynamic monitoring of entity states within the Home Assistant environment.
		- Execution of custom callback functions in response to monitored state changes, allowing for the implementation of bespoke safety logic.
		- Flexible configuration of monitored entities and additional parameters passed to callback functions, supporting a broad array of safety mechanism designs.
		
		This module is designed to be utilized by developers looking to enhance the safety features of their Home Assistant setups,
		offering both ease of use for common use cases and the flexibility to support complex safety scenarios.
		"""
		
		from typing import Callable, List, Any
		import appdaemon.plugins.hass.hassapi as hass  # type: ignore
		
		
		class SafetyMechanism:
		    """
		    A class designed to define and manage safety mechanisms within a Home Assistant environment,
		    allowing for dynamic monitoring and response to changes in entity states.
		
		    Safety mechanisms are defined by a set of entities to monitor and a callback function
		    that is executed when the state of any monitored entity changes. This enables the implementation
		    of custom logic to respond to various events and conditions within a smart home setup.
		
		    Attributes:
		        hass_app: A reference to the Home Assistant application instance, used to interact with the Home Assistant API.
		        entities: A list of entity IDs that this safety mechanism monitors.
		        callback: The callback function that is called when a monitored entity's state changes.
		        name: A user-friendly name for this safety mechanism, used for logging and reference.
		        sm_args: Additional keyword arguments that are passed to the callback function upon execution.
		
		    Methods:
		        setup_listeners: Initializes state change listeners for all monitored entities.
		        entity_changed: A callback method triggered by state changes in monitored entities.
		        extract_entities: Utility method to extract entity IDs from keyword arguments.
		    """
		
		    def __init__(
		        self,
		        hass_app: hass,
		        callback: Callable[..., Any],
		        name: str,
		        isEnabled: bool,
		        **kwargs: Any,
		    ) -> None:
		        """
		        Initializes a new instance of the SafetyMechanism class.
		
		        Args:
		            hass_app: The Home Assistant application instance, providing context for entity monitoring and callbacks.
		            callback: The callback function to be executed when the state of a monitored entity changes.
		                      The function is expected to accept a single argument: an instance of `SafetyMechanism`.
		            name: A descriptive name for this safety mechanism.
		            isEnabled: A flag that indicate if logic shall be executed
		            **kwargs: Additional keyword arguments representing entities to monitor and other parameters
		                      relevant to the specific safety mechanism being implemented. These arguments are
		                      passed through to the callback function.
		        """
		        self.hass_app: Any = hass_app
		        self.entities: List[str] = self.extract_entities(kwargs)
		        self.callback: Callable = callback
		        self.name: str = name
		        self.isEnabled: bool = isEnabled
		        self.sm_args: dict[str, Any] = kwargs
		        self.setup_listeners()
		
		    def setup_listeners(self) -> None:
		        """
		        Configures the Home Assistant listeners for state changes on all entities this safety mechanism is monitoring.
		
		        This method iterates over the `entities` list and registers a callback (`entity_changed`) to be invoked
		        whenever the state of any such entity changes, allowing the safety mechanism to respond to relevant events.
		        """
		        for entity in self.entities:
		            self.hass_app.log(f"Setting up listener for entity: {entity}")
		            self.hass_app.listen_state(self.entity_changed, entity)
		
		    def entity_changed(
		        self, entity: str, _: str, __: Any, ___: Any, **kwargs: dict
		    ) -> None:
		        """
		        Invoked when a state change is detected for any of the monitored entities, triggering the safety mechanism's callback.
		
		        Args:
		            entity: The ID of the entity that experienced a state change.
		            attribute: The specific attribute of the entity that changed (not used in this implementation).
		            old: The previous state of the entity before the change (not used in this implementation).
		            new: The new state of the entity after the change (not used in this implementation).
		            kwargs: A dictionary of additional keyword arguments provided by the listener (not used in this implementation).
		
		        This method logs the state change and then calls the configured callback function, passing itself (`self`) as the argument,
		        allowing the callback to access the safety mechanism's properties and respond appropriately.
		        """
		        self.hass_app.log(f"Entity changed detected for {entity}, calling callback.")
		        self.callback(self)
		
		    def extract_entities(self, kwargs: dict) -> List[str]:
		        """
		        Extracts a list of entity IDs from the keyword arguments passed to the constructor.
		
		        This method supports the flexible specification of entities, allowing for both individual entity IDs and lists of IDs.
		
		        Args:
		            kwargs: A dictionary of keyword arguments passed to the safety mechanism's constructor.
		
		        Returns:
		            A list of entity IDs that are to be monitored by this safety mechanism.
		        """
		        entities = []
		        for _, value in kwargs.items():
		            if isinstance(value, list):
		                entities.extend(value)
		            elif isinstance(value, str):
		                entities.append(value)
		        return entities
		    
		    def disable_sm(self, sm_name : str):
		        
		        self.isEnabled = False</file>
	<file path='backend\shared\temperature_component.py'><![CDATA[
		"""
		This module defines the TemperatureComponent class, part of a Home Assistant-based safety system designed to monitor and respond to temperature-related risks. TemperatureComponent is responsible for managing safety mechanisms that trigger based on direct temperature readings and forecasted temperature changes, providing a dynamic response to potential temperature hazards within a monitored environment.
		
		The component utilizes Home Assistant's infrastructure to monitor temperature sensors and execute predefined safety mechanisms when certain temperature thresholds are reached or forecasted. This system is designed to be configurable, allowing users to define safety mechanisms through external configuration, making it adaptable to various scenarios and requirements.
		
		Classes:
		- DebounceState: A NamedTuple that represents the state of a debounce process.
		- TemperatureComponent: Manages temperature-related safety mechanisms within Home Assistant.
		
		Key Features:
		- Direct temperature monitoring with immediate response mechanisms.
		- Forecasted temperature monitoring for proactive safety measures.
		- Configurable thresholds and response actions to accommodate different monitoring needs and scenarios.
		- Integration with Home Assistant for accessing sensor data and executing actions.
		
		Usage:
		The TemperatureComponent class is intended to be used within a Home Assistant automation setup. Users can define safety mechanisms and their configurations in external YAML files, which the component will read and use to initialize the necessary monitoring and response logic.
		
		Note:
		This module is part of a larger system designed for enhancing safety through Home Assistant. It should be integrated with the appropriate Home Assistant setup and configured according to the specific needs and safety requirements of the environment being monitored.
		"""
		
		import math
		from typing import Dict, Any, Callable, Optional
		from shared.safety_component import (
		    SafetyComponent,
		    safety_mechanism_decorator,
		    DebounceState,
		    SafetyMechanismResult,
		)
		from shared.safety_mechanism import SafetyMechanism
		from shared.types_common import Symptom, RecoveryAction, SMState, RecoveryResult
		from shared.common_entities import CommonEntities
		import appdaemon.plugins.hass.hassapi as hass  # type: ignore
		
		# CONFIG
		DEBOUNCE_INIT = 0
		SM_TC_2_DEBOUNCE_LIMIT = 0
		FORECAST_SAMPLING_TIME = 15  # minutes, but deviratives are ALWAYS in minutes
		
		
		class TemperatureComponent(SafetyComponent):
		    """
		    Manages and orchestrates temperature-related safety mechanisms within the Home Assistant framework.
		    This component is responsible for initializing temperature monitoring mechanisms, processing
		    temperature data, and executing appropriate actions based on configurable thresholds and forecasted conditions.
		
		    It leverages Home Assistant's sensor data to proactively manage temperature risks, employing debouncing strategies
		    to ensure reliable detection and response to temperature fluctuations. The component supports multiple safety mechanisms,
		    each designed to monitor specific conditions and execute defined actions, such as sending alerts or triggering automations.
		    """
		
		    component_name: str = "TemperatureComponent"
		
		    # region Init and enables
		    def __init__(self, hass_app: hass, common_entities: CommonEntities) -> None:  # type: ignore
		        """
		        Initializes the TemperatureComponent instance with the Home Assistant application context, setting up the foundation
		        for temperature-related safety management within the smart home environment.
		
		        Args:
		            hass_app (hass.Hass): The Home Assistant application instance through which sensor data is accessed and actions are executed.
		            common_entities (CommonEntities): A shared object providing access to common entities used across different safety mechanisms.
		        """
		        super().__init__(hass_app, common_entities)
		
		    def get_symptoms_data(
		        self, sm_modules: dict, component_cfg: list[dict[str, Any]]
		    ) -> tuple[Dict[str, Symptom], Dict[str, RecoveryAction]]:
		        """
		        Retrieve symptom configurations from the component configuration and generate corresponding symptom objects.
		
		        Args:
		            sm_modules (dict): A dictionary of system modules.
		            component_cfg (list[dict[str, Any]]): A list of dictionaries where each dictionary
		                contains a single location as the key and a dictionary of configuration data for that location.
		
		        Returns:
		            Tuple[Dict[str, symptom], Dict[str, RecoveryAction]]: Two dictionaries, one for symptoms and one for RecoveryActions.
		        """
		        ret_val_pr: dict[str, Symptom] = {}
		        ret_val_ra: dict[str, RecoveryAction] = {}
		
		        for location_dict in component_cfg:
		            for location, data in location_dict.items():
		                self.hass_app.log(
		                    f"Processing symptoms for location: {location}, data: {data}"
		                )
		                self._process_symptoms_for_location(
		                    sm_modules, location, data, ret_val_pr, ret_val_ra
		                )
		
		        return (ret_val_pr, ret_val_ra)
		
		    def init_safety_mechanism(self, sm_name: str, name: str, parameters: dict) -> bool:
		        """
		        Initializes a safety mechanism based on the provided safety mechanism name.
		
		        Args:
		            sm_name (str): The name of the safety mechanism (e.g., "sm_tc_1" or "sm_tc_2").
		            name (str): The unique name identifying this safety mechanism.
		            parameters (dict): Configuration parameters for the safety mechanism.
		
		        Returns:
		            bool: True if the initialization is successful, False otherwise.
		        """
		        if sm_name == "sm_tc_1":
		            required_keys: list[str] = [
		                "temperature_sensor",
		                "CAL_LOW_TEMP_THRESHOLD",
		                "location",
		            ]
		            sm_method = self.sm_tc_1
		        elif sm_name == "sm_tc_2":
		            required_keys = [
		                "temperature_sensor",
		                "CAL_LOW_TEMP_THRESHOLD",
		                "CAL_FORECAST_TIMESPAN",
		                "location",
		            ]
		            sm_method = self.sm_tc_2
		        else:
		            self.hass_app.log(f"Unknown safety mechanism {sm_name}", level="ERROR")
		            return False
		
		        return self._init_sm(name, parameters, sm_method, required_keys)
		
		    def enable_safety_mechanism(self, name: str, state: SMState) -> bool:
		        """
		        Enables or disables a safety mechanism based on the provided state.
		
		        Args:
		            name (str): The unique name identifying this safety mechanism.
		            state (SMState): The state to set for the safety mechanism (ENABLED or DISABLED).
		
		        Returns:
		            bool: True if the state change is successful, False otherwise.
		        """
		        if name not in self.safety_mechanisms:
		            self.hass_app.log(f"Safety mechanism {name} not found", level="ERROR")
		            return False
		
		        if state == SMState.ENABLED:
		            self.safety_mechanisms[name].isEnabled = True
		            return True
		        elif state == SMState.DISABLED:
		            self.safety_mechanisms[name].isEnabled = False
		            return True
		        else:
		            self.hass_app.log(
		                f"Invalid state {state} for safety mechanism {name}", level="ERROR"
		            )
		            return False
		
		    # endregion
		    # region Safety mechanisms
		    @safety_mechanism_decorator
		    def sm_tc_1(
		        self, sm: SafetyMechanism, entities_changes: dict[str, str] | None = None
		    ) -> SafetyMechanismResult:
		        """
		        The core logic for a direct temperature threshold safety mechanism. It reads current temperature
		        data, compares it against defined thresholds, and, if a risk condition is detected, executes configured
		        actions to mitigate the risk.
		
		        Args:
		            sm (SafetyMechanism): The instance of the safety mechanism being processed.
		            **kwargs: Additional keyword arguments, primarily for future extensions and compatibility.
		
		        Operations:
		            - Retrieves current temperature from the configured sensor.
		            - Applies debouncing to stabilize detection over time.
		            - Triggers configured actions if the temperature crosses the defined threshold.
		
		        Note:
		            This method is wrapped with a decorator to log its execution and handle any exceptions gracefully.
		        """
		        temperature_sensor: str = sm.sm_args["temperature_sensor"]
		        cold_threshold: float = sm.sm_args["cold_thr"]
		        location: str = sm.sm_args["location"]
		
		        # Fetch temperature value, using stubbed value if provided
		        temperature: float | None = self._get_temperature_value(
		            temperature_sensor, entities_changes
		        )
		        if temperature is None:
		            return SafetyMechanismResult(False, None)
		
		        sm_result: bool = temperature < cold_threshold
		        additional_info: dict[str, str] = {"location": location}
		
		        return SafetyMechanismResult(result=sm_result, additional_info=additional_info)
		
		    @safety_mechanism_decorator
		    def sm_tc_2(
		        self, sm: SafetyMechanism, entities_changes: dict[str, str] | None = None
		    ) -> tuple[bool, dict[str, Any] | None]:
		        """
		        Implements logic for a forecast-based temperature change safety mechanism. This method analyzes
		        temperature trends and forecasts future conditions to proactively address potential risks based
		        on predicted temperature changes.
		
		        Args:
		            sm (SafetyMechanism): The safety mechanism instance being evaluated.
		            **kwargs: Arbitrary keyword arguments, allowing for future flexibility in method signatures.
		
		        Operations:
		            - Calculates forecasted temperature using current data and rate of change.
		            - Employs debouncing for reliable forecasting over specified intervals.
		            - Executes preventive actions if forecasted conditions indicate a potential risk.
		
		        Note:
		            Enhanced with a decorator for execution logging and error management, ensuring robust operation.
		        """
		        temperature_sensor: str = sm.sm_args["temperature_sensor"]
		        cold_threshold: float = sm.sm_args["cold_thr"]
		        location: str = sm.sm_args["location"]
		        forecast_span: float = sm.sm_args["forecast_timespan"]
		
		        # Fetch temperature value, using stubbed value if provided
		        temperature: float | None = self._get_temperature_value(
		            temperature_sensor, entities_changes
		        )
		
		        # Fetch temperature value, using stubbed value if provided
		        temperature_rate: float | None = self._get_temperature_value(
		            f"{temperature_sensor}_rate", entities_changes
		        )
		
		        if temperature is None or temperature_rate is None:
		            return SafetyMechanismResult(False, None)
		
		        forecasted_temperature = self.forecast_temperature(
		            temperature, temperature_rate, forecast_span
		        )
		
		        sm_result: bool = forecasted_temperature < cold_threshold
		        additional_info: dict[str, str] = {"location": location}
		
		        return SafetyMechanismResult(result=sm_result, additional_info=additional_info)
		
		    def forecast_temperature(
		        self,
		        initial_temperature: float,
		        dT: float,
		        forecast_timespan_hours: float,
		    ) -> float:
		        """
		        Forecast the temperature using an exponential decay model.
		
		        Parameters:
		        - initial_temperature (float): The initial temperature in degrees Celsius (T_0).
		        - dT (float): The temperature drop per 15 minute (initial rate).
		        - forecast_timespan_hours (float): The timespan for the forecast in hours.
		
		        Returns:
		        - float: The forecasted temperature after the given timespan.
		        """
		        # Convert forecast timespan from hours to minutes
		        forecast_timespan_in_minutes = forecast_timespan_hours * 60
		
		        # Calculate decay constant k based on the initial rate of temperature change
		        k: float = -math.log(
		            (initial_temperature + dT/FORECAST_SAMPLING_TIME) / initial_temperature
		        )
		
		        # Calculate forecasted temperature for the specified timespan using exponential decay
		        forecasted_temperature: float = initial_temperature * math.exp(
		            -k * forecast_timespan_in_minutes
		        )
		
		        return forecasted_temperature
		
		    def sm_recalled(self, **kwargs: dict) -> None:
		        """
		        The sm_recalled function is designed to handle the re-execution of safety mechanisms that require multiple evaluations over time.
		        This function is typically invoked by a scheduler after a delay, allowing for periodic reassessment of safety conditions.
		        It ensures that the safety mechanism is called again with the correct context, enabling continued monitoring and decision-making based on updated data.
		
		        Arguments:
		            kwargs: A dictionary containing key parameters needed to re-invoke the safety mechanism:
		            sm_method: The name of the safety mechanism method to be called (as a string).
		            sm_name: The unique name of the safety mechanism instance.
		            entities_changes: A dictionary containing any changes in entity states that should be considered during the re-evaluation.
		
		        Functionality:
		        Retrieves the method to be invoked based on the sm_method string.
		        Fetches the corresponding SafetyMechanism instance using the sm_name.
		        Calls the safety mechanism method, passing in the relevant safety mechanism instance and any entity changes.
		        The function handles the continued monitoring and evaluation of safety conditions, ensuring that appropriate actions are taken based on the latest data.
		        This function is a critical component in scenarios where the safety mechanism needs to be evaluated multiple times in succession.
		        By using a scheduler, it avoids overwhelming the system with constant checks while still providing timely responses to changing conditions.
		        """
		
		        # Prepare args and functions
		        sm_to_call: Any = getattr(self, kwargs["sm_method"], None)
		        sm: SafetyMechanism = self.safety_mechanisms[kwargs["sm_name"]]
		        entities_changes: dict = kwargs["entities_changes"]
		
		        # Call SM
		        print(f'self:{self} sm:{sm} entities_changes"{entities_changes}')
		        sm_to_call(sm, entities_changes)
		
		    # endregion
		    # region Private functions
		    def _process_symptoms_for_location(
		        self,
		        sm_modules: dict,
		        location: str,
		        data: dict,
		        ret_val_pr: dict,
		        ret_val_ra: dict,
		    ) -> None:
		        """
		        Process symptoms for a given location and update the provided dictionaries.
		
		        Args:
		            sm_modules (dict): A dictionary of system modules.
		            location (str): The location identifier.
		            data (dict): Configuration data specific to the location.
		            ret_val_pr (dict): Dictionary to store generated symptom objects.
		            ret_val_ra (dict): Dictionary to store generated RecoveryAction objects.
		        """
		        # Process SM TC 1
		        self._process_sm_tc(sm_modules, location, data, ret_val_pr, ret_val_ra, tc_number=1)  # type: ignore[misc]
		
		        # Process SM TC 2
		        self._process_sm_tc(sm_modules, location, data, ret_val_pr, ret_val_ra, tc_number=2)  # type: ignore[misc]
		
		    def _process_sm_tc(
		        self,
		        sm_modules: dict,
		        location: str,
		        data: dict,
		        ret_val_pr: dict,
		        ret_val_ra: dict,
		        tc_number: int,
		    ) -> None:
		        """
		        Process a specific SM TC (Safety Mechanism Temperature Condition) and update the provided dictionaries.
		
		        Args:
		            sm_modules (dict): A dictionary of system modules.
		            location (str): The location identifier.
		            data (dict): Configuration data specific to the location.
		            ret_val_pr (dict): Dictionary to store generated symptom objects.
		            ret_val_ra (dict): Dictionary to store generated RecoveryAction objects.
		            tc_number (int): The TC number to process (e.g., 1 or 2).
		        """
		        symptom_name_func = getattr(self, f"_get_sm_tc_{tc_number}_pr_name")
		        symptom_func = getattr(self, f"_get_sm_tc_{tc_number}_symptom")
		        recovery_action_func = getattr(self, f"_get_sm_tc_{tc_number}_recovery_action")
		
		        symptom_name = symptom_name_func(location)
		        symptom = symptom_func(sm_modules, location, data, symptom_name)
		        recovery_action = recovery_action_func(sm_modules, location, data, symptom_name)
		
		        ret_val_pr[symptom_name] = symptom
		        ret_val_ra[symptom_name] = recovery_action
		
		    def _create_symptom(
		        self, modules: dict, location: str, data: dict, symptom_name: str, sm_name: str
		    ) -> Symptom:
		        """
		        Helper function to create a symptom object.
		
		        Args:
		            modules (dict): A dictionary of system modules.
		            location (str): The location identifier.
		            data (dict): Configuration data specific to the symptom.
		            symptom_name (str): The symptom's name.
		            sm_name (str): The safety mechanism name.
		
		        Returns:
		            symptom: The created symptom object.
		        """
		        symptom_params = data.copy()
		        symptom_params["location"] = location
		
		        return Symptom(
		            module=modules[self.__class__.__name__],
		            name=symptom_name,
		            parameters=symptom_params,
		            sm_name=sm_name,
		        )
		
		    def _create_recovery_action(
		        self, location: str, data: dict, action_name: str, default_name: str
		    ) -> RecoveryAction:
		        """
		        Helper function to create a RecoveryAction object.
		
		        Args:
		            location (str): The location identifier.
		            data (dict): Configuration data specific to the recovery action.
		            action_name (str): The recovery action function name.
		            default_name (str): The default name for the recovery action.
		
		        Returns:
		            RecoveryAction: The created RecoveryAction object.
		        """
		        name: str = f"{default_name}{location}"
		        params = {
		            "location": location,
		            "actuator": data.get("actuator"),
		            "window_sensor": data["window_sensor"],
		        }
		        recovery_func = getattr(self, action_name)
		
		        return RecoveryAction(name, params, recovery_func)
		
		    def _get_sm_tc_1_pr_name(self, location: str) -> str:
		        return f"RiskyTemperature{location}"
		
		    def _get_sm_tc_1_symptom(
		        self, modules: dict, location: str, data: dict, symptom_name: str
		    ) -> Symptom:
		        return self._create_symptom(
		            modules, location, data, symptom_name, sm_name="sm_tc_1"
		        )
		
		    def _get_sm_tc_1_recovery_action(
		        self, _: dict, location: str, data: dict, ___: str
		    ) -> RecoveryAction:
		        return self._create_recovery_action(
		            location,
		            data,
		            action_name="RiskyTemperature_recovery",
		            default_name="ManipulateWindow",
		        )
		
		    def _get_sm_tc_2_pr_name(self, location: str) -> str:
		        return f"RiskyTemperature{location}ForeCast"
		
		    def _get_sm_tc_2_symptom(
		        self, modules: dict, location: str, data: dict, symptom_name: str
		    ) -> Symptom:
		        return self._create_symptom(
		            modules, location, data, symptom_name, sm_name="sm_tc_2"
		        )
		
		    def _get_sm_tc_2_recovery_action(
		        self, _: dict, location: str, data: dict, ___: str
		    ) -> RecoveryAction:
		        return self._create_recovery_action(
		            location,
		            data,
		            action_name="RiskyTemperature_recovery",
		            default_name="ManipulateWindow",
		        )
		
		    def _init_sm(
		        self, name: str, parameters: dict, sm_method: Callable, required_keys: list
		    ) -> bool:
		        """
		        Common method to initialize a safety mechanism.
		
		        Args:
		            name (str): The unique name identifying this safety mechanism.
		            parameters (dict): Configuration parameters for the safety mechanism.
		            sm_method (callable): The method to be called for this safety mechanism.
		            required_keys (list): List of keys required in the parameters.
		
		        Returns:
		            bool: True if the initialization is successful, False otherwise.
		        """
		        if name in self.safety_mechanisms:
		            self.hass_app.log(
		                f"Doubled {sm_method.__name__} - Invalid Cfg", level="ERROR"
		            )
		            return False
		
		        extracted_params = self._extract_params(parameters, required_keys)
		
		        # Store the SafetyMechanism instance in the dictionary using the unique name as the key
		        sm_instance: SafetyMechanism = self._create_safety_mechanism_instance(
		            name, sm_method, extracted_params
		        )
		        self.safety_mechanisms[name] = sm_instance
		
		        # Initialize the debounce state for this mechanism
		        self.debounce_states[name] = DebounceState(
		            debounce=DEBOUNCE_INIT, force_sm=False
		        )
		
		        # Additional setup for SM TC 2
		        if sm_method == self.sm_tc_2:
		            self.derivative_monitor.register_entity(
		                extracted_params["temperature_sensor"], 60*FORECAST_SAMPLING_TIME, -2, 2
		            )
		
		        return True
		
		    def _extract_params(self, parameters: dict, required_keys: list) -> dict:
		        """
		        Extracts parameters from the provided dictionary.
		
		        Args:
		            parameters (dict): The parameters to extract.
		            required_keys (list): The required keys for extraction.
		
		        Returns:
		            dict: The extracted parameters.
		        """
		        extracted_params = {}
		        try:
		            for key in required_keys:
		                extracted_params[key] = parameters[key]
		            extracted_params["actuator"] = parameters.get("actuator")
		        except KeyError as e:
		            self.hass_app.log(f"Key not found in sm_cfg: {e}", level="ERROR")
		            return {}
		
		        return extracted_params
		
		    def _create_safety_mechanism_instance(
		        self, name: str, sm_method: Callable, params: dict
		    ) -> SafetyMechanism:
		        """
		        Creates a SafetyMechanism instance.
		
		        Args:
		            name (str): The unique name of the safety mechanism.
		            sm_method (callable): The method to be called for this safety mechanism.
		            params (dict): The parameters for the safety mechanism.
		
		        Returns:
		            SafetyMechanism: The created SafetyMechanism instance.
		        """
		        sm_args = {
		            "hass_app": self.hass_app,
		            "callback": sm_method,
		            "name": name,
		            "isEnabled": False,
		            "temperature_sensor": params["temperature_sensor"],
		            "cold_thr": params["CAL_LOW_TEMP_THRESHOLD"],
		            "location": params["location"],
		            "actuator": params["actuator"],
		        }
		
		        if sm_method == self.sm_tc_2:
		            sm_args.update(
		                {
		                    "forecast_timespan": params["CAL_FORECAST_TIMESPAN"],
		                }
		            )
		
		        return SafetyMechanism(**sm_args)
		
		    def _get_temperature_value(
		        self, sensor_id: str, entities_changes: dict[str, str] | None
		    ) -> float | None:
		        """
		        Fetch and convert temperature from a sensor, using stubbed values if provided.
		
		        Args:
		            sensor_id (str): The ID of the temperature sensor.
		            entities_changes (dict | None): Optional dictionary containing stubbed values for testing.
		
		        Returns:
		            float | None: The temperature value, or None if there was an error.
		        """
		        if entities_changes and sensor_id in entities_changes:
		            try:
		                temperature = float(entities_changes[sensor_id])
		                return temperature
		            except (ValueError, TypeError) as e:
		                self.hass_app.log(
		                    f"Error handling stubbed temperature: {e}", level="ERROR"
		                )
		                return None
		        else:
		            return self.get_num_sensor_val(self.hass_app, sensor_id)
		
		    # endregion
		    @staticmethod
		    def RiskyTemperature_recovery(
		        hass_app: hass,
		        symptom: Symptom,
		        common_entities: CommonEntities,
		        **kwargs: dict[str, str],
		    ) -> Optional[RecoveryResult]:
		        """
		        Recovery action for handling risky temperature conditions.
		
		        This method is called when a risky temperature condition is detected. It determines the appropriate
		        recovery actions, such as closing or opening windows, and generates notifications if manual actions are needed.
		
		        Args:
		            hass_app (hass.Hass): The Home Assistant application instance.
		            symptom (symptom): The symptom instance containing the fault parameters.
		            common_entities (CommonEntities): Shared object providing access to common entities.
		            **kwargs (dict): Additional keyword arguments, such as location, actuator, and window sensors.
		
		        Returns:
		            Optional[RecoveryResult]: A NamedTuple containing the changed entities and notifications,
		            or None if an error occurred.
		        """
		        changed_sensors: dict[str, str] = {}
		        changed_actuators: dict[str, str] = {}
		        notifications: list[str] = []
		        location: str = kwargs["location"]  # type: ignore
		        actuator: str = kwargs["actuator"]  # type: ignore
		        window_sensors: list[str] = kwargs["window_sensor"]  # type: ignore
		
		        # Get room temperature
		        meas_room_temp: float | None = SafetyComponent.get_num_sensor_val(
		            hass_app, symptom.parameters["temperature_sensor"]
		        )
		        if meas_room_temp is None:
		            return None
		
		        # Get outside temperature
		        outside_temp_raw: str | None = common_entities.get_outisde_temperature()
		        if not outside_temp_raw:
		            return RecoveryResult(changed_sensors, changed_actuators, notifications)
		
		        outside_temp = float(outside_temp_raw)
		
		        if outside_temp < meas_room_temp:
		            window_sensors_state = "off"
		            actuator_sensors_state = "off"
		            notification: str = f"Please close windows in {location} as recovery action"
		        else:
		            window_sensors_state = "on"
		            actuator_sensors_state = "on"
		            notification: str = f"Please open windows in {location} as recovery action"
		
		        # Close windows if outside temperature is lower
		        changed_sensors = SafetyComponent.change_all_entities_state(
		            window_sensors, window_sensors_state
		        )
		        if actuator:
		            changed_actuators[actuator] = actuator_sensors_state
		        else:
		            notifications.append(notification)
		
		        return RecoveryResult(changed_sensors, changed_actuators, notifications)]]></file>
	<file path='backend\shared\types_common.py'>
		"""
		Module: types_enums.py
		
		This module defines enumeration types used throughout the Safety Functions application,
		particularly within the Home Assistant-based safety management system. These enums
		provide a standardized set of possible states for faults (FaultState) and safety mechanisms (SMState),
		ensuring consistency and clarity in state management and logic flow across the application.
		
		Enums:
		- FaultState: Enumerates the possible states of faults and symptoms, aiding in the
		  identification and management of safety system conditions.
		- SMState: Defines the operational states of Safety Mechanisms (SMs), offering insight
		  into the activity and readiness of these mechanisms.
		
		Usage:
		Import the necessary enums into your module to leverage these predefined states for
		fault management and safety mechanism state tracking. This centralizes state definitions,
		facilitating easier maintenance and updates.
		"""
		
		from enum import Enum
		from typing import Any, NamedTuple, Dict, List
		
		
		class FaultState(Enum):
		    """
		    Represents the possible states of a fault and symptoms within the safety management system.
		
		    Attributes:
		        NOT_TESTED: Initial state, indicating the fault has not yet been tested.
		        SET: Indicates that the fault condition has been detected.
		        CLEARED: Indicates that the fault condition has been resolved.
		    """
		
		    NOT_TESTED = 0
		    SET = 1
		    CLEARED = 2
		
		
		class SMState(Enum):
		    """
		    Defines the operational states of Safety Mechanisms (SMs) within the safety management system.
		
		    This enumeration helps to clearly define and track the current status of each safety mechanism,
		    facilitating status checks and transitions in response to system events or conditions.
		
		    Attributes:
		        ERROR: Represents a state where the safety mechanism has encountered an error.
		        NON_INITIALIZED: Indicates that the safety mechanism has not been initialized yet.
		        DISABLED: The safety mechanism is initialized but currently disabled, not actively monitoring or acting on safety conditions.
		        ENABLED: The safety mechanism is fully operational and actively engaged in monitoring or controlling its designated safety parameters.
		    """
		
		    ERROR = 0
		    NON_INITIALIZED = 1
		    DISABLED = 2
		    ENABLED = 3
		
		
		class RecoveryActionState(Enum):
		    DO_NOT_PERFORM = 0
		    TO_PERFORM = 1
		
		
		class RecoveryAction:
		    """
		    Represents a specific recovery action within the safety management system.
		
		    Each instance of this class represents a discrete recovery action that can be invoked in response to a fault condition.
		    The class encapsulates the basic information necessary to identify and describe a recovery action, making it
		    easier to manage and invoke these actions within the system.
		
		    Attributes:
		        name (str): The name of the recovery action, used to identify and reference the action within the system.
		    """
		
		    def __init__(self, name: Any, params: Any, recovery_action: Any) -> None:
		        """
		        Initializes a new instance of the RecoveryAction with a specific name.
		
		        This constructor sets the name of the recovery action, which is used to identify and manage the action within
		        the safety management system. The name should be unique and descriptive enough to clearly indicate the action's purpose.
		
		        Args:
		            name (str): The name of the recovery action, providing a unique identifier for the action within the system.
		        """
		        self.name: Any = name
		        self.params: dict = params
		        self.rec_fun: Any = recovery_action
		        self.current_status: RecoveryActionState = RecoveryActionState.DO_NOT_PERFORM
		
		
		class Symptom:
		    """
		    Represents a symptom condition within the system, potentially leading to a fault.
		
		    symptoms are conditions identified as precursors to faults, allowing preemptive actions
		    to avoid faults altogether or mitigate their effects.
		
		    Attributes:
		        name (str): The name of the symptom.
		        sm_name (str): The name of the safety mechanism associated with this symptom.
		        module (SafetyComponent): The module where the safety mechanism is defined.
		        parameters (dict): Configuration parameters for the symptom.
		        recover_actions (Callable | None): The recovery action to execute if this symptom is triggered.
		        state (FaultState): The current state of the symptom.
		        sm_state (SMState): The operational state of the associated safety mechanism.
		
		    Args:
		        name (str): The name identifier of the symptom.
		        sm_name (str): The safety mechanism's name associated with this symptom.
		        module: The module object where the safety mechanism's logic is implemented.
		        parameters (dict): A dictionary of parameters relevant to the symptom condition.
		        recover_actions (Callable | None, optional): A callable that executes recovery actions for this symptom. Defaults to None.
		    """
		
		    def __init__(
		        self,
		        name: str,
		        sm_name: str,
		        module: "SafetyComponent",  # type: ignore
		        parameters: dict,
		    ) -> None:
		        self.name: str = name
		        self.sm_name: str = sm_name
		        self.module: "SafetyComponent" = module
		        self.state: FaultState = FaultState.NOT_TESTED
		        self.parameters: dict = parameters
		        self.sm_state = SMState.NON_INITIALIZED
		
		
		class Fault:
		    """
		    Represents a fault within the safety management system.
		
		    A fault is a condition that has been identified as an error or failure state within
		    the system, requiring notification and possibly recovery actions.
		
		    Attributes:
		        name (str): The name of the fault.
		        state (FaultState): The current state of the fault.
		        related_symptoms (list): A list of symptoms related to this fault.
		        level (int): The severity level of the fault for notification purposes.
		
		    Args:
		        name (str): The name identifier of the fault.
		        related_symptoms (list): List of names of safety mechanism that can trigger this fault.
		        level (int): The severity level assigned to this fault for notification purposes.
		    """
		
		    def __init__(self, name: str, related_symptoms: list, level: int):
		        self.name: str = name
		        self.state: FaultState = FaultState.NOT_TESTED
		        self.previous_val = FaultState.NOT_TESTED
		        self.related_symptoms: list = related_symptoms
		        self.level: int = level
		
		
		class RecoveryResult(NamedTuple):
		    """
		    A named tuple that encapsulates the result of a recovery action.
		
		    Attributes:
		        changed_sensors (Dict[str, str]): A dictionary mapping sensor names to their new states.
		        changed_actuators (Dict[str, str]): A dictionary mapping actuator names to their new states.
		        notifications (List[str]): A list of notifications that provide information about manual actions needed.
		    """
		
		    changed_sensors: Dict[str, str]
		    changed_actuators: Dict[str, str]
		    notifications: List[str]</file>
	<file path='backend\templates\CustomSafetyComponent.py'>
		"""
		This module defines a template for a custom safety component within a Home Assistant-based safety system.
		This component is responsible for monitoring specific conditions and managing safety mechanisms to mitigate risks
		associated with these conditions. This template serves as a foundation to build domain-specific safety components.
		
		Classes:
		- CustomSafetyComponent: Manages custom safety mechanisms within Home Assistant.
		
		Usage:
		The CustomSafetyComponent class can be customized to implement specific monitoring and safety response
		mechanisms, using Home Assistant's infrastructure to interact with sensors and execute safety actions.
		"""
		
		from typing import Dict, Any, Callable, Optional
		from shared.safety_component import (
		    SafetyComponent,
		    safety_mechanism_decorator,
		    DebounceState,
		    SafetyMechanismResult,
		)
		from shared.safety_mechanism import SafetyMechanism
		from shared.types_common import Symptom, RecoveryAction, SMState
		from shared.common_entities import CommonEntities
		import appdaemon.plugins.hass.hassapi as hass  # type: ignore
		
		
		class CustomSafetyComponent(SafetyComponent):
		    """
		    CustomSafetyComponent is a template for implementing specific safety components that monitor 
		    Home Assistant entities and respond to configured conditions. It serves as a base to add 
		    multiple safety mechanisms as needed.
		    
		    Attributes:
		        component_name (str): The name identifier for this component.
		    """
		
		    component_name: str = "CustomSafetyComponent"
		
		    def __init__(self, hass_app: hass, common_entities: CommonEntities) -> None:
		        """
		        Initializes the CustomSafetyComponent with Home Assistant context.
		
		        Args:
		            hass_app (hass.Hass): Home Assistant instance for accessing and controlling entities.
		            common_entities (CommonEntities): Shared entities accessible across safety mechanisms.
		        """
		        super().__init__(hass_app, common_entities)
		
		    def get_symptoms_data(
		        self, sm_modules: dict, component_cfg: list[dict[str, Any]]
		    ) -> tuple[Dict[str, Symptom], Dict[str, RecoveryAction]]:
		        """
		        Retrieve and generate symptom and recovery action configurations for the component.
		
		        Args:
		            sm_modules (dict): System modules used by safety mechanisms.
		            component_cfg (list[dict[str, Any]]): Configuration data specific to this component.
		
		        Returns:
		            tuple: Contains a dictionary of symptoms and a dictionary of recovery actions.
		        """
		        # Implementation placeholder
		        raise NotImplementedError
		
		    def init_safety_mechanism(self, sm_name: str, name: str, parameters: dict) -> bool:
		        """
		        Initializes a safety mechanism with the given parameters.
		
		        Args:
		            sm_name (str): The safety mechanism identifier.
		            name (str): A unique name for this safety mechanism instance.
		            parameters (dict): Configuration parameters specific to the safety mechanism.
		
		        Returns:
		            bool: True if initialization is successful, False otherwise.
		        """
		        # Replace with specific initialization logic as needed
		        raise NotImplementedError
		
		    def enable_safety_mechanism(self, name: str, state: SMState) -> bool:
		        """
		        Enable or disable a specific safety mechanism.
		
		        Args:
		            name (str): Unique name for the safety mechanism.
		            state (SMState): State to enable or disable the mechanism.
		
		        Returns:
		            bool: True if the operation is successful, False otherwise.
		        """
		        # Replace with specific enable/disable logic
		        raise NotImplementedError
		
		    # region Example Safety Mechanism
		    @safety_mechanism_decorator
		    def sm_example_1(
		        self, sm: SafetyMechanism, entities_changes: dict[str, str] | None = None
		    ) -> SafetyMechanismResult:
		        """
		        Implements a sample safety mechanism. This mechanism can be configured to monitor an entity
		        and respond if certain conditions are met.
		
		        Args:
		            sm (SafetyMechanism): Instance of the safety mechanism being evaluated.
		            entities_changes (dict[str, str] | None): Optional dictionary of entity state changes for testing.
		
		        Returns:
		            SafetyMechanismResult: Result indicating whether the mechanism was triggered, and any additional info.
		        """
		        monitored_entity: str = sm.sm_args.get("monitored_entity")
		        threshold: float = sm.sm_args.get("threshold", 0.0)
		
		        # Fetch current entity value
		        entity_value: float | None = self._get_entity_value(monitored_entity, entities_changes)
		
		        if entity_value is None:
		            return SafetyMechanismResult(False, None)
		
		        # Placeholder for actual safety condition check
		        is_condition_met = entity_value > threshold
		        additional_info = {"entity": monitored_entity, "threshold": threshold}
		
		        return SafetyMechanismResult(result=is_condition_met, additional_info=additional_info)
		
		    # endregion
		
		    # region Private Helper Methods
		    def _get_entity_value(
		        self, entity_id: str, entities_changes: dict[str, str] | None
		    ) -> float | None:
		        """
		        Helper function to fetch and convert an entity's state to a float.
		
		        Args:
		            entity_id (str): The ID of the monitored entity.
		            entities_changes (dict[str, str] | None): Optional dictionary for testing with stubbed values.
		
		        Returns:
		            float | None: The entity's value or None if unavailable or invalid.
		        """
		        if entities_changes and entity_id in entities_changes:
		            try:
		                return float(entities_changes[entity_id])
		            except (ValueError, TypeError):
		                self.hass_app.log(f"Invalid test value for {entity_id}", level="ERROR")
		                return None
		        return self.get_num_sensor_val(self.hass_app, entity_id)
		
		    # Add additional private helper methods as needed for processing symptoms, recovery actions, etc.
		    # endregion</file>
	<file path='backend\tests\__init__.py'/>
	<file path='backend\tests\conftest.py'>
		import pytest
		from .fixtures.hass_fixture import *
		from .fixtures.test_sf_cfgs import *</file>
	<file path='backend\tests\fixtures\__init__.py'/>
	<file path='backend\tests\fixtures\hass_fixture.py'>
		import pytest
		from unittest.mock import MagicMock, patch
		from shared.types_common import FaultState
		from SafetyFunctions import SafetyFunctions
		from shared.temperature_component import TemperatureComponent
		from typing import Any, Generator, List
		from itertools import cycle
		
		
		@pytest.fixture
		def mocked_hass() -> Generator[Any, Any, None]:
		    """Fixture for providing a mocked Hass instance."""
		    with patch("appdaemon.plugins.hass.hassapi.Hass") as MockHass:
		        mock_hass = MockHass()
		        mock_hass.logger = MagicMock()
		        mock_hass.get_state = MagicMock(return_value="on")
		        mock_hass.set_state = MagicMock()
		        mock_hass.call_service = MagicMock()
		        yield mock_hass
		
		
		@pytest.fixture
		def mocked_hass_app_basic(mocked_hass, app_config_valid):
		    """Fixture that initializes SafetyFunctions with mocked Hass and provides state management."""
		    with patch.object(
		        SafetyFunctions, "log", new_callable=MagicMock
		    ) as mock_log_method:
		        app_instance = SafetyFunctions(
		            mocked_hass,
		            "dummy_namespace",
		            mocked_hass.logger,
		            app_config_valid,
		            "mock_config",
		            "dummy_app_config",
		            "dummy_global_vars",
		        )
		
		        mock_behaviors = default_mock_behaviors()
		        app_instance.get_state = MagicMock(
		            side_effect=lambda entity_id, **kwargs: mock_get_state(
		                entity_id, mock_behaviors
		            )
		        )
		        yield app_instance, mocked_hass, mock_log_method
		
		
		@pytest.fixture
		def mocked_hass_app_with_temp_component(mocked_hass, app_config_valid):
		    """Fixture that initializes SafetyFunctions with mocked Hass and TemperatureComponent."""
		    with patch(
		        "shared.temperature_component.TemperatureComponent"
		    ) as MockTemperatureComponent, patch.object(
		        SafetyFunctions, "log", new_callable=MagicMock
		    ) as mock_log_method:
		
		        app_instance = SafetyFunctions(
		            mocked_hass,
		            "dummy_namespace",
		            mocked_hass.logger,
		            app_config_valid,
		            "mock_config",
		            "dummy_app_config",
		            "dummy_global_vars",
		        )
		
		        mock_behaviors = default_mock_behaviors()
		        app_instance.get_state  = MagicMock(
		            side_effect=lambda entity_id, **kwargs: mock_get_state(
		                entity_id, mock_behaviors
		            )
		        )
		        
		        app_instance.set_state = mocked_hass.set_state
		        app_instance.call_service = mocked_hass.call_service
		        
		        yield app_instance, mocked_hass, mock_log_method, MockTemperatureComponent, mock_behaviors
		
		
		def default_mock_behaviors():
		    """Default mock behaviors for sensors."""
		    return [
		        MockBehavior("sensor.office_temperature", iter(["5", "6", "7", "8", "9"])),
		        MockBehavior("sensor.office_temperature_rate", iter(["0", "0", "0", "0", "0"])),
		        MockBehavior("sensor.office_humidity", iter(["45", "50"])),
		        MockBehavior("sensor.fault_RiskyTemperature", iter([None, None, None])),
		        MockBehavior(
		            "sensor.office_window_contact_contact", iter(["off", "off", "off"])
		        ),
		        MockBehavior("sensor.dom_temperature", iter(["1", "1", "1"])),
		    ]
		
		
		class MockBehavior:
		    """Class to simulate sensor behavior for testing."""
		
		    def __init__(self, entity_id, generator):
		        self.entity_id = entity_id
		        self.generator = cycle(generator)
		
		    def get_value(self, called_entity_id):
		        if called_entity_id == self.entity_id:
		            return next(self.generator, None)
		        return None
		
		
		def mock_get_state(entity_id, mock_behaviors):
		    """Simulate get_state based on mock behaviors."""
		    for behavior in mock_behaviors:
		        value = behavior.get_value(entity_id)
		        if value is not None:
		            return value
		    return None
		
		def update_mocked_get_state(default: List[MockBehavior], test_specyfic: List[MockBehavior]) -> List[MockBehavior]:
		    # Create a set of entity_ids already in the default list for quick lookup
		    default_entity_ids = {mock.entity_id for mock in default}
		    
		    # Iterate over the default list to replace existing mocks with those from test_specyfic
		    for idx, default_mock in enumerate(default):
		        matching_mock = next((test_mock for test_mock in test_specyfic if test_mock.entity_id == default_mock.entity_id), None)
		        if matching_mock:
		            default[idx] = matching_mock
		    
		    # Add mocks from test_specyfic that are not present in the default list
		    for test_mock in test_specyfic:
		        if test_mock.entity_id not in default_entity_ids:
		            default.append(test_mock)
		    
		    return default</file>
	<file path='backend\tests\fixtures\test_sf_cfgs.py'>
		import pytest
		# mypy: ignore-errors
		
		@pytest.fixture(scope="module")
		def app_config_valid():
		    return {
		        "module": "SafetyFunctions",
		        "class": "SafetyFunctions",
		        "log_level": "DEBUG",
		        "app_config": {
		            "faults": {
		                "RiskyTemperature": {
		                    "name": "Unsafe temperature",
		                    "level": 2,
		                    "related_sms": ["sm_tc_1"],
		                },
		                "RiskyTemperatureForecast": {
		                    "name": "Unsafe temperature forecast",
		                    "level": 3,
		                    "related_sms": ["sm_tc_2"],
		                },
		            }
		        },
		        "user_config": {
		            "notification": {"light_entity": "light.warning_light"},
		            "common_entities": {"outside_temp": "sensor.dom_temperature"},
		            "safety_components": {
		                "TemperatureComponent": [
		                    {
		                        "Office": {
		                            "CAL_LOW_TEMP_THRESHOLD": 18.0,
		                            "CAL_FORECAST_TIMESPAN": 2.0,  # hours # app cfg
		                            "temperature_sensor": "sensor.office_temperature",
		                            "temperature_sensor_rate": "sensor.office_temperature_rate",  # sampling_rate = 1min
		                            "window_sensor": "sensor.office_window_contact_contact",
		                        },
		                        "Kitchen": {
		                            "CAL_LOW_TEMP_THRESHOLD": 18.0,
		                            "CAL_FORECAST_TIMESPAN": 2.0,  # hours # app cfg
		                            "temperature_sensor": "sensor.kitchen_temperature",
		                            "temperature_sensor_rate": "sensor.kitchen_temperature_rate",  # sampling_rate = 1min
		                            "window_sensor": "sensor.kitchen_window_contact_contact",
		                        },
		                    }
		                ]
		            },
		        },
		    }
		
		
		@pytest.fixture(scope="module")
		def app_config_2_faults_to_single_symptom():
		    return {
		        "SafetyFunctions": {
		            "module": "SafetyFunctions",
		            "class": "SafetyFunctions",
		            "log_level": "DEBUG",
		            "app_config": {
		                "faults": {
		                    "RiskyTemperature": {
		                        "name": "Unsafe temperature",
		                        "level": 2,
		                        "related_sms": ["sm_tc_1"],
		                    },
		                    "RiskyTemperatureForecast": {
		                        "name": "Unsafe temperature forecast",
		                        "level": 3,
		                        "related_sms": ["sm_tc_1"],
		                    },
		                }
		            },
		            "user_config": {
		                "notification": {"light_entity": "light.warning_light"},
		                "common_entities": {"outside_temp": "sensor.dom_temperature"},
		                "safety_components": {
		                    "TemperatureComponent": {
		                        "Office": {
		                            "CAL_LOW_TEMP_THRESHOLD": 18.0,
		                            "CAL_FORECAST_TIMESPAN": 2.0,  # hours # app cfg
		                            "temperature_sensor": "sensor.office_temperature",
		                            "temperature_sensor_rate": "sensor.office_temperature_rate",  # sampling_rate = 1min
		                            "window_sensor": "sensor.office_window_contact_contact",
		                        }
		                    }
		                },
		            },
		        }
		    }
		
		
		@pytest.fixture(scope="module")
		def app_config_fault_withou_smc():
		    return {
		        "SafetyFunctions": {
		            "module": "SafetyFunctions",
		            "class": "SafetyFunctions",
		            "log_level": "DEBUG",
		            "app_config": {
		                "faults": {
		                    "RiskyTemperature": {
		                        "name": "Unsafe temperature",
		                        "level": 2,
		                        "related_sms": ["sm_tc_9999"],
		                    },
		                    "RiskyTemperatureForecast": {
		                        "name": "Unsafe temperature forecast",
		                        "level": 3,
		                        "related_sms": ["sm_tc_9999"],
		                    },
		                }
		            },
		            "user_config": {
		                "notification": {"light_entity": "light.warning_light"},
		                "common_entities": {"outside_temp": "sensor.dom_temperature"},
		                "safety_components": {
		                    "TemperatureComponent": {
		                        "Office": {
		                            "CAL_LOW_TEMP_THRESHOLD": 18.0,
		                            "CAL_FORECAST_TIMESPAN": 2.0,  # hours # app cfg
		                            "temperature_sensor": "sensor.office_temperature",
		                            "temperature_sensor_rate": "sensor.office_temperature_rate",  # sampling_rate = 1min
		                            "window_sensor": "sensor.office_window_contact_contact",
		                        }
		                    }
		                },
		            },
		        }
		    }</file>
	<file path='backend\tests\test_common_entities.py'>
		from unittest.mock import Mock
		import pytest
		from shared.common_entities import CommonEntities
		
		def test_common_entities_initialization():
		    """
		    Test Case: Initialization of CommonEntities.
		
		    Scenario:
		        - The configuration is provided with an outside temperature sensor.
		        - Expected Result: The CommonEntities instance should have the correct sensor name.
		    """
		    # Mock the Home Assistant instance
		    mocked_hass_app = Mock()
		
		    # Configuration with an outside temperature sensor
		    config = {"outside_temp": "sensor.outside_temperature"}
		
		    # Instantiate CommonEntities with the mocked hass_app and configuration
		    common_entities = CommonEntities(mocked_hass_app, config)
		
		    # Verify that the outside_temp_sensor is set correctly
		    assert common_entities.outside_temp_sensor == "sensor.outside_temperature"
		
		def test_get_outside_temperature():
		    """
		    Test Case: Get outside temperature from Home Assistant.
		
		    Scenario:
		        - A valid temperature sensor is provided, and hass_app returns a value.
		        - Expected Result: The temperature value from hass_app should be returned.
		    """
		    # Mock the Home Assistant instance
		    mocked_hass_app = Mock()
		
		    # Configure hass_app to return a temperature value when get_state is called
		    mocked_hass_app.get_state.return_value = "25.5"
		
		    # Configuration with an outside temperature sensor
		    config = {"outside_temp": "sensor.outside_temperature"}
		
		    # Instantiate CommonEntities with the mocked hass_app and configuration
		    common_entities = CommonEntities(mocked_hass_app, config)
		
		    # Call get_outisde_temperature() and verify the returned value
		    temperature = common_entities.get_outisde_temperature()
		    assert temperature == "25.5"
		    mocked_hass_app.get_state.assert_called_with("sensor.outside_temperature")
		
		def test_get_outside_temperature_no_hass_app():
		    """
		    Test Case: Get outside temperature when hass_app is None.
		
		    Scenario:
		        - hass_app is None, so there is no connection to Home Assistant.
		        - Expected Result: The log function should be called to indicate an error, and None should be returned.
		    """
		    # Mock the Home Assistant instance
		    mocked_hass_app = Mock()
		    mocked_hass_app.log = Mock()
		
		    # Configuration with an outside temperature sensor
		    config = {"outside_temp": "sensor.outside_temperature"}
		
		    # Instantiate CommonEntities with the mocked hass_app and configuration
		    common_entities = CommonEntities(mocked_hass_app, config)
		
		    # Set hass_app to None to simulate the absence of Home Assistant connection
		    common_entities.hass_app = None
		
		    # Call get_outisde_temperature() and verify the returned value is None
		    temperature = common_entities.get_outisde_temperature()
		    assert temperature is None</file>
	<file path='backend\tests\test_derivative_monitor.py'><![CDATA[
		import pytest
		from unittest.mock import Mock, call
		from shared.derivative_monitor import DerivativeMonitor
		
		
		@pytest.fixture
		def setup_derivative_monitor():
		    """Fixture to set up a mock Hass app and a fresh DerivativeMonitor instance."""
		    mock_hass = Mock()
		    derivative_monitor = DerivativeMonitor(mock_hass)
		
		    # Clear the state of the singleton
		    derivative_monitor.entities.clear()
		    derivative_monitor.derivative_data.clear()
		    derivative_monitor.initialized = False
		
		    # Use a mutable dictionary to hold state values (ensures proper scoping in closures)
		    state_values = {}
		
		    def mock_get_state(entity_id, **kwargs):
		        return state_values.get(entity_id, None)
		
		    def set_mock_state(entity_id, value):
		        state_values[entity_id] = {"state": value}  # Ensure consistent state structure
		
		    # Attach state change simulation to mock_hass
		    mock_hass.get_state.side_effect = mock_get_state
		    mock_hass.set_state.side_effect = lambda entity_id, state, **kwargs: set_mock_state(
		        entity_id, state
		    )
		
		    return mock_hass, derivative_monitor, set_mock_state
		
		
		def test_register_entity(setup_derivative_monitor):
		    """Verify entity registration and creation of derivative entities in Home Assistant."""
		    mock_hass, derivative_monitor, _ = setup_derivative_monitor
		    entity_id = "sensor.temperature"
		    sample_time = 10
		    low_saturation = -5.0
		    high_saturation = 5.0
		
		    derivative_monitor.register_entity(entity_id, sample_time, low_saturation, high_saturation)
		
		    # Verify entity configuration is stored
		    assert entity_id in derivative_monitor.entities
		    config = derivative_monitor.entities[entity_id]
		    assert config["sample_time"] == sample_time
		    assert config["low_saturation"] == low_saturation
		    assert config["high_saturation"] == high_saturation
		
		    # Verify derivative entities are created in Home Assistant
		    mock_hass.set_state.assert_has_calls(
		        [
		            call(
		                f"{entity_id}_rate",
		                state=None,
		                attributes={'friendly_name': 'sensor.temperature Rate', 'state_class': 'measurement', 'unit_of_measurement': '°C/min', 'attribution': 'Data provided by SafetyFunction', 'device_class': 'temperature', 'icon': 'mdi:chart-timeline-variant'},
		            ),
		            call(
		                f"{entity_id}_rateOfRate",
		                state=None,
		                attributes={'friendly_name': 'sensor.temperature Rate', 'state_class': 'measurement', 'unit_of_measurement': '°C/min', 'attribution': 'Data provided by SafetyFunction', 'device_class': 'temperature', 'icon': 'mdi:chart-timeline-variant'},
		            ),
		        ]
		    )
		    
		    del derivative_monitor
		    del mock_hass
		    del _
		
		    def test_calculate_diff(setup_derivative_monitor):
		        """Test the calculation of first and second derivatives."""
		        mock_hass, derivative_monitor, set_mock_state = setup_derivative_monitor
		
		        entity_id = "sensor.temperature"
		        sample_time = 10
		        low_saturation = -5.0
		        high_saturation = 5.0
		
		        derivative_monitor.register_entity(entity_id, sample_time, low_saturation, high_saturation)
		
		        # Simulate initial state changes
		        set_mock_state(entity_id, 20.0)
		        derivative_monitor._calculate_diff(entity_id=entity_id)
		        assert derivative_monitor.get_first_derivative(entity_id) is None
		        assert derivative_monitor.get_second_derivative(entity_id) is None
		
		        # Simulate second state change
		        set_mock_state(entity_id, 25.0)
		        derivative_monitor._calculate_diff(entity_id=entity_id)
		        assert derivative_monitor.get_first_derivative(entity_id) == 2.5
		        assert derivative_monitor.get_second_derivative(entity_id) == 0.0
		
		        # Simulate third state change
		        set_mock_state(entity_id, 28.0)
		        derivative_monitor._calculate_diff(entity_id=entity_id)
		        assert derivative_monitor.get_first_derivative(entity_id) > 2.5 and derivative_monitor.get_first_derivative(entity_id) < 2.7
		        assert derivative_monitor.get_second_derivative(entity_id) == 0.25
		
		    def test_unregistered_entity_error(setup_derivative_monitor):
		        """Ensure an error is logged for unregistered entities."""
		        mock_hass, derivative_monitor, _ = setup_derivative_monitor
		        entity_id = "sensor.unregistered"
		        derivative_monitor._calculate_diff(entity_id=entity_id)
		        mock_hass.log.assert_called_with(
		            f"Entity {entity_id} not registered for derivatives.", level="ERROR"
		        )]]></file>
	<file path='backend\tests\test_fault_manager.py'>
		from unittest.mock import Mock, patch
		import pytest
		from shared.types_common import FaultState, SMState, Symptom, Fault
		from shared.fault_manager import FaultManager
		
		@pytest.fixture
		def mocked_hass_app():
		    return Mock()
		
		@pytest.fixture
		def symptom():
		    # Creating a mock module for SafetyComponent
		    mock_module = Mock()
		    return Symptom(name="RiskyTemperatureOffice", sm_name="sm_tc_1", module=mock_module, parameters={"CAL_LOW_TEMP_THRESHOLD": 18.0})
		
		@pytest.fixture
		def fault():
		    return Fault(name="RiskyTemperature", related_symptoms=["sm_tc_1"], level=2)
		
		@pytest.fixture
		def fault_manager(mocked_hass_app, symptom, fault):
		    sm_modules = {"TemperatureComponent": Mock()}
		    symptom_dict = {"RiskyTemperatureOffice": symptom}
		    fault_dict = {"RiskyTemperature": fault}
		    return FaultManager(mocked_hass_app, sm_modules, symptom_dict, fault_dict)
		
		def test_fault_manager_initialization(fault_manager, fault, symptom):
		    """
		    Test if the FaultManager initializes correctly with fault and symptom dictionaries.
		    """
		    assert fault_manager.faults["RiskyTemperature"] == fault
		    assert fault_manager.symptoms["RiskyTemperatureOffice"] == symptom
		
		def test_register_callbacks(fault_manager):
		    """
		    Test if register_callbacks sets the notify_interface and recovery_interface properly.
		    """
		    recovery_mock = Mock()
		    notify_mock = Mock()
		    fault_manager.register_callbacks(recovery_mock, notify_mock)
		
		    assert fault_manager.recovery_interface == recovery_mock
		    assert fault_manager.notify_interface == notify_mock
		
		def test_set_symptom(fault_manager, mocked_hass_app):
		    """
		    Test if set_symptom correctly marks a symptom as SET and triggers the fault.
		    """
		    fault_manager._set_fault = Mock()
		
		    fault_manager.set_symptom("RiskyTemperatureOffice")
		    assert fault_manager.symptoms["RiskyTemperatureOffice"].state == FaultState.SET
		    fault_manager._set_fault.assert_called_once_with("RiskyTemperatureOffice", None)
		
		def test_clear_symptom(fault_manager, mocked_hass_app):
		    """
		    Test if clear_symptom correctly marks a symptom as CLEARED and clears the fault.
		    """
		    fault_manager._clear_fault = Mock()
		
		    fault_manager.clear_symptom("RiskyTemperatureOffice", {})
		    assert fault_manager.symptoms["RiskyTemperatureOffice"].state == FaultState.CLEARED
		    fault_manager._clear_fault.assert_called_once_with("RiskyTemperatureOffice", {})
		
		def test_disable_symptom(fault_manager, mocked_hass_app):
		    """
		    Test if disable_symptom correctly marks a symptom as NOT_TESTED and clears the fault.
		    """
		    fault_manager._clear_fault = Mock()
		
		    fault_manager.disable_symptom("RiskyTemperatureOffice", {})
		    assert fault_manager.symptoms["RiskyTemperatureOffice"].state == FaultState.NOT_TESTED
		    fault_manager._clear_fault.assert_called_once_with("RiskyTemperatureOffice", {})
		
		def test_set_fault(fault_manager, mocked_hass_app, fault):
		    """
		    Test if _set_fault correctly sets the fault and calls notification and recovery.
		    """
		    additional_info = {"Location": "Office"}
		    fault_manager._generate_fault_tag = Mock(return_value="mocked_fault_tag")
		    fault_manager.notify_interface = Mock()
		    fault_manager.recovery_interface = Mock()
		
		    # Set up the mock for get_state to return appropriate data
		    mocked_hass_app.get_state = Mock(return_value={"attributes": {"Location": "Kitchen"}})
		    
		    fault_manager._set_fault("RiskyTemperatureOffice", additional_info)
		
		    assert fault.state == FaultState.SET
		    mocked_hass_app.set_state.assert_any_call(
		        "sensor.fault_RiskyTemperature",
		        state="Set",
		        attributes={"Location": "Kitchen, Office"}
		    )
		    fault_manager.notify_interface.assert_any_call(
		        "RiskyTemperature",
		        fault.level,
		        FaultState.SET,
		        additional_info,
		        "mocked_fault_tag"
		    )
		    fault_manager.recovery_interface.assert_called_once_with(fault_manager.symptoms["RiskyTemperatureOffice"], "mocked_fault_tag")
		
		def test_clear_fault(fault_manager, mocked_hass_app, fault):
		    """
		    Test if _clear_fault correctly clears the fault and calls notification and recovery.
		    """
		    additional_info = {"Location": "Office"}
		    fault_manager._generate_fault_tag = Mock(return_value="mocked_fault_tag")
		    fault_manager.notify_interface = Mock()
		    fault_manager.recovery_interface = Mock()
		
		    # Set up the mock for get_state to return appropriate data
		    mocked_hass_app.get_state = Mock(return_value={"attributes": {"Location": "Office"}})
		
		    # Set fault first to test clearing it
		    fault_manager._set_fault("RiskyTemperatureOffice", additional_info)
		
		    # Now clear the fault
		    fault_manager._clear_fault("RiskyTemperatureOffice", additional_info)
		
		    assert fault.state == FaultState.CLEARED
		    mocked_hass_app.set_state.assert_any_call(
		        "sensor.fault_RiskyTemperature",
		        state="Cleared",
		        attributes={"Location": ""}
		    )
		    fault_manager.notify_interface.assert_any_call(
		        "RiskyTemperature",
		        fault.level,
		        FaultState.CLEARED,
		        additional_info,
		        "mocked_fault_tag"
		    )
		    fault_manager.recovery_interface.assert_any_call(fault_manager.symptoms["RiskyTemperatureOffice"], "mocked_fault_tag")
		
		def test_found_mapped_fault(fault_manager, fault):
		    """
		    Test if found_mapped_fault correctly returns the fault mapped from the symptom.
		    """
		    found_fault = fault_manager.found_mapped_fault("RiskyTemperatureOffice", "sm_tc_1")
		    assert found_fault == fault
		
		def test_check_fault(fault_manager):
		    """
		    Test if check_fault returns the correct fault state.
		    """
		    assert fault_manager.check_fault("RiskyTemperature") == FaultState.NOT_TESTED
		
		def test_check_symptom(fault_manager):
		    """
		    Test if check_symptom returns the correct symptom state.
		    """
		    assert fault_manager.check_symptom("RiskyTemperatureOffice") == FaultState.NOT_TESTED
		
		def test_fault_manager_multiple_symptoms(fault_manager, mocked_hass_app, fault):
		    """
		    Test the FaultManager with multiple symptoms, ensuring proper state transitions,
		    notification, and recovery actions for complex scenarios.
		    """
		    # Mock the recovery and notification interfaces
		    fault_manager._generate_fault_tag = Mock(return_value="mocked_fault_tag")
		    fault_manager.notify_interface = Mock()
		    fault_manager.recovery_interface = Mock()
		
		    # Define multiple symptoms for testing
		    symptom_office = Symptom(
		        name="RiskyTemperatureOffice",
		        sm_name="sm_tc_1",
		        module=Mock(),
		        parameters={"CAL_LOW_TEMP_THRESHOLD": 18.0},
		    )
		    symptom_kitchen = Symptom(
		        name="RiskyTemperatureKitchen",
		        sm_name="sm_tc_1",
		        module=Mock(),
		        parameters={"CAL_LOW_TEMP_THRESHOLD": 18.0},
		    )
		
		    # Add symptoms to the fault manager
		    fault_manager.symptoms["RiskyTemperatureOffice"] = symptom_office
		    fault_manager.symptoms["RiskyTemperatureKitchen"] = symptom_kitchen
		
		    # Add a fault that both symptoms relate to
		    fault.related_symptoms = ["sm_tc_1"]
		    fault_manager.faults["RiskyTemperature"] = fault
		
		    # Set up the mock for get_state to simulate a previous location being set
		    mocked_hass_app.get_state = Mock(
		        return_value={"attributes": {"Location": "Living Room"}}
		    )
		
		    # Set the first symptom (Office)
		    additional_info_office = {"Location": "Office"}
		    fault_manager.set_symptom("RiskyTemperatureOffice", additional_info_office)
		
		    # Verify the fault state is set and includes both locations (Living Room, Office)
		    assert fault.state == FaultState.SET
		    mocked_hass_app.set_state.assert_any_call(
		        "sensor.fault_RiskyTemperature",
		        state="Set",
		        attributes={"Location": "Living Room, Office"},
		    )
		    fault_manager.notify_interface.assert_any_call(
		        "RiskyTemperature",
		        fault.level,
		        FaultState.SET,
		        additional_info_office,
		        "mocked_fault_tag",
		    )
		    fault_manager.recovery_interface.assert_any_call(
		        symptom_office, "mocked_fault_tag"
		    )
		    
		    # Set the second symptom (Office)
		    additional_info_kitchen = {"Location": "Kitchen"}
		    fault_manager.set_symptom("RiskyTemperatureKitchen", additional_info_kitchen)
		    
		    # Verify the fault state is set and includes both locations (Living Room, Office)
		    assert fault.state == FaultState.SET
		    mocked_hass_app.set_state.assert_any_call(
		        "sensor.fault_RiskyTemperature",
		        state="Set",
		        attributes={"Location": "Living Room, Kitchen"}, # In normal system shall be also included Office but we dont have HA during tests
		    )
		    fault_manager.notify_interface.assert_any_call(
		        "RiskyTemperature",
		        fault.level,
		        FaultState.SET,
		        additional_info_kitchen,
		        "mocked_fault_tag",
		    )
		    fault_manager.recovery_interface.assert_any_call(
		        symptom_kitchen, "mocked_fault_tag"
		    )
		
		    # Clear the first symptom (Office)
		    fault_manager.clear_symptom("RiskyTemperatureOffice", additional_info_office)
		
		    # Verify that fault remains set because the kitchen symptom is not cleared
		    assert fault.state == FaultState.SET
		    
		    # Clear the second symptom (Kitchen)
		    fault_manager.clear_symptom("RiskyTemperatureKitchen", additional_info_kitchen)
		
		    # Verify the fault is now cleared as all related symptoms are cleared
		    assert fault.state == FaultState.CLEARED
		    mocked_hass_app.set_state.assert_any_call(
		        "sensor.fault_RiskyTemperature",
		        state="Cleared",
		        attributes={"Location": ""},
		    )
		    fault_manager.notify_interface.assert_any_call(
		        "RiskyTemperature",
		        fault.level,
		        FaultState.CLEARED,
		        additional_info_kitchen,
		        "mocked_fault_tag",
		    )
		    fault_manager.recovery_interface.assert_any_call(
		        symptom_kitchen, "mocked_fault_tag"
		    )
		
		
		def test_fault_manager_state_transitions(fault_manager, mocked_hass_app, fault):
		    """
		    Test complex state transitions involving multiple symptoms and faults.
		    """
		    # Mock the recovery and notification interfaces
		    fault_manager._generate_fault_tag = Mock(return_value="mocked_fault_tag")
		    fault_manager.notify_interface = Mock()
		    fault_manager.recovery_interface = Mock()
		
		    # Define two symptoms that relate to different faults
		    symptom1 = Symptom(
		        name="RiskyTemperatureOffice",
		        sm_name="sm_tc_1",
		        module=Mock(),
		        parameters={"CAL_LOW_TEMP_THRESHOLD": 18.0},
		    )
		    symptom2 = Symptom(
		        name="OverheatingKitchen",
		        sm_name="sm_tc_2",
		        module=Mock(),
		        parameters={"CAL_HIGH_TEMP_THRESHOLD": 30.0},
		    )
		
		    # Add symptoms to the fault manager
		    fault_manager.symptoms["RiskyTemperatureOffice"] = symptom1
		    fault_manager.symptoms["OverheatingKitchen"] = symptom2
		
		    # Add faults that relate to the symptoms
		    fault1 = Fault("RiskyTemperature", ["sm_tc_1"], level=2)
		    fault2 = Fault("OverheatingFault", ["sm_tc_2"], level=3)
		    fault_manager.faults["RiskyTemperature"] = fault1
		    fault_manager.faults["OverheatingFault"] = fault2
		
		    # Set up the mock for get_state to simulate a previous location being set
		    mocked_hass_app.get_state = Mock(
		        return_value={"attributes": {"Location": "Living Room"}}
		    )
		
		    # Set symptom1 (RiskyTemperatureOffice)
		    additional_info1 = {"Location": "Office"}
		    fault_manager.set_symptom("RiskyTemperatureOffice", additional_info1)
		
		    # Verify fault1 is set
		    assert fault1.state == FaultState.SET
		    fault_manager.notify_interface.assert_any_call(
		        "RiskyTemperature",
		        fault1.level,
		        FaultState.SET,
		        additional_info1,
		        "mocked_fault_tag",
		    )
		
		    # Set symptom2 (OverheatingKitchen)
		    additional_info2 = {"Location": "Kitchen"}
		    fault_manager.set_symptom("OverheatingKitchen", additional_info2)
		
		    # Verify fault2 is set
		    assert fault2.state == FaultState.SET
		    fault_manager.notify_interface.assert_any_call(
		        "OverheatingFault",
		        fault2.level,
		        FaultState.SET,
		        additional_info2,
		        "mocked_fault_tag",
		    )
		
		    # Clear symptom1 (RiskyTemperatureOffice)
		    fault_manager.clear_symptom("RiskyTemperatureOffice", additional_info1)
		
		    # Verify fault1 is cleared
		    assert fault1.state == FaultState.CLEARED
		    fault_manager.notify_interface.assert_any_call(
		        "RiskyTemperature",
		        fault1.level,
		        FaultState.CLEARED,
		        additional_info1,
		        "mocked_fault_tag",
		    )
		
		    # Verify fault2 remains set
		    assert fault2.state == FaultState.SET
		
		    # Clear symptom2 (OverheatingKitchen)
		    fault_manager.clear_symptom("OverheatingKitchen", additional_info2)
		
		    # Verify fault2 is cleared
		    assert fault2.state == FaultState.CLEARED
		    fault_manager.notify_interface.assert_any_call(
		        "OverheatingFault",
		        fault2.level,
		        FaultState.CLEARED,
		        additional_info2,
		        "mocked_fault_tag",
		    )
		    
		def test_fault_manager_init_safety_mechanisms_failure(fault_manager):
		    """
		    Test the FaultManager's init_safety_mechanisms function for a failure scenario where a symptom
		    fails to initialize its safety mechanism, setting its state to ERROR.
		    """
		    # Mock a symptom that will fail to initialize
		    symptom = Symptom(
		        name="FaultyTemperatureSensor",
		        sm_name="sm_tc_faulty",
		        module=Mock(),
		        parameters={"CAL_LOW_TEMP_THRESHOLD": 18.0},
		    )
		
		    # Make the init_safety_mechanism method return False to simulate failure
		    symptom.module.init_safety_mechanism = Mock(return_value=False)
		
		    # Add the symptom to the fault manager
		    fault_manager.symptoms["FaultyTemperatureSensor"] = symptom
		
		    # Initialize safety mechanisms
		    fault_manager.init_safety_mechanisms()
		
		    # Verify that the symptom state is set to ERROR
		    assert fault_manager.symptoms["FaultyTemperatureSensor"].sm_state == SMState.ERROR
		    
		def test_fault_manager_missing_interfaces(fault_manager, mocked_hass_app):
		    """
		    Test the behavior of the FaultManager when notification or recovery interfaces are missing.
		    """
		    # Define a symptom
		    symptom = Symptom(
		        name="RiskyTemperatureOffice",
		        sm_name="sm_tc_1",
		        module=Mock(),
		        parameters={"CAL_LOW_TEMP_THRESHOLD": 18.0},
		    )
		
		    # Set up the mock for get_state to simulate a previous location being set
		    mocked_hass_app.get_state = Mock(
		        return_value={"attributes": {"Location": "Office"}}
		    )
		    
		    # Add the symptom to the fault manager
		    fault_manager.symptoms["RiskyTemperatureOffice"] = symptom
		
		    # Add a fault that the symptom relates to
		    fault = Fault("RiskyTemperature", ["sm_tc_1"], level=2)
		    fault_manager.faults["RiskyTemperature"] = fault
		
		    # Set symptom without recovery and notification interfaces
		    fault_manager.set_symptom("RiskyTemperatureOffice", {"Location": "Office"})
		
		    # Verify that fault is set
		    assert fault.state == FaultState.SET
		    mocked_hass_app.set_state.assert_any_call(
		        "sensor.fault_RiskyTemperature",
		        state="Set",
		        attributes={"Location": "Office"},
		    )
		
		    # Verify that no notification or recovery calls are made
		    assert fault_manager.notify_interface is None
		    assert fault_manager.recovery_interface is None
		
		    # Clear symptom without recovery and notification interfaces
		    fault_manager.clear_symptom("RiskyTemperatureOffice", {"Location": "Office"})
		
		    # Verify that fault is cleared
		    assert fault.state == FaultState.CLEARED
		    mocked_hass_app.set_state.assert_any_call(
		        "sensor.fault_RiskyTemperature",
		        state="Cleared",
		        attributes={"Location": ""},
		    )
		
		    # Verify that no notification or recovery calls are made
		    assert fault_manager.notify_interface is None
		    assert fault_manager.recovery_interface is None
		    
		def test_fault_manager_cleared_state_determinate_info(fault_manager, mocked_hass_app):
		    """
		    Test the _determinate_info function for the CLEARED branch.
		    """
		    # Set up the mock for get_state to simulate current attributes
		    mocked_hass_app.get_state = Mock(
		        return_value={"attributes": {"Location": "Living Room, Office"}}
		    )
		
		    # Define additional information to clear
		    additional_info = {"Location": "Office"}
		
		    # Call the _determinate_info method with FaultState.CLEARED
		    updated_info = fault_manager._determinate_info(
		        "sensor.fault_RiskyTemperature", additional_info, FaultState.CLEARED
		    )
		
		    # Verify the updated information
		    assert updated_info == {"Location": "Living Room"}
		
		    # Test clearing the last remaining location
		    additional_info = {"Location": "Living Room"}
		    updated_info = fault_manager._determinate_info(
		        "sensor.fault_RiskyTemperature", additional_info, FaultState.CLEARED
		    )
		
		    # Verify the updated information is empty
		    assert updated_info == {'Location': 'Office'}
		    
		    
		def test_fault_manager_multiple_faults_associated_with_symptom(fault_manager, mocked_hass_app):
		    """
		    Test the behavior when multiple faults are associated with a single symptom.
		    """
		    # Define a symptom
		    symptom = Symptom(
		        name="RiskyTemperatureOffice",
		        sm_name="sm_tc_1",
		        module=Mock(),
		        parameters={"CAL_LOW_TEMP_THRESHOLD": 18.0},
		    )
		    fault_manager.symptoms["RiskyTemperatureOffice"] = symptom
		
		    # Define multiple faults that are incorrectly associated with the same symptom
		    fault1 = Fault("Fault1", ["sm_tc_1"], level=2)
		    fault2 = Fault("Fault2", ["sm_tc_1"], level=3)
		    fault_manager.faults["Fault1"] = fault1
		    fault_manager.faults["Fault2"] = fault2
		
		    # Call found_mapped_fault and verify it returns None due to multiple faults
		    result = fault_manager.found_mapped_fault("RiskyTemperatureOffice", "sm_tc_1")
		    assert result is None
		    mocked_hass_app.log.assert_any_call(
		        "Error: Multiple faults found associated with symptom_id 'RiskyTemperatureOffice', indicating a configuration error.",
		        level="ERROR",
		    )
		
		
		def test_fault_manager_no_fault_associated_with_symptom(fault_manager, mocked_hass_app):
		    """
		    Test the behavior when no fault is associated with a symptom.
		    """
		    # Define a symptom
		    symptom = Symptom(
		        name="RiskyTemperatureOffice",
		        sm_name="sm_tc_1",
		        module=Mock(),
		        parameters={"CAL_LOW_TEMP_THRESHOLD": 18.0},
		    )
		    fault_manager.symptoms["RiskyTemperatureOffice"] = symptom
		
		    # Call found_mapped_fault and verify it returns None due to no associated faults
		    result = fault_manager.found_mapped_fault("RiskyTemperatureKitchen", "sm_tc_999")
		    assert result is None
		    mocked_hass_app.log.assert_any_call(
		        "Error: No faults associated with symptom_id 'RiskyTemperatureKitchen'. This may indicate a configuration error.",
		        level="ERROR",
		    )
		    
		def test_enable_sm_invalid_state(fault_manager, mocked_hass_app):
		    """
		    Test the behavior when an invalid safety mechanism state is provided.
		    """
		    # Define a symptom
		    symptom = Symptom(
		        name="RiskyTemperatureOffice",
		        sm_name="sm_tc_1",
		        module=Mock(),
		        parameters={"CAL_LOW_TEMP_THRESHOLD": 18.0},
		    )
		    fault_manager.symptoms["RiskyTemperatureOffice"] = symptom
		
		    # Attempt to enable the safety mechanism with an invalid state
		    invalid_state = "INVALID_STATE"  # This is not an instance of SMState
		    fault_manager.enable_sm("RiskyTemperatureOffice", invalid_state)
		
		    # Verify that the error was logged
		    mocked_hass_app.log.assert_any_call(
		        f"Error: Unknown SMState '{invalid_state}' for safety mechanism 'RiskyTemperatureOffice'.",
		        level="ERROR",
		    )
		    
		def test_enable_sm_failure_case(fault_manager, mocked_hass_app):
		    """
		    Test the behavior when enabling a safety mechanism fails.
		    """
		    # Define a symptom
		    symptom = Symptom(
		        name="RiskyTemperatureOffice",
		        sm_name="sm_tc_1",
		        module=Mock(),
		        parameters={"CAL_LOW_TEMP_THRESHOLD": 18.0},
		    )
		    # Simulate enabling failure by returning False
		    symptom.module.enable_safety_mechanism.return_value = False
		    fault_manager.symptoms["RiskyTemperatureOffice"] = symptom
		
		    # Attempt to enable the safety mechanism
		    fault_manager.enable_sm("RiskyTemperatureOffice", SMState.ENABLED)
		
		    # Verify that the symptom state is set to ERROR
		    assert symptom.sm_state == SMState.ERROR
		    
		def test_determinate_info_no_NOT_TESTED(fault_manager):
		    """
		    Test _determinate_info when fault_state doesn't match.
		    """
		    entity_id = "sensor.fault_test"
		    additional_info = {"Location": "Office"}
		    fault_state = FaultState.NOT_TESTED  # FaultState is neither SET nor CLEARED
		    
		    # Set up the mock for `get_state` to return current attributes
		    mocked_hass_app.get_state = Mock(return_value={
		        "attributes": {"Location": "None"}  # Existing attribute is set as 'None'
		    })
		
		    result = fault_manager._determinate_info(entity_id, additional_info, fault_state)
		    
		    # Verify that the result is None, covering the last line of the function
		    assert result is None
		    
		def test_determinate_info_set_none_value(fault_manager, mocked_hass_app):
		    """
		    Test _determinate_info when the current attribute exists as 'None' and needs to be updated to a new value.
		    """
		    entity_id = "sensor.fault_test"
		    additional_info = {"Location": "Office"}
		
		    # Set up the mock for `get_state` to return current attributes
		    mocked_hass_app.get_state = Mock(return_value={
		        "attributes": {"Location": "None"}  # Existing attribute is set as 'None'
		    })
		
		    fault_state = FaultState.SET
		
		    result = fault_manager._determinate_info(entity_id, additional_info, fault_state)
		    
		    # Verify that the attribute "Location" was updated from "None" to "Office"
		    assert result == {"Location": "Office"}
		    
		def test_determinate_info_clear_none_value(fault_manager, mocked_hass_app):
		    """
		    Test _determinate_info when clearing an attribute that exists as 'None'.
		    """
		    entity_id = "sensor.fault_test"
		    additional_info = {"Location": "Office"}
		
		    # Set up the mock for `get_state` to return current attributes
		    mocked_hass_app.get_state = Mock(return_value={
		        "attributes": {"Location": "None, Office"}  # Existing attribute contains 'None' and 'Office'
		    })
		
		    fault_state = FaultState.CLEARED
		
		    result = fault_manager._determinate_info(entity_id, additional_info, fault_state)
		    
		    # Verify that the attribute "Location" is cleared correctly
		    assert result == {"Location": "None"}</file>
	<file path='backend\tests\test_faultmanager.not_ready'>
		from shared.types_common import FaultState
		
		def test_faults_set_symptoms(mocked_hass_app):
		
		    app_instance, _ , __= mocked_hass_app
		
		    app_instance.initialize()
		    # 0. Check before symptom and Fault
		    assert (
		        app_instance.fm.check_symptom("RiskyTemperatureOffice")
		        == FaultState.NOT_TESTED
		    )
		    assert app_instance.fm.check_fault("RiskyTemperature") == FaultState.NOT_TESTED
		
		    # 1. Set symptom and Fault
		    app_instance.fm.set_symptom(
		        "RiskyTemperatureOffice", additional_info={"location": "office"}
		    )
		    assert app_instance.fm.check_symptom("RiskyTemperatureOffice") == FaultState.SET
		    assert app_instance.fm.check_fault("RiskyTemperature") == FaultState.SET
		
		    # 2 Heal symptom and Fault
		    app_instance.fm.clear_symptom(
		        "RiskyTemperatureOffice", additional_info={"location": "office"}
		    )
		    assert (
		        app_instance.fm.check_symptom("RiskyTemperatureOffice") == FaultState.CLEARED
		    )
		    assert app_instance.fm.check_fault("RiskyTemperature") == FaultState.CLEARED
		
		    # 3 Set symptom and Fault
		    app_instance.fm.set_symptom(
		        "RiskyTemperatureOffice", additional_info={"location": "office"}
		    )
		    assert app_instance.fm.check_symptom("RiskyTemperatureOffice") == FaultState.SET
		    assert app_instance.fm.check_fault("RiskyTemperature") == FaultState.SET
		
		    # 4 Set symptom and Fault
		    app_instance.fm.set_symptom(
		        "RiskyTemperatureOffice", additional_info={"location": "office"}
		    )
		    assert app_instance.fm.check_symptom("RiskyTemperatureOffice") == FaultState.SET
		    assert app_instance.fm.check_fault("RiskyTemperature") == FaultState.SET
		    
		def test_faults_set_2_symptom_heal_one(mocked_hass_app):
		    
		    app_instance, _, __= mocked_hass_app
		    app_instance.initialize()
		    
		    # 0. Check before symptom and Fault
		    assert (
		        app_instance.fm.check_symptom("RiskyTemperatureOffice")
		        == FaultState.NOT_TESTED
		    )
		    assert (
		        app_instance.fm.check_symptom("RiskyTemperatureKitchen")
		        == FaultState.NOT_TESTED
		    )
		    assert app_instance.fm.check_fault("RiskyTemperature") == FaultState.NOT_TESTED
		
		    # 1. Set first symptom
		    app_instance.fm.set_symptom(
		        "RiskyTemperatureOffice", additional_info={"location": "office"}
		    )
		    
		    assert app_instance.fm.check_symptom("RiskyTemperatureOffice") == FaultState.SET
		    assert app_instance.fm.check_symptom("RiskyTemperatureKitchen") == FaultState.NOT_TESTED
		    assert app_instance.fm.check_fault("RiskyTemperature") == FaultState.SET
		    
		    # 2. Clear first symptom
		    app_instance.fm.clear_symptom(
		        "RiskyTemperatureOffice", additional_info={"location": "office"}
		    )
		    
		    assert app_instance.fm.check_symptom("RiskyTemperatureOffice") == FaultState.CLEARED
		    assert app_instance.fm.check_symptom("RiskyTemperatureKitchen") == FaultState.NOT_TESTED
		    assert app_instance.fm.check_fault("RiskyTemperature") == FaultState.CLEARED
		    
		    
		    # 3. Set both symptoms
		    app_instance.fm.set_symptom(
		        "RiskyTemperatureOffice", additional_info={"location": "office"}
		    )
		    app_instance.fm.set_symptom(
		        "RiskyTemperatureKitchen", additional_info={"location": "office"}
		    )
		    
		    assert app_instance.fm.check_symptom("RiskyTemperatureOffice") == FaultState.SET
		    assert app_instance.fm.check_symptom("RiskyTemperatureKitchen") == FaultState.SET
		    assert app_instance.fm.check_fault("RiskyTemperature") == FaultState.SET
		
		    # 4. Clear one symptom
		    app_instance.fm.clear_symptom(
		        "RiskyTemperatureOffice", additional_info={"location": "office"}
		    )
		    
		    assert app_instance.fm.check_symptom("RiskyTemperatureOffice") == FaultState.CLEARED
		    assert app_instance.fm.check_symptom("RiskyTemperatureKitchen") == FaultState.SET
		    assert app_instance.fm.check_fault("RiskyTemperature") == FaultState.SET
		    
		    # 5. Clear second symptom
		    app_instance.fm.clear_symptom(
		        "RiskyTemperatureKitchen", additional_info={"location": "office"}
		    )
		    
		    assert app_instance.fm.check_symptom("RiskyTemperatureOffice") == FaultState.CLEARED
		    assert app_instance.fm.check_symptom("RiskyTemperatureKitchen") == FaultState.CLEARED
		    assert app_instance.fm.check_fault("RiskyTemperature") == FaultState.CLEARED
		    
		    
		def test_faults_invalid_cfg_2_smc(mocked_hass_app_2_flts_1_sm):
		
		    app_instance, _, mock_log_method = mocked_hass_app_2_flts_1_sm
		
		    # 1. Set symptom and Fault
		    app_instance.fm.set_symptom(
		        "RiskyTemperatureOffice", additional_info={"location": "office"}
		    )
		    mock_log_method.assert_called_with("Error: Multiple faults found associated with symptom_id 'RiskyTemperatureOffice', indicating a configuration error.", level='ERROR')
		    
		def test_faults_invalid_cfg_no_smc(mocked_hass_app_flt_0_sm):
		
		    app_instance, _, mock_log_method = mocked_hass_app_flt_0_sm
		
		    # 1. Set symptom and Fault
		    app_instance.fm.set_symptom(
		        "RiskyTemperatureOffice", additional_info={"location": "office"}
		    )
		    mock_log_method.assert_called_with("Error: No faults associated with symptom_id 'RiskyTemperatureOffice'. This may indicate a configuration error.", level='ERROR')</file>
	<file path='backend\tests\test_faults_init.not_ready'>
		from unittest.mock import patch, MagicMock
		import pytest
		from shared.temperature_component import TemperatureComponent
		from shared.types_common import FaultState
		
		# Assuming SafetyFunctions is in the correct import path
		from SafetyFunctions import SafetyFunctions
		
		def test_faults_init_RiskyTemperature(mocked_hass_app):
		    """
		    Test the initialization of the 'RiskyTemperature' fault in the SafetyFunctions application.
		
		    Verifies that the 'RiskyTemperature' fault:
		    - Is correctly named 'RiskyTemperature'.
		    - Is initialized with a state of 'NOT_TESTED', indicating it hasn't been triggered yet.
		    - Is related to the correct symptom 'sm_tc_1', which it depends on for activation.
		    - Has a notification level set to '2', denoting its priority or severity.
		
		    This test ensures that fault configurations are correctly set up during the application's
		    initialization process, which is crucial for the fault management system to operate as intended.
		    """
		    app_instance, _, __= mocked_hass_app
		
		    app_instance.initialize()
		    
		    # Verify the fault's name is as expected
		    assert app_instance.faults["RiskyTemperature"].name == "RiskyTemperature", \
		        "'RiskyTemperature' fault does not have the correct name."
		
		    # Verify the fault's initial state is NOT_TESTED
		    assert app_instance.faults["RiskyTemperature"].state == FaultState.NOT_TESTED, \
		        "'RiskyTemperature' fault should initially be in the 'NOT_TESTED' state."
		
		    # Verify the fault is related to the correct symptom
		    assert app_instance.faults["RiskyTemperature"].related_symptoms == ['sm_tc_1'], \
		        "'RiskyTemperature' fault is not correctly related to 'sm_tc_1' symptom."
		
		    # Verify the fault's notification level is set to 2
		    assert app_instance.faults["RiskyTemperature"].level == 2, \
		        "'RiskyTemperature' fault does not have the correct notification level."</file>
	<file path='backend\tests\test_initialization.py'>
		# tests/test_initialization.py
		
		import pytest
		from shared.temperature_component import TemperatureComponent
		from shared.fault_manager import FaultManager
		from .fixtures.hass_fixture import mock_get_state, MockBehavior  # Import utilities from conftest.py
		
		
		@pytest.mark.init
		@pytest.mark.positive
		def test_initialize_dicts_symptom(mocked_hass_app_basic):
		    app_instance, _, __ = mocked_hass_app_basic
		    app_instance.initialize()
		
		    # Assert the 'symptoms' dictionary content
		    symptom = app_instance.symptoms["RiskyTemperatureOffice"]
		    assert symptom.name == "RiskyTemperatureOffice"
		    assert symptom.sm_name == "sm_tc_1"
		    assert symptom.parameters["CAL_LOW_TEMP_THRESHOLD"] == 18.0
		
		    # Assert the 'faults' dictionary content
		    fault = app_instance.fault_dict["RiskyTemperature"]
		    assert fault["name"] == "Unsafe temperature"
		    assert fault["level"] == 2
		    assert fault["related_sms"][0] == "sm_tc_1"
		
		    # Assert the 'notification_cfg' dictionary content
		    notification = app_instance.notification_cfg
		    assert notification["light_entity"] == "light.warning_light"
		
		
		def test_NotificationManager_init(mocked_hass_app_basic):
		    app_instance, _, __ = mocked_hass_app_basic
		    app_instance.initialize()
		
		    assert app_instance.notify_man.hass_app is not None
		    assert app_instance.notify_man.notification_config is app_instance.notification_cfg
		
		
		def test_temperature_component_initialization(mocked_hass_app_with_temp_component):
		    app_instance, _, __, MockTemperatureComponent , mock_behaviors_default = mocked_hass_app_with_temp_component
		    app_instance.initialize()
		
		    assert isinstance(
		        app_instance.sm_modules["TemperatureComponent"], TemperatureComponent
		    )
		
		
		def test_fault_manager_initialization(mocked_hass_app_with_temp_component):
		    app_instance, _, __, MockTemperatureComponent , mock_behaviors_default = mocked_hass_app_with_temp_component
		    app_instance.initialize()
		
		    assert isinstance(app_instance.fm, FaultManager)
		    assert app_instance.fm.notify_interface == app_instance.notify_man.notify
		    assert app_instance.fm.recovery_interface == app_instance.reco_man.recovery
		    assert (
		        app_instance.fm.sm_modules["TemperatureComponent"]
		        == app_instance.sm_modules["TemperatureComponent"]
		    )
		
		
		def test_assign_fm(mocked_hass_app_with_temp_component):
		    app_instance, _, __, ___ , mock_behaviors_default = mocked_hass_app_with_temp_component
		    app_instance.initialize()
		
		    for module in app_instance.sm_modules.values():
		        assert module.fault_man is app_instance.fm
		
		
		def test_app_health_set_to_good_at_end_of_init(mocked_hass_app_with_temp_component):
		    app_instance, _, mock_log_method, ___ , mock_behaviors_default = mocked_hass_app_with_temp_component
		    app_instance.initialize()
		
		    mock_log_method.assert_called_with("Safety app started successfully", level="DEBUG")</file>
	<file path='backend\tests\test_notify_man.py'>
		# tests/test_temperature_component.py
		# mypy: ignore-errors
		
		from typing import Iterator, List
		import pytest
		from shared.types_common import FaultState, SMState
		from unittest.mock import Mock
		from .fixtures.hass_fixture import (
		    mock_get_state,
		    MockBehavior,
		    update_mocked_get_state,
		)  # Import utilities from conftest.py
		
		from shared.notification_manager import NotificationManager
		
		@pytest.mark.parametrize(
		    "test_size,temperature, expected_symptom_state, expected_fault_state, prefault_title, prefault_message",
		    [
		        (
		            5,
		            ["35", "36", "37", "8", "9"],
		            FaultState.CLEARED,
		            FaultState.CLEARED,
		            None,
		            None,
		        ),
		        (
		            5,
		            ["5", "6", "7", "8", "9"],
		            FaultState.SET,
		            FaultState.SET,
		            "Hazard!",
		            'Fault: RiskyTemperature\nlocation: Office\n',
		        ),
		        (
		            6,
		            ["5", "6", "7", "8", "9", "34", "34", "34", "34", "34", "34", "34"],
		            FaultState.CLEARED,
		            FaultState.CLEARED,
		            "Hazard!",
		            'Fault: RiskyTemperature\nlocation: Office\n has been cleared.',
		        ),
		    ],
		)
		def test_temp_comp_notification(
		    mocked_hass_app_with_temp_component,
		    test_size,
		    temperature,
		    expected_symptom_state,
		    expected_fault_state,
		    prefault_title,
		    prefault_message,
		):
		    """
		    Test Case: Verify symptom and fault states based on temperature input.
		
		    Scenario:
		        - Input: Temperature sequences with varying levels.
		        - Expected Result: Symptom and fault states should match expected values based on temperature.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		
		    test_mock_behaviours: List[MockBehavior[str, Iterator[str]]] = [
		        MockBehavior("sensor.office_temperature", iter(temperature))
		    ]
		    mock_behaviors_default: List[MockBehavior] = update_mocked_get_state(
		        mock_behaviors_default, test_mock_behaviours
		    )
		
		    app_instance.get_state.side_effect = lambda entity_id, **kwargs: mock_get_state(
		        entity_id, mock_behaviors_default
		    )
		    app_instance.initialize()
		
		    for _ in range(test_size):
		        app_instance.sm_modules["TemperatureComponent"].sm_tc_1(
		            app_instance.sm_modules["TemperatureComponent"].safety_mechanisms[
		                "RiskyTemperatureOffice"
		            ]
		        )
		
		    assert (
		        app_instance.fm.check_symptom("RiskyTemperatureOffice")
		        == expected_symptom_state
		    )
		    assert app_instance.fm.check_fault("RiskyTemperature") == expected_fault_state
		
		    # Check notification
		    if prefault_title:
		        notify_call = [
		            call
		            for call in app_instance.call_service.call_args_list
		            if "notify" in call.args[0]
		        ]
		        # Check last one
		        assert notify_call[-1].kwargs["title"] == prefault_title
		        assert notify_call[-1].kwargs["message"] == prefault_message
		        
		def test_notify_fault_set(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Notify when fault is set.
		
		    Scenario:
		        - Fault is in FaultState.SET.
		        - Expected Result: The notification is processed and the correct services are called.
		    """
		    notification_config: dict[str, str] = {
		        "light_entity": "light.warning_light",
		        "alarm_entity": "alarm_control_panel.safety_alarm",
		        "dashboard_1_entity": "sensor.dash_emergency",
		    }
		    app_instance, _, __, ___, mock_behaviors_default = (
		    mocked_hass_app_with_temp_component
		    )
		    
		    notification_manager = NotificationManager(app_instance, notification_config)
		    app_instance.call_service = Mock()
		    app_instance.set_state = Mock()
		    app_instance.log = Mock()
		
		    fault_name = "TestFault"
		    fault_level = 1
		    fault_status = FaultState.SET
		    fault_tag = "BAAD"
		    additional_info: dict[str, str] = {"Location": "Office"}
		
		    # Call notify to simulate a fault being set
		    notification_manager.notify(fault_name, fault_level, fault_status, additional_info, fault_tag)
		
		    # Validate that the correct services were called
		    app_instance.call_service.assert_any_call(
		        "alarm_control_panel/alarm_trigger",
		        entity_id=notification_config["alarm_entity"],
		    )
		    app_instance.call_service.assert_any_call(
		        "light/turn_on",
		        entity_id=notification_config["light_entity"],
		        color_name="red",
		    )
		    
		def test_notify_fault_cleared(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Notify when fault is cleared.
		
		    Scenario:
		        - Fault is in FaultState.CLEARED.
		        - Expected Result: A cleared notification message is sent.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    notification_config = {
		        "dashboard_1_entity": "sensor.dash_emergency",
		    }
		
		    notification_manager = NotificationManager(app_instance, notification_config)
		    app_instance.call_service = Mock()
		    app_instance.set_state = Mock()
		    app_instance.log = Mock()
		
		    fault_name = "TestFault"
		    fault_level = 1
		    fault_status = FaultState.CLEARED
		    additional_info = {"Location": "Office"}
		
		    # Call notify to simulate a fault being cleared
		    notification_manager.notify(fault_name, fault_level, fault_status, additional_info, "00")
		
		    
		def test_notify_no_level_defined(mocked_hass_app_with_temp_component):
		    """
		    Test Case: No notification level defined.
		
		    Scenario:
		        - Notification level has no defined handler.
		        - Expected Result: A warning is logged.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    notification_config = {}
		
		    notification_manager = NotificationManager(app_instance, notification_config)
		    app_instance.log = Mock()
		
		    fault_name = "TestFault"
		    fault_level = 4
		    fault_status = FaultState.SET
		
		    # Call notify to simulate a fault with undefined notification level
		    notification_manager.notify(fault_name, fault_level, fault_status, None, "00")
		
		    
		def test_notify_company_app(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Notify company app based on different levels.
		
		    Scenario:
		        - Send notifications for different levels and ensure correct behavior.
		        - Level 4 should not send any notification.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    notification_config = {
		        "dashboard_1_entity": "sensor.dash_emergency",
		    }
		
		    notification_manager = NotificationManager(app_instance, notification_config)
		    app_instance.call_service = Mock()
		    app_instance.log = Mock()
		
		    # Test for different levels
		    fault_name = "TestFault"
		    message = "Test message"
		    fault_state = FaultState.SET
		
		    # Level 4 should not send notifications
		    notification_manager._notify_company_app(4, message, fault_name, fault_state)
		    app_instance.call_service.assert_not_called()
		
		    # Level 1 should send notifications
		    notification_manager._notify_company_app(1, message, fault_name, fault_state)
		    app_instance.call_service.assert_called()
		    
		    
		def test_notify_invalid_fault_status(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Invalid fault status.
		
		    Scenario:
		        - Fault status is neither SET nor CLEARED.
		        - Expected Result: A warning is logged indicating an invalid fault status.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    notification_config = {}
		
		    notification_manager = NotificationManager(app_instance, notification_config)
		    app_instance.log = Mock()
		
		    fault_name = "TestFault"
		    fault_level = 1
		    fault_status = "INVALID_STATUS"  # Use an invalid status that is not in FaultState
		
		    # Call notify with an invalid fault status
		    notification_manager.notify(fault_name, fault_level, fault_status, None, "00")
		
		    # Verify that a warning log was triggered for the invalid fault status
		    app_instance.log.assert_called_with(f"Invalid fault status '{fault_status}'", level="WARNING")
		    
		def test_set_dashboard_notification(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Set dashboard notification.
		
		    Scenario:
		        - Set a notification on the dashboard based on severity level.
		        - Expected Result: The dashboard entity state is updated, or a warning is logged if the entity is not configured.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    notification_config = {
		        "dashboard_1_entity": "sensor.dash_emergency"
		    }
		
		    notification_manager = NotificationManager(app_instance, notification_config)
		    app_instance.set_state = Mock()
		    app_instance.log = Mock()
		
		    message = "Test Dashboard Message"
		    level = 1
		
		    # Call _set_dashboard_notification with a valid level
		    notification_manager._set_dashboard_notification(message, level)
		
		    # Verify that the dashboard entity state was set
		    app_instance.set_state.assert_called_with("sensor.dash_emergency", state=message)
		    app_instance.log.assert_called_with(
		        f"Dashboard entity sensor.dash_emergency was changed to {message}", level="DEBUG"
		    )
		
		    # Call _set_dashboard_notification with an invalid level (not configured)
		    level = 2
		    notification_manager._set_dashboard_notification(message, level)
		
		    # Verify that a warning log was triggered for missing dashboard entity configuration
		    app_instance.log.assert_called_with(
		        f"No dashboard entity configured for level '{level}'", level="WARNING"
		    )
		    
		def test_notify_company_app_no_notification_data(mocked_hass_app_with_temp_component):
		    """
		    Test Case: No notification data available.
		
		    Scenario:
		        - Notification data is not available for the given level.
		        - Expected Result: A warning is logged indicating that no notification configuration exists for the given level.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    notification_config = {}
		
		    notification_manager = NotificationManager(app_instance, notification_config)
		    app_instance.log = Mock()
		
		    level = 999  # Level without a configuration
		    message = "Test message"
		    fault_tag = "TestFaultTag"
		    fault_state = FaultState.SET
		
		    # Call _notify_company_app with no available notification data
		    notification_manager._notify_company_app(level, message, fault_tag, fault_state)
		
		    # Verify that a warning log was triggered for missing notification configuration
		    app_instance.log.assert_called_with(
		        f"No notification configuration for level {level}", level="WARNING"
		    )
		
		def test_clear_symptom_msg(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Clear symptom message.
		
		    Scenario:
		        - Update the notification message to indicate recovery and resend the notification.
		        - Expected Result: The notification message is updated and sent.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    notification_config = {}
		
		    notification_manager = NotificationManager(app_instance, notification_config)
		    app_instance.log = Mock()
		    app_instance.call_service = Mock()
		
		    notification_data = {
		        "title": "Test Notification",
		        "message": "Original message",
		        "data": {}
		    }
		    notification_msg = "Recovery message"
		
		    # Call _clear_symptom_msg to update and resend the notification
		    notification_manager._clear_symptom_msg(notification_data, notification_msg)
		
		    # Verify that the notification message was updated
		    assert notification_data["message"] == f" {notification_msg}"
		
		    # Verify that the notification was resent
		    app_instance.call_service.assert_called_with(
		        "notify/notify",
		        title=notification_data["title"],
		        message=notification_data["message"],
		        data=notification_data["data"]
		    )</file>
	<file path='backend\tests\test_prefaults_init.not_ready'>
		from shared.fault_manager import SMState
		
		
		def test_symptoms_init_RiskyTemperatureOffice(mocked_hass_app):
		    """
		    Test the initialization of the 'RiskyTemperatureOffice' symptom in the SafetyFunctions app.
		
		    Ensures that the symptom:
		    - Is named 'RiskyTemperatureOffice'.
		    - Uses 'sm_tc_1' as its safety mechanism.
		    - Is associated with the 'TemperatureComponent' module.
		    - Has correct parameters for the low temperature threshold and temperature sensor.
		    - Uses the 'RiskyTemperatureRecovery' recovery action from the 'TemperatureComponent'.
		    """
		    app_instance, _, __ = mocked_hass_app
		    app_instance.initialize()
		    
		    assert (
		        app_instance.symptoms["RiskyTemperatureOffice"].name
		        == "RiskyTemperatureOffice"
		    ), "symptom 'RiskyTemperatureOffice' does not have the correct name."
		    assert (
		        app_instance.symptoms["RiskyTemperatureOffice"].sm_name == "sm_tc_1"
		    ), "'RiskyTemperatureOffice' does not use 'sm_tc_1' as its safety mechanism."
		    assert (
		        app_instance.symptoms["RiskyTemperatureOffice"].module
		        == app_instance.sm_modules["TemperatureComponent"]
		    ), "'RiskyTemperatureOffice' is not correctly associated with the 'TemperatureComponent' module."
		    assert app_instance.symptoms["RiskyTemperatureOffice"].parameters == {
		        "CAL_LOW_TEMP_THRESHOLD": 28,
		        "temperature_sensor": "sensor.office_temperature",
		    }, "'RiskyTemperatureOffice' does not have the correct parameters."
		    assert (
		        app_instance.symptoms["RiskyTemperatureOffice"].recover_actions
		        == app_instance.sm_modules["TemperatureComponent"].RiskyTemperatureRecovery
		    ), "'RiskyTemperatureOffice' does not use the correct recovery action."
		
		    assert app_instance.symptoms["RiskyTemperatureOffice"].sm_state == SMState.ENABLED
		
		
		def test_symptoms_init_RiskyTemperatureOfficeForecast(mocked_hass_app):
		    """
		    Test the initialization of the 'RiskyTemperatureOfficeForeCast' symptom in the SafetyFunctions app.
		
		    Ensures that the symptom:
		    - Is named 'RiskyTemperatureOfficeForeCast'.
		    - Uses 'sm_wmc_2' as its safety mechanism.
		    - Is associated with the 'TemperatureComponent' module.
		    - Has correct parameters for the low temperature threshold, forecast timespan, temperature sensor, and temperature sensor rate.
		    - Uses the 'RiskyTemperatureRecovery' recovery action from the 'TemperatureComponent'.
		    """
		    app_instance, _, __ = mocked_hass_app
		    app_instance.initialize()
		    
		    assert (
		        app_instance.symptoms["RiskyTemperatureOfficeForeCast"].name
		        == "RiskyTemperatureOfficeForeCast"
		    ), "symptom 'RiskyTemperatureOfficeForeCast' does not have the correct name."
		    assert (
		        app_instance.symptoms["RiskyTemperatureOfficeForeCast"].sm_name == "sm_tc_2"
		    ), "'RiskyTemperatureOfficeForeCast' does not use 'sm_tc_2' as its safety mechanism."
		    assert (
		        app_instance.symptoms["RiskyTemperatureOfficeForeCast"].module
		        == app_instance.sm_modules["TemperatureComponent"]
		    ), "'RiskyTemperatureOfficeForeCast' is not correctly associated with the 'TemperatureComponent' module."
		    assert app_instance.symptoms["RiskyTemperatureOfficeForeCast"].parameters == {
		        "CAL_LOW_TEMP_THRESHOLD": 28,
		        "CAL_FORECAST_TIMESPAN": 60,
		        "temperature_sensor": "sensor.office_temperature",
		        "temperature_sensor_rate": "sensor.office_temperature_rate",
		    }, "'RiskyTemperatureOfficeForeCast' does not have the correct parameters."
		    assert (
		        app_instance.symptoms["RiskyTemperatureOfficeForeCast"].recover_actions
		        == app_instance.sm_modules["TemperatureComponent"].RiskyTemperatureRecovery
		    ), "'RiskyTemperatureOfficeForeCast' does not use the correct recovery action."
		
		    assert (
		        app_instance.symptoms["RiskyTemperatureOfficeForeCast"].sm_state
		        == SMState.ENABLED
		    )
		
		
		def test_enablesymptoms_during_init(mocked_hass_app):
		    """
		    Test that symptoms are enabled during the initialization of the SafetyFunctions app.
		
		    This test verifies that:
		    - The 'RiskyTemperatureOffice' symptom is transitioned to the ENABLED state as part of the initialization process.
		    - The 'RiskyTemperatureOfficeForeCast' symptom is also transitioned to the ENABLED state during initialization.
		
		    Ensuring symptoms are enabled during initialization is crucial for the application to start monitoring
		    conditions that could lead to faults right away, aligning with the app's proactive safety management strategy.
		    """
		    app_instance, _, __ = mocked_hass_app
		    app_instance.initialize()
		    
		    # Verify 'RiskyTemperatureOffice' symptom is ENABLED after initialization
		    assert (
		        app_instance.fm.symptoms["RiskyTemperatureOffice"].sm_state == SMState.ENABLED
		    ), "'RiskyTemperatureOffice' symptom should be in the ENABLED state after initialization."
		
		    # Verify 'RiskyTemperatureOfficeForeCast' symptom is ENABLED after initialization
		    assert (
		        app_instance.fm.symptoms["RiskyTemperatureOfficeForeCast"].sm_state
		        == SMState.ENABLED
		    ), "'RiskyTemperatureOfficeForeCast' symptom should be in the ENABLED state after initialization."</file>
	<file path='backend\tests\test_recovery_man.py'>
		# tests/test_recovery_man.py
		# mypy: ignore-errors
		
		from shared.types_common import FaultState, RecoveryResult, RecoveryActionState, Fault, Symptom, RecoveryAction
		from unittest.mock import Mock
		
		
		def test_recovery_cleared_state(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Execute recovery process when symptom is in CLEARED state.
		
		    Scenario:
		        - Symptom is in FaultState.CLEARED.
		        - Expected Result: `_handle_cleared_state` should be called.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    symptom = Mock()
		    symptom.state = FaultState.CLEARED
		    fault_tag = "00"
		    app_instance.initialize()
		
		    recovery_manager = app_instance.reco_man
		    recovery_manager._handle_cleared_state = Mock()
		
		    recovery_manager.recovery(symptom,"00")
		
		    recovery_manager._handle_cleared_state.assert_called_once_with(symptom)
		
		
		def test_recovery_action_not_found(mocked_hass_app_with_temp_component):
		    """
		    Test Case: No recovery action found for the given symptom.
		
		    Scenario:
		        - Symptom name does not exist in `recovery_actions`.
		        - Expected Result: Log the absence of a recovery action.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    symptom = Mock()
		    symptom.name = "NonExistentSymptom"
		    symptom.state = FaultState.SET
		
		    app_instance.initialize()
		
		    recovery_manager = app_instance.reco_man
		    recovery_manager.hass_app.log = Mock()
		
		    recovery_manager.recovery(symptom,"00")
		
		    recovery_manager.hass_app.log.assert_called_with(
		        "No recovery actions defined for symptom: NonExistentSymptom", level="DEBUG"
		    )
		
		
		def test_no_recovery_changes_needed(mocked_hass_app_with_temp_component):
		    """
		    Test Case: No changes needed for recovery.
		
		    Scenario:
		        - Recovery action returns `None`.
		        - Expected Result: Log message indicates no changes are needed.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    symptom = Mock()
		    symptom.name = "TestSymptom"
		    symptom.state = FaultState.SET
		
		    app_instance.initialize()
		
		    recovery_manager = app_instance.reco_man
		    recovery_action = Mock()
		    recovery_action.rec_fun.return_value = None
		    recovery_action.params = {}  # Ensure that params attribute is a valid dictionary
		    recovery_manager.recovery_actions = {symptom.name: recovery_action}
		    recovery_manager.hass_app.log = Mock()
		
		    recovery_manager.recovery(symptom,"00")
		
		    recovery_manager.hass_app.log.assert_called_with(
		        f"No changes determined for recovery of symptom: {symptom.name}", level="DEBUG"
		    )
		
		
		def test_recovery_validation_fails(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Recovery action validation fails.
		
		    Scenario:
		        - `_is_dry_test_failed()` or `_isRecoveryConflict()` returns True.
		        - Expected Result: Recovery is aborted.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    symptom = Mock()
		    symptom.name = "TestSymptom"
		    symptom.state = FaultState.SET
		
		    app_instance.initialize()
		
		    recovery_manager = app_instance.reco_man
		    recovery_action = Mock()
		    recovery_result = Mock()
		    recovery_action.rec_fun.return_value = recovery_result
		    recovery_action.params = {}  # Ensure that params attribute is a valid dictionary
		    recovery_manager.recovery_actions = {symptom.name: recovery_action}
		    recovery_manager._is_dry_test_failed = Mock(return_value=True)
		    recovery_manager._isRecoveryConflict = Mock(return_value=False)
		    recovery_manager._execute_recovery = Mock()
		
		    recovery_manager.recovery(symptom,"00")
		
		    recovery_manager._execute_recovery.assert_not_called()
		
		
		def test_successful_recovery_execution(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Successful recovery action execution.
		
		    Scenario:
		        - Recovery validation passes.
		        - Expected Result: Recovery is executed successfully.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    symptom = Mock()
		    symptom.name = "TestSymptom"
		    symptom.state = FaultState.SET
		
		    app_instance.initialize()
		
		    recovery_manager = app_instance.reco_man
		    recovery_action = Mock()
		    recovery_result = Mock()
		    recovery_action.rec_fun.return_value = recovery_result
		    recovery_action.params = {}  # Ensure that params attribute is a valid dictionary
		    recovery_manager.recovery_actions = {symptom.name: recovery_action}
		    recovery_manager._is_dry_test_failed = Mock(return_value=False)
		    recovery_manager._isRecoveryConflict = Mock(return_value=False)
		    recovery_manager._execute_recovery = Mock()
		
		    recovery_manager.recovery(symptom,"00")
		
		    recovery_manager._execute_recovery.assert_called_once_with(symptom, recovery_result)
		
		
		def test_dry_test_failure_aborts_recovery(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Recovery aborted when `_is_dry_test_failed()` returns True.
		
		    Scenario:
		        - `_is_dry_test_failed()` returns True.
		        - Expected Result: Recovery is aborted, `_execute_recovery()` is not called.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    symptom = Mock()
		    symptom.name = "ComplexSymptom"
		    symptom.state = FaultState.SET
		
		    app_instance.initialize()
		
		    recovery_manager = app_instance.reco_man
		    recovery_action = Mock()
		    recovery_result = Mock()
		    recovery_action.rec_fun.return_value = recovery_result
		    recovery_action.params = {}
		    recovery_manager.recovery_actions = {symptom.name: recovery_action}
		
		    # Simulate `_is_dry_test_failed` returning True, indicating a validation failure
		    recovery_manager._is_dry_test_failed = Mock(return_value=True)
		    recovery_manager._isRecoveryConflict = Mock(return_value=False)
		    recovery_manager._execute_recovery = Mock()
		
		    # Execute recovery
		    recovery_manager.recovery(symptom,"00")
		
		    # Assert that recovery execution did not proceed
		    recovery_manager._execute_recovery.assert_not_called()
		    recovery_manager._is_dry_test_failed.assert_called_once_with(
		        symptom.name, recovery_result.changed_sensors
		    )
		    recovery_manager._isRecoveryConflict.assert_not_called()  # Since `_is_dry_test_failed` failed, `_isRecoveryConflict` should not be called
		
		
		def test_recovery_conflict_aborts_recovery(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Recovery aborted when `_isRecoveryConflict()` returns True.
		
		    Scenario:
		        - `_is_dry_test_failed()` returns False.
		        - `_isRecoveryConflict()` returns True.
		        - Expected Result: Recovery is aborted, `_execute_recovery()` is not called.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    symptom = Mock()
		    symptom.name = "ComplexSymptom"
		    symptom.state = FaultState.SET
		
		    app_instance.initialize()
		
		    recovery_manager = app_instance.reco_man
		    recovery_action = Mock()
		    recovery_result = Mock()
		    recovery_action.rec_fun.return_value = recovery_result
		    recovery_action.params = {}
		    recovery_manager.recovery_actions = {symptom.name: recovery_action}
		
		    # Simulate `_is_dry_test_failed` returning False and `_isRecoveryConflict` returning True
		    recovery_manager._is_dry_test_failed = Mock(return_value=False)
		    recovery_manager._isRecoveryConflict = Mock(return_value=True)
		    recovery_manager._execute_recovery = Mock()
		
		    # Execute recovery
		    recovery_manager.recovery(symptom,"00")
		
		    # Assert that recovery execution did not proceed
		    recovery_manager._execute_recovery.assert_not_called()
		    recovery_manager._is_dry_test_failed.assert_called_once_with(
		        symptom.name, recovery_result.changed_sensors
		    )
		    recovery_manager._isRecoveryConflict.assert_called_once_with(symptom)
		
		
		def test_successful_recovery_execution(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Successful recovery execution when all checks pass.
		
		    Scenario:
		        - `_is_dry_test_failed()` returns False.
		        - `_isRecoveryConflict()` returns False.
		        - Expected Result: Recovery is executed, `_execute_recovery()` is called.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    fault_tag = "BEEF"
		    symptom = Mock()
		    symptom.name = "ComplexSymptom"
		    symptom.state = FaultState.SET
		
		    app_instance.initialize()
		
		    recovery_manager = app_instance.reco_man
		    recovery_action = Mock()
		    recovery_result = Mock()
		    recovery_action.rec_fun.return_value = recovery_result
		    recovery_action.params = {}
		    recovery_manager.recovery_actions = {symptom.name: recovery_action}
		
		    # Simulate `_is_dry_test_failed` and `_isRecoveryConflict` both returning False
		    recovery_manager._is_dry_test_failed = Mock(return_value=False)
		    recovery_manager._isRecoveryConflict = Mock(return_value=False)
		    recovery_manager._execute_recovery = Mock()
		
		    # Execute recovery
		    recovery_manager.recovery(symptom,fault_tag)
		
		    # Assert that recovery execution proceeded
		    recovery_manager._execute_recovery.assert_called_once_with(symptom, recovery_result, fault_tag)
		
		
		def test_recovery_execution_multiple_entities(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Recovery execution with multiple entities being updated.
		
		    Scenario:
		        - The recovery action makes changes to multiple sensors and actuators.
		        - Expected Result: All entities should have their states set correctly.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    symptom = Mock()
		    symptom.name = "MultipleEntitiesSymptom"
		    symptom.state = FaultState.SET
		
		    app_instance.initialize()
		
		    recovery_manager = app_instance.reco_man
		    recovery_result = RecoveryResult(
		        changed_sensors={"sensor.test_1": "on", "sensor.test_2": "off"},
		        changed_actuators={"actuator_1": "active", "actuator_2": "inactive"},
		        notifications=[],
		    )
		    recovery_action = Mock()
		    recovery_action.rec_fun.return_value = recovery_result
		    recovery_action.params = {}
		    recovery_manager.recovery_actions = {symptom.name: recovery_action}
		    recovery_manager._is_dry_test_failed = Mock(return_value=False)
		    recovery_manager._isRecoveryConflict = Mock(return_value=False)
		
		    recovery_manager.recovery(symptom,"00")
		
		    # Validate that all entities are updated correctly
		    app_instance.set_state.assert_any_call("actuator_1", state="active")
		    app_instance.set_state.assert_any_call("actuator_2", state="inactive")
		
		
		def test_integration_with_fault_and_notification_managers(
		    mocked_hass_app_with_temp_component,
		):
		    """
		    Test Case: Integration with FaultManager and NotificationManager.
		
		    Scenario:
		        - The recovery action makes changes and issues notifications.
		        - Expected Result: Notifications are properly sent, and recovery actions are registered.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		
		    # Create and initialize the symptom to be registered in FaultManager
		    symptom = Mock()
		    symptom.name = "IntegrationSymptom"
		    symptom.state = FaultState.SET
		    symptom.sm_name = "sm_integration"
		
		    app_instance.initialize()
		
		    # Register the symptom in the FaultManager
		    fault_manager = app_instance.fm
		    fault_manager.symptoms = {symptom.name: symptom}
		
		    # Prepare the RecoveryManager and NotificationManager
		    recovery_manager = app_instance.reco_man
		    recovery_result = RecoveryResult(
		        changed_sensors={},  # No sensor changes
		        changed_actuators={"actuator_1": "active"},
		        notifications=["Manual intervention required for actuator_1."],
		    )
		    recovery_action = Mock()
		    recovery_action.rec_fun.return_value = recovery_result
		    recovery_action.params = {}
		    recovery_manager.recovery_actions = {symptom.name: recovery_action}
		
		    # Prepare FaultManager to return an existing fault for this symptom
		    fault = Fault("IntegrationFault", [symptom.sm_name], 1)
		    fault_manager.faults = {fault.name: fault}
		    fault_manager.found_mapped_fault = Mock(return_value=fault)
		    fault_tag = '00'
		
		    # Mock NotificationManager to validate the notification actions
		    notification_manager = app_instance.notify_man
		    notification_manager._add_recovery_action = Mock()
		
		    # Execute recovery
		    recovery_manager._is_dry_test_failed = Mock(return_value=False)
		    recovery_manager._isRecoveryConflict = Mock(return_value=False)
		    recovery_manager.recovery(symptom,fault_tag)
		
		    # Validate that actuators are updated correctly
		    app_instance.set_state.assert_any_call("actuator_1", state="active")
		
		    # Validate that the notification action was called correctly
		    notification_manager._add_recovery_action.assert_called_once_with(
		        "Manual intervention required for actuator_1.", fault_tag
		    )
		
		
		def test_recovery_action_state_transition(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Validate the transition of `RecoveryActionState`.
		
		    Scenario:
		        - Check that the `RecoveryActionState` transitions from `DO_NOT_PERFORM` to `TO_PERFORM` during execution.
		        - Expected Result: RecoveryActionState is updated correctly.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    symptom = Mock()
		    symptom.name = "StateTransitionSymptom"
		    symptom.state = FaultState.SET
		
		    app_instance.initialize()
		
		    recovery_manager = app_instance.reco_man
		    recovery_result = RecoveryResult(
		        changed_sensors={"sensor.test_1": "on", "sensor.test_2": "off"},
		        changed_actuators={"actuator_1": "active", "actuator_2": "inactive"},
		        notifications=[],
		    )
		    recovery_action = Mock()
		    recovery_action.rec_fun.return_value = recovery_result
		    recovery_action.params = {}
		    recovery_action.current_status = RecoveryActionState.DO_NOT_PERFORM
		    recovery_manager.recovery_actions = {symptom.name: recovery_action}
		    recovery_manager._is_dry_test_failed = Mock(return_value=False)
		    recovery_manager._isRecoveryConflict = Mock(return_value=False)
		
		    # Execute the recovery process
		    recovery_manager.recovery(symptom,"00")
		
		    # Assert that the recovery action state is updated to `TO_PERFORM`
		    assert recovery_action.current_status == RecoveryActionState.TO_PERFORM
		    # Verify that the recovery function (`rec_fun`) was called
		    recovery_action.rec_fun.assert_called_once_with(
		        recovery_manager.hass_app,
		        symptom,
		        recovery_manager.common_entities,
		        **recovery_action.params,
		    )
		    
		def test_check_conflict_with_higher_priority(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Conflict detected with higher priority fault.
		
		    Scenario:
		        - The recovery action has matching actions.
		        - One of the matching faults has a higher priority than the current recovery fault.
		        - Expected Result: The function returns True, indicating a conflict.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = mocked_hass_app_with_temp_component
		
		    # Create a mock for a symptom and fault
		    symptom = Mock()
		    symptom.name = "TestSymptom"
		    symptom.sm_name = "sm_test"
		
		    app_instance.initialize()
		
		    # Mock the RecoveryManager instance and required methods
		    recovery_manager = app_instance.reco_man
		
		    # Mock FaultManager to include a matching fault with higher priority
		    found_symptom = Mock()
		    found_symptom.name = "MatchingSymptom"
		    
		    higher_priority_fault = Mock()
		    higher_priority_fault.level = 5  # Set higher priority
		    
		    # Set the fault manager's symptoms and found_fault method to match
		    recovery_manager.fm.symptoms = {
		        "MatchingSymptom": found_symptom
		    }
		    recovery_manager.fm.found_mapped_fault = Mock(return_value=higher_priority_fault)
		
		    # Define a list of matching actions that includes the "MatchingSymptom"
		    matching_actions = ["MatchingSymptom"]
		    
		    # The current fault's priority is lower than the mocked fault
		    rec_fault_prio = 3
		
		    # Call `_check_conflict_with_matching_actions` and check the result
		    conflict = recovery_manager._check_conflict_with_matching_actions(
		        matching_actions,
		        rec_fault_prio,
		        symptom
		    )
		
		    # Assert that conflict is True due to higher priority fault being present
		    assert conflict is True
		
		def test_recovery_conflict_with_higher_priority(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Recovery process is aborted due to a higher-priority conflict.
		
		    Scenario:
		        - The recovery action has matching actions.
		        - One of the matching faults has a higher priority than the current recovery fault.
		        - Expected Result: The recovery is not performed because of the conflict.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = mocked_hass_app_with_temp_component
		
		    # Create mock symptom
		    symptom = Mock()
		    symptom.name = "TestSymptom"
		    symptom.state = FaultState.SET
		    symptom.sm_name = "sm_test"
		
		    app_instance.initialize()
		
		    recovery_manager = app_instance.reco_man
		
		    # Mock the RecoveryAction
		    recovery_result = RecoveryResult(
		        changed_sensors={"sensor.test_1": "on"},
		        changed_actuators={"actuator_1": "active"},
		        notifications=[],
		    )
		    recovery_action = Mock()
		    recovery_action.rec_fun.return_value = recovery_result
		    recovery_action.params = {}
		    recovery_action.name = "MatchingAction"  # Set name to a non-mock value
		    recovery_manager.recovery_actions = {
		        symptom.name: recovery_action,  # Include the test symptom in recovery actions
		        "MatchingSymptom": recovery_action,  # Also include a mock matching action
		    }
		
		    # Mock FaultManager to include a matching fault with higher priority
		    found_symptom = Mock()
		    found_symptom.name = "MatchingSymptom"
		    found_symptom.sm_name = "sm_test"
		    found_fault = Mock()
		    found_fault.level = 5  # Set higher priority than current recovery fault
		
		    test_fault = Mock()
		    test_fault.level = 3  # Priority of the current recovery fault (lower)
		
		    # Set up FaultManager behavior
		    recovery_manager.fm.symptoms = {
		        "MatchingSymptom": found_symptom,
		        "TestSymptom": symptom,
		    }
		
		    # Define a side_effect function for found_mapped_fault
		    def found_mapped_fault_side_effect(symptom_name, sm_name):
		        if symptom_name == "TestSymptom":
		            return test_fault
		        elif symptom_name == "MatchingSymptom":
		            return found_fault
		        return None
		
		    recovery_manager.fm.found_mapped_fault = Mock(side_effect=found_mapped_fault_side_effect)
		
		    # Mock `_is_dry_test_failed` to return False, allowing the conflict check to proceed
		    recovery_manager._is_dry_test_failed = Mock(return_value=False)
		    recovery_manager._execute_recovery = Mock()
		
		    # Call recovery
		    recovery_manager.recovery(symptom,"00")
		
		    # Assert that `_execute_recovery` was not called due to the conflict
		    recovery_manager._execute_recovery.assert_not_called()
		    recovery_manager.fm.found_mapped_fault.assert_any_call(symptom.name, symptom.sm_name)
		    recovery_manager.fm.found_mapped_fault.assert_any_call("MatchingSymptom", "sm_test")
		
		import pytest
		from unittest.mock import Mock, patch
		from shared.types_common import FaultState, RecoveryActionState, RecoveryResult
		
		def test_perform_recovery_with_exception_handling(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Exception handling during entity state changes in recovery.
		
		    Scenario:
		        - An exception is raised during setting an entity state.
		        - Expected Result: Proper error logging and continuation of recovery process.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = mocked_hass_app_with_temp_component
		    symptom = Mock()
		    symptom.name = "TestSymptomWithException"
		    symptom.sm_name = "TestSM"
		    symptom.state = FaultState.SET
		
		    app_instance.initialize()
		
		    recovery_manager = app_instance.reco_man
		    recovery_result = RecoveryResult(
		        changed_sensors={"sensor.test_1": "on", "sensor.test_2": "off"},
		        changed_actuators={"actuator_1": "active", "actuator_2": "inactive"},
		        notifications=["Test notification"],
		    )
		
		    # Mocking a RecoveryAction
		    recovery_action = Mock()
		    recovery_action.rec_fun.return_value = recovery_result
		    recovery_action.params = {}
		    recovery_action.current_status = RecoveryActionState.DO_NOT_PERFORM
		    recovery_manager.recovery_actions = {symptom.name: recovery_action}
		
		    # Mocking found fault
		    found_fault = Mock()
		    found_fault.name = "TestFault"
		    fault_tag = 'BE'
		    recovery_manager.fm.found_mapped_fault = Mock(return_value=found_fault)
		
		    # Mock `set_state` to throw an exception for one of the entities
		    def mock_set_state(entity, state):
		        if entity == "actuator_1":
		            raise Exception("Simulated set_state error")
		        else:
		            pass
		
		    recovery_manager.hass_app.set_state = Mock(side_effect=mock_set_state)
		    recovery_manager.hass_app.log = Mock()
		    recovery_manager.nm._add_recovery_action  = Mock()
		    
		    # Call `_perform_recovery`
		    recovery_manager._perform_recovery(symptom, recovery_result.notifications, recovery_result.changed_actuators, fault_tag)
		
		    # Validate that the correct error was logged
		    recovery_manager.hass_app.log.assert_any_call(
		        "Exception during setting actuator_1 to active value. Simulated set_state error",
		        level="ERROR",
		    )
		
		    # Assert that `set_state` was called for other entities despite the exception
		    recovery_manager.hass_app.set_state.assert_any_call("actuator_1", state="active")
		    recovery_manager.hass_app.set_state.assert_any_call("actuator_2", state="inactive")
		
		    # Assert that notifications were processed
		    recovery_manager.nm._add_recovery_action.assert_called_once_with("Test notification", fault_tag)
		
		
		def test_perform_recovery_no_recovery_action_found(mocked_hass_app_with_temp_component):
		    """
		    Test Case: No recovery action found for the given symptom.
		
		    Scenario:
		        - `_find_recovery()` returns None.
		        - Expected Result: Proper error logging indicating that no recovery action was found.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = mocked_hass_app_with_temp_component
		    symptom = Mock(spec=Symptom)
		    symptom.name = "NonExistentRecoverySymptom"
		    symptom.sm_name = "TestSM"
		    symptom.state = FaultState.SET
		    fault_tag = 'CE'
		
		    app_instance.initialize()
		
		    recovery_manager = app_instance.reco_man
		
		    # Mock `_find_recovery` to return None to simulate that the recovery action was not found
		    recovery_manager._find_recovery = Mock(return_value=None)
		    recovery_manager.hass_app.log = Mock()
		
		    # Call `_perform_recovery`
		    recovery_manager._perform_recovery(symptom, notifications=[], entities_changes={}, fault_tag=fault_tag)
		
		    # Validate that the correct error was logged
		    recovery_manager.hass_app.log.assert_called_once_with(
		        f"Recovery action for {symptom.name} was not found!", level="ERROR"
		    )
		
		def test_perform_recovery_no_action_in_list(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Symptom without an associated recovery action.
		
		    Scenario:
		        - Symptom is not present in the `recovery_actions` list.
		        - Expected Result: Proper error logging indicating that no recovery action was found.
		    """
		    # Set up the mocked instance and symptom
		    app_instance, _, __, ___, mock_behaviors_default = mocked_hass_app_with_temp_component
		    symptom = Mock(spec=Symptom)
		    symptom.name = "NonExistentRecoverySymptom"
		    symptom.sm_name = "TestSM"
		    symptom.state = FaultState.SET
		
		    app_instance.initialize()
		
		    # Set up the RecoveryManager instance
		    recovery_manager = app_instance.reco_man
		    fault_tag = '00'
		
		    # Prepare recovery_actions list with entries for other symptoms, but not the one we're testing
		    recovery_action_1 = Mock(spec=RecoveryAction)
		    recovery_action_1.name = "ExistingRecoveryAction"
		    recovery_manager.recovery_actions = {
		        "OtherSymptom": recovery_action_1  # No entry for "NonExistentRecoverySymptom"
		    }
		
		    # Mock logging for assertions
		    recovery_manager.hass_app.log = Mock()
		
		    # Call `_perform_recovery`
		    recovery_manager._perform_recovery(symptom, notifications=[], entities_changes={},fault_tag=fault_tag)
		
		    # Validate that the correct error was logged
		    recovery_manager.hass_app.log.assert_called_once_with(
		        f"Recovery action for {symptom.name} was not found!", level="ERROR"
		    )
		    
		def test_perform_recovery_no_matching_action(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Indirectly test `_find_recovery()` returning `None`.
		
		    Scenario:
		        - Symptom is not present in the `recovery_actions` dictionary.
		        - Expected Result: Proper logging indicating that no recovery action was found.
		    """
		    # Set up the mocked app instance and initialize it
		    app_instance, _, __, ___, mock_behaviors_default = mocked_hass_app_with_temp_component
		    app_instance.initialize()
		
		    # Set up the recovery manager with no recovery actions
		    recovery_manager = app_instance.reco_man
		    recovery_manager.recovery_actions = {}  # No recovery actions available
		
		    # Create a mock Symptom object that is not in recovery_actions
		    symptom = Mock(spec=Symptom)
		    symptom.name = "NonExistingSymptom"
		    symptom.sm_name = "TestSM"
		    symptom.state = FaultState.SET
		    fault_tag = '78'
		
		    # Mock `hass_app` logging to verify log calls
		    recovery_manager.hass_app.log = Mock()
		
		    # Call `_perform_recovery` with the mock Symptom
		    recovery_manager._perform_recovery(symptom, notifications=[], entities_changes={},fault_tag=fault_tag)
		
		    # Validate that the correct log message is printed
		    recovery_manager.hass_app.log.assert_called_once_with(
		        f"Recovery action for {symptom.name} was not found!", level="ERROR"
		    )
		    
		def test_no_recovery_conflict(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Indirectly test `_isRecoveryConflict()` returning `False`.
		
		    Scenario:
		        - `_get_matching_actions()` returns an empty list, meaning no conflicting actions are found.
		        - Expected Result: `_isRecoveryConflict()` should return `False`, indicating no conflict exists.
		    """
		    # Set up the mocked app instance and initialize it
		    app_instance, _, __, ___, mock_behaviors_default = mocked_hass_app_with_temp_component
		    app_instance.initialize()
		
		    # Set up the recovery manager
		    recovery_manager = app_instance.reco_man
		
		    # Mock the symptom that we will pass to `_isRecoveryConflict`
		    symptom = Mock(spec=Symptom)
		    symptom.name = "NoConflictSymptom"
		    symptom.sm_name = "TestSM"
		    symptom.state = FaultState.SET
		
		    # Mock `hass_app` logging to verify log calls
		    recovery_manager.hass_app.log = Mock()
		
		    # Mock `_get_matching_actions` to return an empty list (indicating no matching actions)
		    recovery_manager._get_matching_actions = Mock(return_value=[])
		
		    # Mock `found_mapped_fault` to return `None`, to bypass other checks
		    recovery_manager.fm.found_mapped_fault = Mock(return_value=None)
		
		    # Call `recovery()` with the symptom to indirectly trigger `_isRecoveryConflict()`
		    recovery_manager._isRecoveryConflict(symptom)
		
		    # Since `_get_matching_actions` returns an empty list, `_isRecoveryConflict` should return False
		    recovery_manager._get_matching_actions.assert_called_once_with(symptom)
		    
		def test_recovery_performed_callback(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Validate the behavior of `_recovery_performed()` callback.
		
		    Scenario:
		        - `_recovery_performed()` is invoked, simulating an entity state change.
		        - Expected Result: `_recovery_clear()` is called with the correct symptom.
		    """
		    # Set up the mocked app instance and initialize it
		    app_instance, _, __, ___, mock_behaviors_default = mocked_hass_app_with_temp_component
		    app_instance.initialize()
		
		    # Set up the recovery manager
		    recovery_manager = app_instance.reco_man
		
		    # Mock the `_recovery_clear` method to track if it is called
		    recovery_manager._recovery_clear = Mock()
		
		    # Define the symptom that will be passed in `cb_args`
		    symptom = Mock()
		    symptom.name = "TestSymptom"
		
		    # Call `_recovery_performed` directly with the mock callback arguments
		    cb_args = {"symptom": symptom}
		
		    # Invoke the callback function directly
		    recovery_manager._recovery_performed(None, None, None, None, cb_args)
		
		    # Assert that `_recovery_clear` was called with the expected symptom
		    recovery_manager._recovery_clear.assert_called_once_with(symptom)</file>
	<file path='backend\tests\test_safetyFunctions.py'>
		from typing import Iterator, List
		import pytest
		from shared.types_common import FaultState, SMState
		from shared.temperature_component import TemperatureComponent
		import SafetyFunctions
		from unittest.mock import Mock, patch
		from .fixtures.hass_fixture import (
		    mock_get_state,
		    MockBehavior,
		    update_mocked_get_state,
		)  # Import utilities from conftest.py
		from unittest.mock import ANY
		
		def test_safety_functions_initialization(mocked_hass_app_with_temp_component) -> None:
		
		    app_instance, mocked_hass, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    app_instance.initialize()
		
		    # Assert the 'symptoms' dictionary content
		    symptom = app_instance.symptoms["RiskyTemperatureOffice"]
		    assert symptom.name == "RiskyTemperatureOffice"
		    assert symptom.sm_name == "sm_tc_1"
		    assert symptom.parameters["CAL_LOW_TEMP_THRESHOLD"] == 18.0
		
		    # Assert the 'faults' dictionary content
		    fault = app_instance.fault_dict["RiskyTemperature"]
		    assert fault["name"] == "Unsafe temperature"
		    assert fault["level"] == 2
		    assert fault["related_sms"][0] == "sm_tc_1"
		
		    # Assert the 'notification_cfg' dictionary content
		    notification = app_instance.notification_cfg
		    assert notification["light_entity"] == "light.warning_light"
		
		    # Ensure that the correct common entity was used
		    assert app_instance.common_entities_cfg["outside_temp"] == "sensor.dom_temperature"
		
		    # Verify that safety mechanisms are initialized and enabled
		    mocked_hass.set_state.assert_any_call("sensor.safety_app_health", state="init")
		    mocked_hass.set_state.assert_any_call("sensor.safety_app_health", state="running",attributes = ANY)
		
		    # Verify TemperatureComponent configurations are set up correctly
		    assert "TemperatureComponent" in app_instance.sm_modules
		
		    # Verify that TemperatureComponent received the correct configuration
		    temp_comp_cfg = app_instance.safety_components_cfg["TemperatureComponent"][0]
		    assert "Office" in temp_comp_cfg
		    assert temp_comp_cfg["Office"]["temperature_sensor"] == "sensor.office_temperature"
		    assert (
		        temp_comp_cfg["Office"]["window_sensor"]
		        == "sensor.office_window_contact_contact"
		    )
		
		    assert "Kitchen" in temp_comp_cfg
		    assert (
		        temp_comp_cfg["Kitchen"]["temperature_sensor"] == "sensor.kitchen_temperature"
		    )
		    assert (
		        temp_comp_cfg["Kitchen"]["window_sensor"]
		        == "sensor.kitchen_window_contact_contact"
		    )
		
		    # Verify the NotificationManager is initialized with the correct entity
		    assert (
		        app_instance.notify_man.notification_config["light_entity"]
		        == "light.warning_light"
		    )
		
		    # Verify that common entities are properly initialized in CommonEntities
		    assert "outside_temp" in app_instance.common_entities_cfg
		    assert app_instance.common_entities_cfg["outside_temp"] == "sensor.dom_temperature"
		
		
		def test_fault_and_symptom_registration(mocked_hass_app_with_temp_component):
		    """Ensure all configured faults and symptoms are correctly registered in FaultManager."""
		    app_instance, _, __, ___, _ = mocked_hass_app_with_temp_component
		    app_instance.initialize()
		
		    # Assert that all symptoms are registered
		    for symptom_name in app_instance.symptoms:
		        symptom = app_instance.symptoms[symptom_name]
		        assert app_instance.fm.check_symptom(symptom_name) == FaultState.NOT_TESTED
		
		    # Assert that all faults are registered
		    for fault_name in app_instance.faults:
		        fault = app_instance.faults[fault_name]
		        assert fault.name is not None
		        assert fault.level >= 0
		
		
		def test_trigger_symptom_sets_fault(mocked_hass_app_with_temp_component):
		    """Test triggering a symptom results in fault state being set."""
		    app_instance, _, __, ___, _ = mocked_hass_app_with_temp_component
		    app_instance.initialize()
		
		    # Manually trigger a symptom
		    app_instance.fm.set_symptom("RiskyTemperatureOffice", None)
		
		    # Check if the corresponding fault is set to 'SET'
		    assert app_instance.fm.check_fault("RiskyTemperature") == FaultState.SET
		
		
		def test_recovery_process_execution(mocked_hass_app_with_temp_component):
		    """Test that recovery actions are executed when faults are triggered."""
		    app_instance, _, __, ___, _ = mocked_hass_app_with_temp_component
		    app_instance.initialize()
		
		    # Mock the recovery action to track if it's called
		    app_instance.reco_man.recovery = Mock()
		    # Bind new Mock with recovery_interface
		    app_instance.fm.recovery_interface = app_instance.reco_man.recovery
		
		    # Manually trigger a symptom
		    app_instance.fm.set_symptom("RiskyTemperatureOffice", None)
		
		    # Extract the call arguments
		    recovery_call_args = app_instance.reco_man.recovery.call_args
		
		    # Verify only the first argument of the call, which should be the symptom object
		    assert recovery_call_args[0][0] == app_instance.symptoms["RiskyTemperatureOffice"]
		
		
		def test_app_initialization_health_state(mocked_hass_app_with_temp_component):
		    """Test health state transitions during app initialization."""
		    app_instance, mocked_hass, __, ___, _ = mocked_hass_app_with_temp_component
		
		    app_instance.initialize()
		
		    # Verify that health state transitions from 'init' to 'good'
		    mocked_hass.set_state.assert_any_call("sensor.safety_app_health", state="init")
		    mocked_hass.set_state.assert_any_call("sensor.safety_app_health", state="running",attributes = ANY)
		
		def test_common_entities_lookup(mocked_hass_app_with_temp_component):
		    """Test that common entities are properly initialized and accessible."""
		    app_instance, _, __, ___, _ = mocked_hass_app_with_temp_component
		    app_instance.initialize()
		
		    # Access the common entity and ensure it matches the configured value
		    assert app_instance.common_entities_cfg["outside_temp"] == "sensor.dom_temperature"
		
		
		def test_initialize_no_faults_or_safety_components(mocked_hass_app_with_temp_component):
		    """
		    Test Case: No faults or safety components defined in configuration.
		
		    Scenario:
		        - The configuration does not include any faults or safety components.
		        - Expected Result: The app stops, logging an appropriate warning, setting the app state to 'invalid_cfg', and calling terminate.
		    """
		    app_instance, mocked_hass, _, _, _ = mocked_hass_app_with_temp_component
		
		    # Modify the configuration to remove 'faults' and 'safety_components'
		    app_instance.args['app_config']['faults'] = {}  # No faults defined
		    app_instance.args['user_config']['safety_components'] = {}  # No safety components defined
		
		    mocked_hass.stop_app = Mock()
		    # Call initialize to test behavior
		    app_instance.initialize()
		
		    # Check if the warning log was called
		    app_instance.log.assert_called_with("No faults or safety components defined. Stopping the app.", level="WARNING")
		
		    # Check if the app state was set to 'invalid_cfg'
		    mocked_hass.set_state.assert_called_with("sensor.safety_app_health", state="invalid_cfg")</file>
	<file path='backend\tests\test_temperatureComponent.py'>
		# tests/test_temperature_component.py
		# mypy: ignore-errors
		
		from typing import Iterator, List
		import pytest
		from shared.types_common import FaultState, SMState
		from unittest.mock import Mock
		from .fixtures.hass_fixture import (
		    mock_get_state,
		    MockBehavior,
		    update_mocked_get_state,
		)  # Import utilities from conftest.py
		
		
		DEBOUNCE_LIMIT = 1
		
		
		@pytest.mark.parametrize(
		    "temperature, expected_symptom_state, expected_fault_state",
		    [
		        (
		            ["35", "36", "37", "8", "9"],
		            FaultState.CLEARED,
		            FaultState.CLEARED,
		        ),
		        (
		            ["5", "6", "7", "8", "9"],
		            FaultState.SET,
		            FaultState.SET,
		        ),
		    ],
		)
		def test_temp_comp_smtc1(
		    mocked_hass_app_with_temp_component,
		    temperature,
		    expected_symptom_state,
		    expected_fault_state,
		):
		    """
		    Test Case: Verify symptom and fault states based on temperature input.
		
		    Scenario:
		        - Input: Temperature sequences with varying levels.
		        - Expected Result: Symptom and fault states should match expected values based on temperature.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		
		    test_mock_behaviours: List[MockBehavior[str, Iterator[str]]] = [
		        MockBehavior("sensor.office_temperature", iter(temperature))
		    ]
		    mock_behaviors_default: List[MockBehavior] = update_mocked_get_state(
		        mock_behaviors_default, test_mock_behaviours
		    )
		
		    app_instance.get_state.side_effect = lambda entity_id, **kwargs: mock_get_state(
		        entity_id, mock_behaviors_default
		    )
		    app_instance.initialize()
		
		    for _ in range(5):
		        app_instance.sm_modules["TemperatureComponent"].sm_tc_1(
		            app_instance.sm_modules["TemperatureComponent"].safety_mechanisms[
		                "RiskyTemperatureOffice"
		            ]
		        )
		
		    assert (
		        app_instance.fm.check_symptom("RiskyTemperatureOffice")
		        == expected_symptom_state
		    )
		    assert app_instance.fm.check_fault("RiskyTemperature") == expected_fault_state
		
		
		def test_symptom_set_when_temp_NOT_below_threshold(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Symptom Set When Temperature is Below Threshold
		
		    Scenario:
		        - Input: Temperature sequence ["16.0", "24", "23"]
		        - Expected Result: Symptom "RiskyTemperatureOffice" should be set to True.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    temperature_sequence: List[str] = ["16.0", "24", "23"]
		
		    test_mock_behaviours: list[MockBehavior] = [
		        MockBehavior("sensor.office_temperature", iter(temperature_sequence))
		    ]
		
		    mock_behaviors_default: List[MockBehavior] = update_mocked_get_state(
		        mock_behaviors_default, test_mock_behaviours
		    )
		
		    app_instance.get_state.side_effect = lambda entity_id, **kwargs: mock_get_state(
		        entity_id, mock_behaviors_default
		    )
		
		    app_instance.initialize()
		
		    assert (
		        app_instance.fm.check_symptom("RiskyTemperatureOffice") is FaultState.NOT_TESTED
		    )
		
		
		@pytest.mark.parametrize(
		    "debounce_value, expected_symptom_state",
		    [
		        (DEBOUNCE_LIMIT, FaultState.CLEARED),  # Case where debounce limit is met
		        (
		            DEBOUNCE_LIMIT - 1,
		            FaultState.NOT_TESTED,
		        ),  # Case where debounce limit is not met
		    ],
		)
		def test_symptom_cleared_when_temp_above_threshold(
		    mocked_hass_app_with_temp_component, debounce_value, expected_symptom_state
		):
		    """
		    Test Case: Symptom Cleared When Temperature is Above Threshold
		
		    Scenario:
		        - Input: Temperature sequence ["20.0", "21.0", "22.0"]
		        - Expected Result: Symptom "RiskyTemperatureOffice" should be cleared.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    temperature_sequence = ["20.0", "21.0", "22.0", "22.0"]
		
		    test_mock_behaviours = [
		        MockBehavior("sensor.office_temperature", iter(temperature_sequence))
		    ]
		    mock_behaviors_default: List[MockBehavior] = update_mocked_get_state(
		        mock_behaviors_default, test_mock_behaviours
		    )
		
		    app_instance.get_state.side_effect = lambda entity_id, **kwargs: mock_get_state(
		        entity_id,
		        mock_behaviors_default,
		    )
		
		    app_instance.initialize()
		
		    for _ in range(debounce_value):
		        app_instance.sm_modules["TemperatureComponent"].sm_tc_1(
		            app_instance.sm_modules["TemperatureComponent"].safety_mechanisms[
		                "RiskyTemperatureOffice"
		            ]
		        )
		
		    assert (
		        app_instance.fm.check_symptom("RiskyTemperatureOffice")
		        is expected_symptom_state
		    )
		
		
		def test_symptom_cleared_when_temp_above_threshold_less_than_debounce(
		    mocked_hass_app_with_temp_component,
		):
		    """
		    Test Case: Symptom Cleared When Temperature is Above Threshold
		
		    Scenario:
		        - Input: Temperature sequence ["20.0", "21.0", "22.0"]
		        - Expected Result: Symptom "RiskyTemperatureOffice" should be cleared.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    temperature_sequence = ["20.0", "21.0", "22.0", "22.0"]
		
		    test_mock_behaviours: List[MockBehavior[str, Iterator[str]]] = [
		        MockBehavior("sensor.office_temperature", iter(temperature_sequence))
		    ]
		    mock_behaviors_default: List[MockBehavior] = update_mocked_get_state(
		        mock_behaviors_default, test_mock_behaviours
		    )
		
		    app_instance.get_state.side_effect = lambda entity_id, **kwargs: mock_get_state(
		        entity_id,
		        mock_behaviors_default,
		    )
		
		    app_instance.initialize()
		
		    for _ in range(DEBOUNCE_LIMIT - 1):
		        app_instance.sm_modules["TemperatureComponent"].sm_tc_1(
		            app_instance.sm_modules["TemperatureComponent"].safety_mechanisms[
		                "RiskyTemperatureOffice"
		            ]
		        )
		
		    assert (
		        app_instance.fm.check_symptom("RiskyTemperatureOffice") is FaultState.NOT_TESTED
		    )
		
		
		def test_forecasted_symptom_set_when_temp_rate_indicates_drop(
		    mocked_hass_app_with_temp_component,
		):
		    """
		    Test Case: Forecasted Symptom Set When Temperature Rate Indicates a Drop
		
		    Scenario:
		        - Input: Initial temperature is 20.0°C, rate is -0.1°C/min, and forecast timespan is 2 hours.
		        - Expected Result: Symptom "RiskyTemperatureOfficeForeCast" should be set to True.
		    """
		    app_instance, __, _, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    temperature_sequence = ["20.0"]
		    rate_of_change = "-1"  # degrees per 15 minute
		
		    # Initialize the application and register the monitored entity in DerivativeMonitor
		    app_instance.initialize()
		    app_instance.derivative_monitor.register_entity(
		        "sensor.office_temperature",
		        sample_time=60*15,  # Sampling every 1 minute
		        low_saturation=-10.0,
		        high_saturation=10.0,
		    )
		
		    # Mock the states for temperature and rate
		    app_instance.get_state.side_effect = lambda entity_id, **kwargs: mock_get_state(
		        entity_id,
		        [
		            MockBehavior("sensor.office_temperature", iter(temperature_sequence)),
		            MockBehavior("sensor.office_temperature_rate", iter([rate_of_change])),
		        ],
		    )
		
		    # Simulate multiple iterations to reach the debounce limit
		    for _ in range(DEBOUNCE_LIMIT):
		        app_instance.sm_modules["TemperatureComponent"].sm_tc_2(
		            app_instance.sm_modules["TemperatureComponent"].safety_mechanisms[
		                "RiskyTemperatureOfficeForeCast"
		            ]
		        )
		
		    # Assert the symptom state
		    assert (
		        app_instance.fm.check_symptom("RiskyTemperatureOfficeForeCast")
		        is FaultState.SET
		    )
		
		
		
		@pytest.mark.parametrize(
		    "debounce_value, expected_symptom_state",
		    [
		        (DEBOUNCE_LIMIT, FaultState.CLEARED),  # Case where debounce limit is met
		        (
		            DEBOUNCE_LIMIT - 1,
		            FaultState.NOT_TESTED,
		        ),  # Case where debounce limit is not met
		    ],
		)
		def test_forecasted_symptom_cleared_when_temp_rate_indicates_stability(
		    mocked_hass_app_with_temp_component, debounce_value, expected_symptom_state
		):
		    """
		    Test Case: Forecasted Symptom Cleared When Temperature Rate Indicates Stability
		
		    Scenario:
		        - Input: Initial temperature is 20.0°C, rate is 0.1°C/min, and forecast timespan is 2 hours.
		        - Parametrized with debounce_value and expected_symptom_state.
		        - Expected Result: Symptom "RiskyTemperatureOfficeForeCast" should be cleared when debounce limit is met.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    temperature_sequence = ["20.0"]
		    rate_of_change = "0.5"  # degrees per minute
		
		    app_instance.get_state.side_effect = lambda entity_id, **kwargs: mock_get_state(
		        entity_id,
		        [
		            MockBehavior("sensor.office_temperature", iter(temperature_sequence)),
		            MockBehavior("sensor.office_temperature_rate", iter([rate_of_change])),
		        ],
		    )
		
		    app_instance.initialize()
		
		    for _ in range(debounce_value):
		        app_instance.sm_modules["TemperatureComponent"].sm_tc_2(
		            app_instance.sm_modules["TemperatureComponent"].safety_mechanisms[
		                "RiskyTemperatureOfficeForeCast"
		            ]
		        )
		
		    assert (
		        app_instance.fm.check_symptom("RiskyTemperatureOfficeForeCast")
		        == expected_symptom_state
		    )
		
		
		def test_safety_mechanism_disabled_does_not_trigger_symptom(
		    mocked_hass_app_with_temp_component,
		):
		    """
		    Test Case: Safety Mechanism Disabled Does Not Trigger Symptom
		
		    Scenario:
		        - Input: Temperature is 15.0°C, and the mechanism is disabled.
		        - Expected Result: Symptom state should remain unchanged.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    temperature_sequence = ["15.0"]
		
		    test_mock_behaviours: List[MockBehavior[str, Iterator[str]]] = [
		        MockBehavior("sensor.office_temperature", iter(temperature_sequence))
		    ]
		    mock_behaviors_default: List[MockBehavior] = update_mocked_get_state(
		        mock_behaviors_default, test_mock_behaviours
		    )
		
		    app_instance.get_state.side_effect = lambda entity_id, **kwargs: mock_get_state(
		        entity_id,
		        mock_behaviors_default,
		    )
		
		    app_instance.initialize()
		
		    # Disable the safety mechanism
		    app_instance.fm.enable_sm("RiskyTemperatureOffice", SMState.DISABLED)
		
		    for _ in range(DEBOUNCE_LIMIT):
		        app_instance.sm_modules["TemperatureComponent"].sm_tc_1(
		            app_instance.sm_modules["TemperatureComponent"].safety_mechanisms[
		                "RiskyTemperatureOffice"
		            ]
		        )
		
		    # Check that no symptom was set since the mechanism was disabled
		    assert (
		        app_instance.fm.check_symptom("RiskyTemperatureOffice") is FaultState.NOT_TESTED
		    )
		
		
		def test_initialize_dicts_symptom(mocked_hass_app_with_temp_component):
		    """
		    Test Case: Initialization of Symptom Dictionaries
		
		    Scenario:
		        - Input: Initialization of the app instance.
		        - Expected Result: Validate that the symptom, fault, and notification configurations are correctly populated.
		    """
		    app_instance, _, __, ___, mock_behaviors_default = (
		        mocked_hass_app_with_temp_component
		    )
		    app_instance.initialize()
		
		    # Validate initialization
		    symptom = app_instance.symptoms["RiskyTemperatureOffice"]
		    assert symptom.name == "RiskyTemperatureOffice"
		    assert symptom.sm_name == "sm_tc_1"
		    assert symptom.parameters["CAL_LOW_TEMP_THRESHOLD"] == 18.0
		
		    fault = app_instance.fault_dict["RiskyTemperature"]
		    assert fault["name"] == "Unsafe temperature"
		    assert fault["level"] == 2
		    assert fault["related_sms"][0] == "sm_tc_1"
		
		    notification = app_instance.notification_cfg
		    assert notification["light_entity"] == "light.warning_light"</file>
	<file path='docs\SafetyConcept\SafetyConcept - HARA.md'>
		# ISO 26262 Inspired Safety Strategy for Home Automation Systems
		
		
		
		
		## 1. Hazard analysis and risk assessment
		
		### 1.1 Hazard identification:
		
		This process identifies and analyzes potential hazards to the home automation system and its occupants.
		By assessing the system, components, and external factors, all hazards are identified for a comprehensive understanding of risks.
		This involves examining security vulnerabilities, safety concerns, environmental factors, and system malfunctions.
		Identified hazards inform risk assessment and guide the development of safety measures.
		
		---
		
		#### 1.1.1 Identyfied hazards:
		
		---
		
		**Unauthorized Access:**
		
		This could occur if a door or window is left open or unlocked, or if a security system is disabled.
		
		**Fire:**
		
		This could be caused by a malfunctioning device, such as a heater, stove, or electrical equipment.
		
		**Gas Leak:**
		
		Gas appliances could leak, leading to potential poisoning or explosion.
		
		**Carbon Monoxide Poisoning:**
		
		This is another risk associated with gas appliances, particularly if they are not properly
		ventilated.
		
		**Water Leak/Flood:**
		
		This could occur if a pipe bursts or a faucet is left running.
		
		**Electrical Shock:**
		
		This could be caused by a faulty device, or by water coming into contact with electrical equipment.
		
		**Poor Air Quality:**
		
		This could be caused by a lack of ventilation, leading to a buildup of pollutants or allergens.
		
		**Loss of Heating/Cooling:**
		
		This could occur if the HVAC system fails, leading to uncomfortable or even dangerous indoor temperatures.
		
		**Failure of Safety or Monitoring Devices:**
		
		Devices like smoke detectors, CO detectors, or security cameras could fail to operate correctly.
		
		**Privacy Invasion:**
		
		Unauthorized access to the system could lead to privacy concerns, such as surveillance through security cameras.
		
		**System Failure:**
		
		A failure in the home automation system itself could lead to various problems, such as lights not working, doors not unlocking, etc.
		
		**Unsafe Cold Exposure:**
		
		This can occur if a room's temperature falls below the safe threshold for the situation or occupants. For example, the bathroom temperature might need to be at least 22°C during a child's bath.
		
		**Unsafe Heat Exposure:**
		
		Similarly, a room's temperature could rise above the safe threshold for the situation or occupants. For example, the living room might become uncomfortably or unsafely hot during a summer heatwave if the cooling system isn't functioning properly.
		
		**Rain Entering Through Open Window:**
		
		This hazard arises when rain enters through an open window, potentially causing water damage to the home's interior and electrical systems. A smart home system can help prevent this by monitoring the weather and alerting residents or automatically closing windows when rain is detected.
		
		---
		
		### 1.2 Hazards assessment and risk classification:
		
		This process evaluates identified hazards based on severity, exposure, and controllability.
		By quantifying these factors and calculating risk scores, hazards are prioritized.
		The assigned priorities guide the development of safety measures and risk mitigation strategies.
		
		Based on the hazard assessment, each identified hazard is assigned a risk level. This risk level is typically determined by factors such as the potential severity of the hazard, the likelihood of the hazard occurring, and the ability of the user or system to control the hazard.
		
		---
		
		#### 1.2.1 Definitions
		
		**Severity** refers to the potential harm that could be caused by the hazard. High severity hazards could cause serious harm, such as injury or significant property damage, while medium severity hazards might cause discomfort or minor damage.
		
		**Exposure** refers to the likelihood of the hazard occurring. High exposure hazards could occur regularly, while medium exposure hazards might only occur occasionally.
		
		**Controllability** refers to the user's ability to prevent or mitigate the hazard. High controllability hazards can be easily managed by the user, while medium controllability hazards might require more effort or specialized knowledge to manage.
		
		---
		
		#### 1.2.2 Numerical values:
		
		High=3, Medium=2, and Low=1 for _Severity_, _Exposure_  
		High=1, Medium=2, and Low=3 for _Controllability_
		
		---
		
		
		#### 1.2.3 Formula Risk:
		
		Risk_score = (2 x _Severity_) x _Exposure_ x _Controllability_ to calculate risk.
		
		---
		
		#### 1.2.4 Categories:
		
		**Level 1:** High Risk (Risk score 24 and above)  
		**Level 2:** Medium Risk (Risk score between 12 and 23)  
		**Level 3:** Low Risk (Risk score between 6 and 11)  
		**Level 4:** Very Low Risk (Risk score 5 or below)
		
		---
		#### 1.2.5 Risk assessment rules
		
		**Severity:**  
		_High_: These hazards pose immediate threats to health or life. They require instant action to mitigate. Examples include a fire, gas leak, or carbon monoxide poisoning.
		
		_Medium_: These hazards could lead to potential costs if not addressed promptly. They might not directly threaten health or life but can cause significant damage or inconvenience. For instance, unauthorized access could lead to theft, while a water leak could cause property damage.
		
		_Low_: These hazards might cause minor costs if repeated over time, or could potentially impact health if the exposure is sustained or repeated. For example, poor air quality might not pose a direct threat but can lead to health issues over time. Similarly, a slight loss of heating or cooling might be uncomfortable but is not immediately dangerous.
		
		**Exposure:**  
		_Low:_ These hazards are very unlikely to occur. There might be very specific or rare conditions that could lead to these hazards, but under normal circumstances, the chances are minimal.
		
		_Medium:_ These hazards are possible under certain circumstances. They might not happen regularly, but there are known situations or conditions where these hazards could materialize.
		
		_High:_ These hazards occur often or under a wide range of common conditions. They are part of the routine or daily operation and therefore have a higher likelihood of happening.
		
		**Controllability:**  
		_Low:_ These hazards are beyond the control of the residents or can only be mitigated in a limited way. They often require the involvement of specialists or emergency services to manage. For example, a gas leak would be considered a low controllability hazard, as it requires professional assistance to mitigate.
		
		_Medium:_ Residents can mitigate these hazards, but it may take time and the recovery may not be complete. These are situations that may not be easily managed remotely. For example, a water leak could be considered a medium controllability hazard, as a resident could potentially stop the leak, but may not be able to repair the damage without professional help.
		
		_High:_ These hazards can be easily mitigated if residents are notified in time, and many of these situations can be managed remotely. For instance, an open window could be considered a high controllability hazard, as it can be simply closed if a resident is notified and still in the house, or potentially even remotely via an automated system.
		
		---
		
		#### 1.2.6 Risk assessment table
		
		| Hazard                    | Severity   | Exposure   | Controllability | Risk Score     | Level   |
		| ------------------------- | ---------- | ---------- | --------------- | -------------- | ------- |
		| Unauthorized Access       | High (3)   | Medium (2) | Low (3)         | (2x3)x2x3 = 36 | Level 1 |
		| System cybersecurity      | High (3)   | High (3)   | High (1)        | (2x3)x3x1 = 18 | Level 2 |
		| Fire                      | High (3)   | Low (1)    | Low (3)         | (2x3)x1x3 = 18 | Level 2 |
		| Gas Leak                  | High (3)   | Low (1)    | Low (3)         | (2x3)x1x3 = 18 | Level 2 |
		| Carbon Monoxide Poisoning | High (3)   | Low (1)    | Low (3)         | (2x3)x1x3 = 18 | Level 2 |
		| Electrical Shock          | High (3)   | Medium (2) | Low (3)         | (2x3)x2x3 = 36 | Level 1 |
		| Poor Air Quality          | Low (1)    | High (3)   | Medium (2)      | (2x1)x3x2 = 12 | Level 3 |
		| Unsafe Cold Exposure      | Medium (2) | High (3)   | Medium (2)      | (2x2)x3x2 = 24 | Level 1 |
		| Unsafe Heat Exposure      | Medium (2) | High (3)   | Medium (2)      | (2x2)x3x2 = 24 | Level 1 |
		| System Failure            | High (3)   | Low (1)    | Low (3)         | (2x3)x1x3 = 18 | Level 2 |
		| Water Leak/Flood          | Medium (2) | High (3)   | Medium (2)      | (2x2)x3x2 = 24 | Level 1 |
		| Loss of Heating/Cooling   | Medium (2) | Low (1)    | Low (3)         | (2x2)x1x3 = 12 | Level 3 |
		
		
		> Certainly, it's important to note that the initial risk assessment you have conducted takes into consideration the basic safety measures that are commonly found in homes, even without the presence of a home automation system. These traditional safety measures form the baseline upon which the home automation system's additional safety features are built. (ie. RCD, door locks or manual window locks)
		---
		### 1.3 Safety goals
		
		#### 1.3.1.1 Unauthorized Access:
		
		    - The system shall continuously monitor for indications of unauthorized access or unexpected movement when the home is declared unoccupied.
		    - The system shall immediately issue alerts to the occupants upon detection of unauthorized access or unexpected movement.
		    - The system shall communicate an alert signal to a pre-defined security company upon detection of unauthorized access or unexpected movement.
		    - The system shall persistently monitor the status of external doors in relation to the home occupancy status.
		    - The system shall ensure closure of external doors within a predefined timeout interval.
		    - The system shall ascertain the closure of critical windows in the absence of occupants or presence of minors.
		    - The system shall ensure external doors are locked when the house is unoccupied or all occupants are asleep.
		    - The system shall ensure critical windows are closed when the house is unoccupied or all occupants are asleep.
		
		#### 1.3.2 System cybersecurity:
		
		    - The system cybersecurity will be thoroughly covered during the Threat and Risk Assessment (TARA) process.
		
		#### 1.3.3 Fire:
		
		    - The system shall actively detect the presence of smoke.
		    - The system shall promptly alert the occupants in the event of a fire.
		    - The system shall schedule and issue reminders for maintenance of fire sensors.
		    - The system shall unlock external doors to expedite evacuation in case of fire.
		
		#### 1.3.4 Gas Leak:
		
		    - The system shall alert the occupants promptly upon detection of a gas leak.
		    - The system shall automatically disengage the main gas supply when a gas leak is detected.
		    - The system shall schedule and issue reminders for maintenance of gas sensors.
		
		#### 1.3.5 Carbon Monoxide Poisoning:
		
		    - The system shall alert occupants when hazardous levels of carbon monoxide are detected.
		    - The system shall schedule and issue reminders for maintenance of CO sensors.
		
		#### 1.3.6 Water Leak/Flood:
		
		    - The system shall promptly alert the occupants upon detecting a leak.
		    - The system shall disengage the water supply upon detection of a leak.
		    - The system shall alert occupants if any doors or windows are open in case of a rain/storm forecast.
		
		#### 1.3.7 Electrical Shock:
		
		    - The system shall schedule and notify for maintenance of the Residual Current Device (RCD).
		
		#### 1.3.8 Poor Air Quality:
		
		    - The system shall promptly notify residents when the air quality within the home deteriorates below a predefined standard.
		    - The system shall to anticipate potential deterioration of indoor air quality and take preventive actions.
		    - The system shall interface with air purifiers within the home to maintain air quality.
		
		#### 1.3.9 Unsafe Cold Exposure:
		
		    - The system shall alert the occupants if the temperature drops below a certain threshold.
		    - The system shall interface with the home heating system to mitigate cold exposure hazards.
		    - The system shall perform proactive actions and issue user notifications based on available data to prevent cold exposure and maintain comfortable indoor conditions.
		
		#### 1.3.10 Unsafe Heat Exposure:
		
		    - The system shall alert the occupants if the temperature rises above a certain threshold.
		    - The system shall interface with the home heating system and AC to mitigate heat exposure hazards.
		    - The system shall take proactive actions and issue notifications to prevent heat exposure and maintain comfortable conditions.
		
		#### 1.3.11 System Failure:
		
		    - The system shall consistently monitor the activity of all sensors and actuators to detect timeouts and failures.
		    - The system shall remind the users about updates periodically.
		    - The system shall provide a backup power supply to ensure continuous operation in the event of a power outage.
		    - The system shall perform regular self-checks or diagnostics to identify and alert users to potential failures or malfunctions.
		    - The system shall monitor network connectivity and performance, including Ethernet port status, system latency, and packet loss.
		    - The system shall monitor the health of the Zigbee network.
		    - The system shall integrate with the existing Home Automation (HA) fault manager.
		
		#### 1.3.12 Loss of Heating/Cooling:
		
		    - The system shall continuously monitor the current flow temperature and compare it against the expected temperature range to detect any potential heater errors or anomalies.
		
		---
		### 1.4 Risk Evaluation
		
		---
		
		In this stage, you compare the risk levels from your risk assessment with your predetermined risk acceptance criteria. Risk acceptance criteria can be defined based on factors such as legal requirements, industry standards, and the risk tolerance of the stakeholders involved.
		
		#### 1.4.1 Priority rules:
		
		**Level 1 Risks:** Level 1 must be addressed immediately due to its high severity, high exposure, and low controllability. These risks are the top priority and should be mitigated before moving forward with the implementation. However, if additional measures cannot be implemented, Level 1 risks should be clearly stated.
		
		**High Severity Risks:** Regardless of their exposure or controllability, risks with a high severity level should be next in line for mitigation. These risks can cause significant harm and, therefore, should be addressed promptly to protect the occupants and the property.
		
		**Low Controllability Risks:** After high exposure risks, focus on risks with low controllability. These are risks that occupants have little to no control over and, thus, require an effective mitigation strategy to prevent potential harm.
		
		Rest of safety measurements.
		---
		### 1.5 Risk Mitigation
		
		---
		
		For risks that need further mitigation, you'll need to develop a risk mitigation strategy. This strategy should outline specific actions to reduce the likelihood and/or impact of each risk. The strategy can include a variety of measures such as:
		
		    - _Mitigation:_ Reducing the impact or likelihood of the risk. This is often the main focus in the context of home automation systems.
		    - _Acceptance:_ Acknowledging the risk and preparing contingency plans.
		    - _Avoidance:_ Changing plans or strategies to entirely avoid the risk.
		    - _Transfer:_ Shifting the risk to another party, such as purchasing insurance.
		
		#### 1.5.1 Risk assessment after implementing safety goals:
		
		| Hazard                    | Severity   | Exposure   | Controllability | Risk Score     | Level   |
		| ------------------------- | ---------- | ---------- | --------------- | -------------- | ------- |
		| Unauthorized Access       | High (3)   | Low (1)    | Low (3)         | (2x3)x1x3 = 18 | Level 2 |
		| System cybersecurity      | High (3)   | Medium (2) | High (1)        | (2x3)x2x1 = 12 | Level 3 |
		| Fire                      | High (3)   | Low (1)    | Low (3)         | (2x3)x1x3 = 18 | Level 2 |
		| Gas Leak                  | High (3)   | Low (1)    | Medium (2)      | (2x3)x1x2 = 12 | Level 3 |
		| Carbon Monoxide Poisoning | High (3)   | Low (1)    | Low (3)         | (2x3)x1x3 = 18 | Level 2 |
		| Electrical Shock          | High (3)   | Low (1)    | Low (3)         | (2x3)x1x3 = 18 | Level 2 |
		| Poor Air Quality          | Low (1)    | Medium (2) | High (1)        | (2x1)x2x1 = 4  | Level 4 |
		| Unsafe Cold Exposure      | Medium (2) | Medium (2) | High (1)        | (2x2)x2x1 = 8  | Level 4 |
		| Unsafe Heat Exposure      | Medium (2) | Medium (2) | High (1)        | (2x2)x2x1 = 8  | Level 4 |
		| System Failure            | High (3)   | Low (1)    | Low (3)         | (2x3)x1x3 = 18 | Level 2 |
		| Water Leak/Flood          | Medium (2) | Medium (2) | Medium (2)      | (2x2)x2x2 = 16 | Level 3 |
		| Loss of Heating/Cooling   | Medium (2) | Low (1)    | Low (3)         | (2x2)x1x3 = 12 | Level 3 |
		---
		### 1.6 Risk Monitoring:
		
		---
		
		After mitigation measures are implemented, the risks are monitored to ensure that the mitigation measures are effective and to identify any new hazards that may arise.  
		TODO</file>
	<file path='docs\SafetyConcept\SafetyConcept - SYS.md'>
		# ISO 26262 Inspired Safety Strategy for Home Automation Systems
		
		## 1 Purpose
		    TODO
		## 2 System boundaries
		
		### 2.1 Inside the System Boundary:
		
		---
		
		**Hardware sensors - Input interface:**
		
		- windows contact sensor
		- door contact sensor
		- smoke detector
		- gas detector
		- carbon monooxide detector
		- climate sensor for each room (temperature and humidity)
		- inside air pollution
		- boiler signals and measurements
		
		**Cloud sensors - Input interface:**
		
		- Weather sensor
		  - Current temperature, pressure, wind speed, clouds
		  - Forecast for temperature, pressure, wind speed, clouds
		  - Hazardous fenoma:
		    - Storm alert
		    - Blizzard alert
		    - Wind alert
		    - Rain alert
		    - Heatwave alert
		    - Tornado alert
		- Occupancy sensor
		- Outside air pollution
		- System health data and system update information
		- Ethernet port status
		- Link status to router
		- Link status to WAN
		- System latency data
		- Packet loss data
		
		**HW Actuators - Output interface:**
		
		- Smart locks
		- Siren
		- Information light
		- Alert light
		
		**Cloud Actuators:**
		
		- Phone application popup
		- Main card in UI
		- User action scheduler
		
		**Processing:**
		
		- Home automation instance
		
		---
		
		### 2.2 Outside the System Boundary:
		
		- The physical environment where the home is located and which the sensors are monitoring
		- Users who interact with the system, either physically or through an interface/app
		- Internet services providing data such as weather forecasts
		
		## 3 System modes:
		
		---
		
		**Armed Mode:**
		
		- The system is actively monitoring for hazards and is ready to react.
		
		**Disarmed Mode:**
		
		- The system is not actively monitoring for hazards.
		
		**Maintenance Mode:**
		
		- The system checks the status of its sensors and actuators, updates its software, and performs other maintenance tasks.
		
		TODO - Add state machine
		
		## 4 Interfaces requirements:
		
		---
		
		### Smoke/Gas/CO sensor
		
		    - TODO
		
		### Smoke/Gas/CO sensor
		
		    - TODO
		
		### Window/Door contact
		
		    - Shall support contact notification
		    - Shall support remained batery value
		
		### House occupy
		
		    - Sleep time - Event that notify that everyone goes to sleep
		    - Leave - Home is empty less than 1 day
		    - Vacation - Home is empty more than 1 day
		    - Home Alone: Only one person is at home. This could adjust safety and security measures, and change other settings like temperature or lighting.
		    - Guests: You have guests over. This may require different settings for privacy, security, or comfort.
		    - Kids: Only not adult residents are in house.
		    - Occupied: Adult residents are in house
		
		### Weather sensor
		
		    - TODO
		
		### Weather environmental hazards:
		
		    - Freezing - Temperature below 4 C
		    - Storm - Incoming storm
		    - Rain
		    - Air pollution - Air pollution 2.5pmm above 20
		    - Heatwave: High temperatures might require specific responses such as closing blinds, turning on air conditioning, etc.
		    - High Wind: Could lead to similar responses as a storm.
		    - Snow: Cold temperatures combined with snowfall might affect heating systems and require specific actions.
		    - High Humidity: This might trigger dehumidifiers or other responses to control internal humidity.
		
		### Outside air pollution sensor
		
		    - TODO
		
		### System health data and system update information
		
		    - TODO
		
		### Ethernet network health:
		
		    - Ethernet port status
		    - Link status to router
		    - Link status to WAN
		    - System latency data
		    - Packet loss data
		
		### Heating output values
		
		    - TODO
		
		### Heating input values
		
		    - TODO
		
		### Smart lock actuator
		
		    - TODO
		
		### Alarm siren
		
		    - TODO
		
		### Informational light
		
		    - TODO
		
		### Smart lock actuator
		
		    - TODO
		
		### Alert light
		
		    - TODO
		
		### Phone application popup
		
		    - TODO
		
		### Lovelance card
		
		    - TODO
		
		### User action scheduler
		
		    - TODO
		
		---
		
		## 5 Common requirements:
		
		- Critical windows/door are elements that should be closed if nobody are in house, like front windows.
		
		---
		- Notifiaction levels:
		
		    |Description         |  Notification            |
		    | ------- |-------------------------- |
		    | Level 1 | Home assistant notification on phone with higher priority, sound alarm, light notification as yellow, and dashboard information as hazard |
		    | Level 2 | Home assistant notification on phone with higher priority, light notification as yellow, and dashboard information as hazard              |
		    | Level 3 | Home assistant notification on phone and dashboard information as warning                                                                 |
		    | Level 4 | Dashboard information                                                                                                                     |
		---
		
		## 6 System safety components:
		
		---
		
		### 6.1 **Window and door Monitoring Component:**
		
		**Inputs:**
		
		- Window contact sensor data
		- Occupancy sensor data
		- Room temperature sensor data
		- Outside temperature data (from weather forecast)
		- Rain forecast data (from weather forecast)
		- Storm forecast data (from weather forecast)
		
		**Outputs:**
		
		- Alerts to occupants (via various channels)
		- Heating system actactors
		
		**Safety Goals Addressed:**
		
		- The system shall ascertain the closure of critical windows in the absence of occupants, presence of minors or all occupants are asleep.
		- The system shall alert the occupants if the temperature drops below a certain threshold.
		- The system shall alert the occupants if the temperature rises, windows are closed, and the external temperature is lower than the room temperature.
		- The system shall alert occupants if any doors or windows are open in case of a rain forecast.
		- The system shall alert occupants if any doors or windows are open in case of a storm forecast.
		- The system shall interface with the home heating system to mitigate cold exposure hazards.
		- The system shall alert the occupants if air quality deteriorates below a predefined standard and windows are open.
		
		**States and Transitions:**
		
		#### SM_WMC_1 (Windows status if house empty)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Are all critical \nwindows closed?}
		    B -->|Yes| A
		    B -->|No| C{Is the house unoccupied, \npresensce only minors or \nall occupants are asleep?}
		    C -->|No| A
		    C -->|Yes| E[SM performed]
		    E -->|Healing: House is occupied| A
		```
		
		    - SM shall be realized by notification of level 2
		
		#### SM_WMC_2 (TODO)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Are windows closed\n within room?}
		    B -->|Yes| A
		    B -->|No| C{Is room temperature below\n CAL_THR_RoomXLeve1Cold?}
		    C -->|No| D{Is dT/dt below \nCAL_THR_RoomXColdRate*?}
		    C -->|Yes| E[Notification on level B?]
		    D -->|No| A
		    D-->|Yes| E[SM performed]
		    E -->|Healing: windows closed or\n temperature raised| A
		```
		
		    - SM shall be realized by notification of level 2
		
		#### SM_WMC_3 (Window Monitoring and Temperature Control in Unoccupied Rooms)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Are windows closed\n within room?}
		    B -->|No| A
		    B -->|Yes| C{Is room temperature over \nCAL_THR_RoomXLevel1Warm?}
		    C -->|No| A
		    C -->|Yes| D{Is dT/dt over \nCAL_THR_RoomXWarmRate?}
		    D -->|Yes| E{Is outside temperature\n lower than in room?}
		    D  -->|No| A
		    E -->|No| A
		    E -->|Yes| F[SM perform ]
		    F -->|Healing: windows open or\n temperature failing| A
		```
		
		    - SM shall be realized by notification of level 3
		
		#### SM_WMC_4 (Rain monitoring)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Are all rain-sensitive\n windows closed?}
		    B -->|Yes| A
		    B -->|No| C{Is rain forecast?}
		    C -->|No| A
		    C -->|Yes| E[SM perfomed]
		    E -->|Healing: Rain not longer forecasted or\n all windows closed| A
		```
		
		    - SM shall be realized by notification of level 2
		
		#### SM_WMC_5 (Storm monitoring)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Are all windows\n closed?}
		    B -->|Yes| A
		    B -->|No| C{Is storm \nforecasted?}
		    C -->|No| A
		    C -->|Yes| E[SM perfomed]
		    E -->|Healing: Storm not longer forecasted or\n all windows closed| A
		```
		
		    - SM shall be realized by notification of level 2
		
		#### SM_WMC_6 (Level2 cold exposure)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Are windows are\n closed within room?}
		    B -->|Yes| A
		    B -->|No| C{Is room temperature below\n CAL_THR_RoomXLevel2ColdHazard?}
		    C -->|No| A
		    C-->|Yes| E[SafeMeas performed]
		    E -->|Healing: window closed or \ntemperature raised| A
		```
		
		    - SM shall be realized increasing setpoint value for specif room by CAL_THR_HeatingIncrease
		
		#### SM_WMC_7 (Rain-sensitive Window Monitoring and Forecast Awareness)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Are all windows closed?}
		    B -->|Yes| A
		    B -->|No| C{Is outside air quality under\n CAL_THR_AirQ?}
		    C -->|Yes| A
		    C -->|No| E[SM performed]
		    E -->|Healing: House is occupied| A
		```
		
		    - SM shall be realized by notification of level 2
		
		#### SM_WMC_8 (Windows Sensor Maintenance Reminder)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Check if \nCAL_WSensorMaintPer\n elapsed?}
		    B -->|No| A
		    B -->|Yes| C[SM performed]
		    C -->|Healing: User confirmation| A
		```
		
		    -SM shall be realized by scheduling maintenance action for user
		
		---
		
		### 6.2 **Hazardous Atmosphere Detection Component:**
		
		**Inputs:**:
		
		- Smoke detector sensor data
		- Gas detector sensor data
		- Carbon monoxide detector sensor data
		
		**Outputs:**
		
		- Alerts to occupants
		- External doors unlocked for evacuation
		- Scheduler
		
		**Safety Goals Addressed:**
		
		- The system shall actively detect the presence of smoke.
		- The system shall promptly alert the occupants in the event of a fire.
		- The system shall schedule and issue reminders for maintenance of fire sensors.
		- The system shall unlock external doors to expedite evacuation in case of fire.
		- The system shall alert the occupants promptly upon detection of a gas leak.
		- The system shall automatically disengage the main gas supply when a gas leak is detected.
		- The system shall schedule and issue reminders for maintenance of gas sensors.
		- The system shall alert occupants when hazardous levels of carbon monoxide are detected.
		- The system shall schedule and issue reminders for maintenance of CO sensors.
		
		#### SM_HADC_1 (Smoke Detection and Alert)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Smoke detected?}
		    B -->|No| A
		    B -->|Yes| C[SM performed]
		    C -->|Healing: User confirmation| A
		```
		
		    -SM shall be realized by notification of level 1 and evacuation process
		
		#### SM_HADC_2 (Gas Detection and Alert)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Gas detected?}
		    B -->|No| A
		    B -->|Yes| C[SM performed]
		    C -->|Healing: User confirmation| A
		```
		
		    -SM shall be realized by notification of level 1 and evacuation process
		
		#### SM_HADC_3 (Carbon monoxide detection and Alert)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Carbon monoxide detected?}
		    B -->|No| A
		    B -->|Yes| C[SM performed]
		    C -->|Healing: User confirmation| A
		```
		
		    -SM shall be realized by notification of level 1 and evacuation process
		
		#### SM_HADC_4 (Gas Leak Sensor Maintenance)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Check if \nCAL_GasLeakSensorMaintePer elapsed?}
		    B -->|No| A
		    B -->|Yes| C[SM performed]
		    C -->|Healing: User confirmation| A
		```
		
		    -SM shall be realized by schedule maintenance action for user
		
		#### SM_HADC_5 (Smoke Sensor Maintenance)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Check if \nCAL_SmokeSensorMaintePer elapsed?}
		    B -->|No| A
		    B -->|Yes| C[SM performed]
		    C -->|Healing: User confirmation| A
		```
		
		    -SM shall be realized by schedule maintenance action for user
		
		#### SM_HADC_6 (CO Sensor Maintenance)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Check if \nCAL_COSensorMaintePer elapsed?}
		    B -->|No| A
		    B -->|Yes| C[SM performed]
		    C -->|Healing: User confirmation| A
		```
		
		    -SM shall be realized by schedule maintenance action for user
		
		### 6.3 ** TO DELETE : Door Monitoring Component:**
		
		**Inputs:**
		
		- Door contact sensor data
		- Occupancy sensor data
		
		**Outputs:**
		-Alerts to occupants
		-SmartLocks
		
		**Safety Goals Addressed:**
		
		- The system shall persistently monitor the status of external doors in relation to the home occupancy status.
		- The system shall ensure closure of external doors within a predefined timeout interval.
		- The system shall alert occupants if any doors or windows are open in case of a rain forecast.
		- The system shall alert occupants if any doors or windows are open in case of a storm forecast.
		- The system shall ensure external doors are locked when the house is unoccupied or all occupants are asleep.
		
		#### SM_DMC_1 (External Door Monitoring in Absence)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is the house in \nleave / vacations /\n sleep /\n home alone /\n occupancy status?}
		    B -->|No| A
		    B -->|Yes| C{Are any external\n doors open?}
		    C -->|No| A
		    C -->|Yes| D[SM performed]
		    D -->|Healing: Door closed or \nhouse is occupied| A
		```
		
		    -SM shall be realized by sending a notification of level 2
		
		#### SM_DMC_2 (External Door Open Duration Monitoring)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is any external door\n open for longer than \nCAL_DoorXOpenDurTmnt ?}
		    B -->|No| A
		    B -->|Yes| C[SM performed]
		    C -->|Healing: Door closed| A
		```
		
		    -SM shall be realized by sending a notification of level 2
		
		#### SM_DMC_3 (Occupancy-based External Door Locking)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is everyone asleep \nor has everyone left the house?}
		    B -->|No| A
		    B -->|Yes| C{Are any external \ndoors unlocked?}
		    C -->|No| A
		    C -->|Yes| D[SM performed]
		    D -->|Healing: Door locked or \nsomeone is awake/has returned home| A
		```
		
		    - SM shall be realized by sending a notification of level 3 and scheduling a door lock action if feasible.
		
		#### SM_DMC_4 (Maintenance of Door Sensors)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Check if \nCAL_DoorSensorMaintPer\n elapsed?}
		    B -->|No| A
		    B -->|Yes| C[SM performed]
		    C -->|Healing: User confirmation| A
		```
		
		    -SM shall be realized by scheduling maintenance action for user
		
		### 6.3 **System Monitoring Component:**
		
		**Inputs:**
		
		- Sensor and actuator status data
		- System health data
		- Power supply status
		- System update information
		- Ethernet port status
		- Link status to router
		- Link status to WAN
		- System latency data
		- Packet loss data
		
		**Outputs:**
		
		- Alerts to occupants
		- System maintenance reminders/actions
		
		**Safety Goals Addressed:**
		
		- The system shall consistently monitor the activity of all sensors and actuators to detect timeouts and failures.
		- The system shall remind the users about updates periodically.
		- The system shall provide a backup power supply to ensure continuous operation in the event of a power outage.
		- The system shall perform regular self-checks or diagnostics to identify and alert users to potential failures or malfunctions.
		- The system shall monitor network connectivity and performance, including Ethernet port status, system latency, and packet loss.
		- The system shall monitor the health of the Zigbee network.
		- The system shall integrate with the existing Home Automation (HA) fault manager.
		
		#### SM_SMC_1a (Output Sanity Monitoring)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is Sensor/Actuator \nreturn sanity output ?}
		    B -->|Yes| A
		    B -->|No| C[SM performed]
		    C -->|Healing: Sensor/Actuator output \nreturns to normal or\n User confirms resolution| A
		```
		
		    - SM shall be realized by sending a notification based on sensor/actuator type.
		
		#### SM_SMC_1b (Timeout Monitoring)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Has Sensor/Actuator data\n been received within\n CAL_SensActuatorTimThrs?}
		    B -->|Yes| A
		    B -->|No| C[SM performed]
		    C -->|Healing: Sensor/Actuator sends data or\n User confirms resolution| A
		```
		
		    - SM shall be realized by sending a notification based on sensor/actuator type.
		
		#### SM_SMC_1c (Battery Level Monitoring)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is Sensor/Actuator \nbattery level within \nCAL_SensorActuatorBattLvlThrs?}
		    B -->|Yes| A
		    B -->|No| C[SM performed]
		    C -->|Healing: Sensor/Actuator \nbattery replaced or \nrecharged or \nUser confirms resolution| A
		```
		
		    - SM shall be realized by sending a notification to replace or recharge the battery, and scheduling the next battery replacement or recharge as required.
		
		#### SM_SMC_2 (System Update Reminder)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is there \na System Update available?}
		    B -->|No| A
		    B -->|Yes| C[SM performed]
		    C -->|Healing: System Update performed or\n User confirms delay| A
		```
		
		    - SM shall be realized by sending a notification of level 3
		
		#### SM_SMC_3 (Power Failure Management)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is there a power outage?}
		    B -->|No| A
		    B -->|Yes| C{Is a UPS installed and functioning?}
		    C -->|No| A
		    C -->|Yes| D[SM performed]
		    D -->|Healing: Power restored or \nUser confirms resolution| A
		```
		
		    - SM shall be realized by sending a notification of level 3
		
		#### SM_SMC_4a (CPU Usage Monitoring)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is CPU usage within \nCAL_CPUUsageThreshold?}
		    B -->|Yes| A
		    B -->|No| C[SM performed]
		    C -->|Healing: CPU usage returns to normal or \nUser confirms resolution| A
		```
		
		    - SM shall be realized by sending a notification of level 3
		
		#### SM_SMC_4b (RAM Usage Monitoring)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is RAM usage within \nCAL_RAMUsageThreshold?}
		    B -->|Yes| A
		    B -->|No| C[SM performed]
		    C -->|Healing: RAM usage returns to normal or \nUser confirms resolution| A
		```
		
		    - SM shall be realized by sending a notification of level 3
		
		#### SM_SMC_4c (Disk Space Monitoring)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is Disk Space within \nCAL_DiskSpaceThreshold?}
		    B -->|Yes| A
		    B -->|No| C[SM performed]
		    C -->|Healing: Disk Space freed up or\n User confirms resolution| A
		```
		
		    - SM shall be realized by sending a notification of level 3
		
		#### SM_SMC_4d (Hardware Temperature Monitoring)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is Hardware temperature within \nCAL_HardwareTemperatureThrsh?}
		    B -->|Yes| A
		    B -->|No| C[SM performed]
		    C -->|Healing: Hardware temperature \nreturns to normal or \nUser confirms resolution| A
		```
		
		    - SM shall be realized by sending a notification of level 3
		
		#### SM_SMC_4e (Ethernet Link Status)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is Ethernet link active?}
		    B -->|Yes| A
		    B -->|No| C[SM performed]
		    C -->|Healing: Ethernet link active| A
		```
		
		    - SM shall be realized by sending a notification of level 3
		
		#### SM_SMC_4f(Local Network Connectivity)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is router reachable?}
		    B -->|Yes| A
		    B -->|No| C[SM performed]
		    C -->|Healing: Router reachable| A
		```
		
		    - SM shall be realized by sending a notification of level 3
		
		#### SM_SMC_4g (Internet Access Management)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is Internet reachable?}
		    B -->|Yes| A
		    B -->|No| C[SM performed]
		    C -->|Healing: Internet reachable| A
		```
		
		    - SM shall be realized by sending a notification of level 3
		
		#### SM_SMC_4h (Internet Latency Monitoring)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is Internet latency \nbelow CAL_InternetLatencyThreshold?}
		    B -->|Yes| A
		    B -->|No| C[SM performed]
		    C -->|Healing: Internet latency \nabove threshold| A
		
		```
		
		    - SM shall be realized by sending a notification of level 3
		
		#### SM_SMC_4i (Packet Loss Monitoring)
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is packet loss below\n CAL_PacketLossThreshold?}
		    B -->|Yes| A
		    B -->|No| C[SM performed]
		    C -->|Healing: Packet loss \nabove threshold| A
		```
		
		    - SM shall be realized by sending a notification of level 3
		
		### 6.4 **HVAC Monitoring Component:**
		
		**Inputs:**
		
		- Current flow temperature
		- Heater/cooler status
		
		**Outputs:**
		
		- Alert to occupants
		- HVAC maintenance reminders/actions
		
		**Outputs:**
		
		- The system shall continuously monitor the current flow temperature and compare it against the expected temperature range to detect any potential heater errors or anomalies.
		
		
		**SM_HMC_1 (Heating/Cooling Flow Monitoring)**
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is the current \nflow temperature within\n CAL_THRFlowTemperature?}
		    B -->|Yes| A
		    B -->|No| C[SM performed]
		    C -->|Healing: Flow temperature returns to normal| A
		```
		
		    - SM shall be realized by sending a notification of level 2
		
		---
		
		**SM_HMC_2 (Temperature Rate of Change Monitoring)**
		
		```mermaid
		flowchart TD
		    A[START] -->| | B{Is the current flow\n temperature within \nCAL_THRFlowTemperature?}
		    B -->|Yes| A
		    B -->|No| C[SM performed]
		    C -->|Healing: Flow temperature returns to normal| A
		```
		    - SM shall be realized by sending a notification of level 2
		
		---
		
		### 6.5 **System Health Monitor component:**
		
		### 6.6 **Temperature Monitor component:**
		
		#### 6.6.1 Overview
		**Purpose**
		
		The Temperature Monitor component is a dedicated safety monitoring system within the home automation environment, tasked with ensuring the wellbeing of occupants by detecting potential temperature-related hazards. Its operations are independent for each room, allowing for precise monitoring and targeted alerts. The scope includes:
		
		- Independently monitoring the temperature in each room against predefined safe temperature thresholds.
		- Interfacing with the home's HVAC system to provide adjustments due to detected temperature hazards.
		- Alerting occupants when a room's temperature approaches hazardous levels, enabling them to take preventive or corrective actions.
		- Utilizing predictive analytics to forecast potential temperature-related hazards specific to each room based on historical and real-time temperature data.
		- Generating and sending proactive notifications and recommended actions to occupants to mitigate forecasted temperature hazards.
		#### 6.6.2 Inputs
		
		    - Average Temperature sensor for each room
		    - All windows contact sensors
		    - Temperature outside
		    - Forecasted temperature
		    - Current room setpoint
		    - Next setpoint with elapsed time
		
		#### 6.6.3 Outputs
		    - Change setpoint
		    - HVAC Emergency heating 
		    - AC emergency cooling
		
		### 6.6.3 Hardware Requirements
		    - High-precision temperature sensors capable of reporting room-specific conditions with a tolerance of +/- 0.5°C (or +/- 1°F).
		    - Reliable window contact sensors that integrate with the home automation system to provide status updates.
		    - A compatible interface module that allows for communication and control between the Temperature Monitor component and the HVAC system.
		
		### 6.6.4 Software Requirements
		**Functional Requirements**: 
		
		    - The software shall collect data from each room's temperature sensor and compare it against the %ROOMX_LOW_TEMP_THRESHOLD% if any of inputs change value.
		    - The software shall integrate with an external API to obtain outside temperature and forecasted temperature data.
		    - The software shall monitor the current and next setpoint of the room's HVAC system along with the time remaining until the next setpoint change.
		
		**Performance Requirements**: 
		
		    - The system shall process temperature readings and execute the necessary logic to detect prefault conditions within a maximum time frame of 1s.
		    - Notifications must be sent to the occupants within 1s of detecting a temperature threshold breach.
		
		### 6.6.5 Calibrations
		
		    - %CAL_ROOMX_LOW_TEMP_THRESHOLD% - Risky temperature value for room X.
		    - %CAL_ROOMX_FORECAST_TIMESPAN% -  
		
		
		### 6.6.6 Safety Mechanisms
		
		### **LowTemperatureMonitoring (TC_SM1)**: 
		**Description**: 
		
		    Safety mechanism check temperature in current room and raise room prefault if falls behind given threshold. 
		
		**Safety Goals Addressed**
		
		    - The system shall alert the occupants if the temperature drops below a certain threshold.
		    - The system shall interface with the home heating system to mitigate cold exposure hazards.
		**Activity Diagram/Requirements**: 
		
		    - Prefault shall be set if temperature falls behind %ROOMX_LOW_TEMP_THRESHOLD%
		    - Prefault shall be healed if temperature is higher that %ROOMX_LOW_TEMP_THRESHOLD%
		    
		**Linked Prefault**: 
		
		        PR_TCSM1_ROOMX_UNDERTEMPEATURE
		**Mapped Prefaults to Fault**: 
		
		        F_UNDERTEMEPRATURE
		**Recovery Actions**: 
		
		        - Increase heating setpoint in that specyfic room as reaction.
		**Notification Actions**: 
		
		        Notification level 2 shall be raised.
		        Notification shall contains current temperature and room name.
		
		### **LowTemperatureForecasting (TC_SM2)**: 
		**Description**: 
		
		    LowTemperatureForecasting (TC_SM2) is a predictive safety mechanism within the home automation system that interfaces with the heating system to preemptively address and mitigate the risk of cold exposure. It utilizes advanced analytics to anticipate potential drops in temperature that could lead to discomfort or safety issues, initiating user notifications and automated adjustments to maintain a comfortable indoor environment.
		
		**Safety Goals Addressed**
		
		    - The system shall interface with the home heating system to mitigate cold exposure hazards.
		    - The system shall perform proactive actions and issue user notifications based on available data to prevent cold exposure and maintain comfortable indoor conditions.
		**Activity Diagram/Requirements**: 
		
		    - The system shall forecast temperature of room in next 3 hours based on current system state.
		    - If %ROOMX_LOW_TEMP_THRESHOLD% will be reached in next 1 hour, prefault shall be set
		    - If %ROOMX_LOW_TEMP_THRESHOLD% wont be reached in next 1 hour, prefault shall be healed
		    
		**Linked Prefault**: 
		
		        PR_TCSM2_ROOMX_UNDERTEMPEATURE_RISK
		**Mapped Prefaults to Fault**: 
		
		        F_UNDERTEMEPRATURE_RISK
		**Recovery Actions**: 
		
		        - Increase heating setpoint in that specyfic room as reaction.
		        - Ask user to close windows if open.
		        - Ask user to open door to mix air with rest of house.
		**Notification Actions**: 
		
		        Notification level 3 shall be raised. 
		        Notification shall contains current temperature and room name.      
		
		#### 6.7 **Water Leak Monitor component:**
		
		## 7 Safety dashboard:
		
		## 8 Utility components:</file>
	<file path='docs\SafetyConcept\SM_template.md'>
		# Safety Component
		
		## Overview
		
		### Purpose
		- A brief description of the Safety Component's purpose within the home automation environment, emphasizing its role in ensuring the safety and well-being of occupants by detecting and responding to potential hazards.
		
		### Scope
		- An outline of the component's operational scope, including the types of hazards it's designed to detect and the areas of the home it covers.
		
		## Inputs
		- A list and description of the inputs required by the Safety Component, such as sensor data, environmental conditions, and user settings.
		
		## Outputs
		- Details of the outputs generated by the Safety Component, including alerts, system adjustments, and emergency responses.
		
		## Hardware Requirements
		- Specifications for the necessary hardware, including sensors, actuators, and communication interfaces, to support the component's functionality.
		
		## Software Requirements
		
		### Functional Requirements
		- Description of the software's tasks, such as data collection, hazard detection, and integration with other home automation systems.
		
		### Performance Requirements
		- Expected system performance, including processing speeds for hazard detection and response times for alerts and system adjustments.
		
		## Calibrations
		- Information on calibration settings and thresholds for detecting hazards, ensuring the component operates accurately and effectively.
		
		## Safety Mechanisms
		
		### Mechanism 1 (e.g., Low Temperature Monitoring)
		#### Description
		- A detailed description of this safety mechanism, including its method for detecting and responding to specific hazards.
		#### Safety Goals Addressed
		- The specific safety goals this mechanism aims to achieve.
		#### Activity Diagram/Requirements
		- The logic flow and requirements for detecting and responding to hazards, including conditions for setting and clearing alerts.
		#### Linked Prefault
		- Information on the specific prefault condition related to this mechanism.
		#### Mapped Prefaults to Fault
		- How prefaults are escalated to faults within the system's safety logic.
		#### Recovery Actions
		- Actions taken by the system to mitigate detected hazards.
		#### Notification Actions
		- Details of the notifications sent to occupants, including notification level and information content.
		
		### Mechanism 2 (e.g., Smoke Detection)
		#### (Repeat the same structure as Mechanism 1)</file>
	<file path='frontend\.d.ts'>
		interface CustomEnv {
		  NODE_ENV: 'development' | 'production';
		  VITE_HA_URL: string;
		  VITE_FOLDER_NAME: string;
		  VITE_SSH_USERNAME: string;
		  VITE_SSH_PASSWORD: string;
		  VITE_SSH_HOSTNAME: string;
		  VITE_HA_TOKEN: string;
		  [key: string]: unknown;
		}
		
		// For Vite's import.meta.env
		interface ImportMeta {
		  env: CustomEnv;
		}
		
		// For Node's process.env
		declare global {
		  namespace NodeJS {
		    interface ProcessEnv extends CustomEnv {}
		  }
		}</file>
	<file path='frontend\.gitignore'>
		# Logs
		logs
		*.log
		npm-debug.log*
		yarn-debug.log*
		yarn-error.log*
		pnpm-debug.log*
		lerna-debug.log*
		
		node_modules
		dist
		dist-ssr
		*.local
		
		# Editor directories and files
		.vscode/*
		!.vscode/extensions.json
		.idea
		.DS_Store
		*.suo
		*.ntvs*
		*.njsproj
		*.sln
		*.sw?
		
		**.env</file>
	<file path='frontend\.nvmrc'>
		20</file>
	<file path='frontend\.prettierignore'>
		# Add files here to ignore them from prettier formatting
		**/node_modules
		/dist
		/coverage
		**/*.css
		**/*.md
		**/*.mjs</file>
	<file path='frontend\.prettierrc'>
		{
		  "singleQuote": true,
		  "quoteProps": "as-needed",
		  "arrowParens": "avoid",
		  "tabWidth": 2,
		  "trailingComma": "es5",
		  "semi": true,
		  "jsxSingleQuote": true,
		  "printWidth": 140
		}</file>
	<file path='frontend\eslint.config.js'>
		import js from '@eslint/js';
		import globals from 'globals';
		import reactHooks from 'eslint-plugin-react-hooks';
		import reactRefresh from 'eslint-plugin-react-refresh';
		import tseslint from 'typescript-eslint';
		
		export default tseslint.config(
		  { ignores: ['dist'] },
		  {
		    extends: [js.configs.recommended, ...tseslint.configs.recommended],
		    files: ['**/*.{ts,tsx}'],
		    languageOptions: {
		      ecmaVersion: 2020,
		      globals: globals.browser,
		    },
		    plugins: {
		      'react-hooks': reactHooks,
		      'react-refresh': reactRefresh,
		    },
		    rules: {
		      ...reactHooks.configs.recommended.rules,
		      'react-refresh/only-export-components': ['warn', { allowConstantExport: true }],
		    },
		  }
		);</file>
	<file path='frontend\index.html'><![CDATA[
		<!doctype html>
		<html lang="en">
		  <head>
		    <meta charset="UTF-8" />
		    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
		    <link href="https://cdn.jsdelivr.net/npm/@mdi/font/css/materialdesignicons.min.css" rel="stylesheet" />
		    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
		    <title>Vite + React + TS</title>
		  </head>
		  <body>
		    <div id="root"></div>
		    <script type="module" src="/src/main.tsx"></script>
		  </body>
		</html>]]></file>
	<file path='frontend\package.json'><![CDATA[
		{
		  "name": "safetyhome",
		  "private": true,
		  "version": "0.0.0",
		  "type": "module",
		  "scripts": {
		    "dev": "vite",
		    "build": "tsc -b && vite build",
		    "lint": "eslint .",
		    "preview": "vite preview",
		    "prettier": "prettier --write .",
		    "sync": "npx tsx ./sync-types.ts",
		    "prebuild": "npm run prettier",
		    "deploy": "npx tsx scripts/deploy.ts"
		  },
		  "dependencies": {
		    "@hakit/components": "^4.0.4",
		    "@hakit/core": "^4.0.4",
		    "react": "^18.3.1",
		    "react-dom": "^18.3.1",
		    "react-router-dom": "^7.1.1"
		  },
		  "devDependencies": {
		    "@eslint/js": "^9.17.0",
		    "@types/node": "^22.10.5",
		    "@types/react": "^18.3.18",
		    "@types/react-dom": "^18.3.5",
		    "@vitejs/plugin-react": "^4.3.4",
		    "autoprefixer": "^10.4.20",
		    "chalk": "^5.4.1",
		    "dotenv": "^16.4.7",
		    "eslint": "^9.17.0",
		    "eslint-plugin-react-hooks": "^5.0.0",
		    "eslint-plugin-react-refresh": "^0.4.16",
		    "globals": "^15.14.0",
		    "node-scp": "^0.0.23",
		    "postcss": "^8.5.1",
		    "prettier": "^3.4.2",
		    "tailwindcss": "^3.4.17",
		    "typescript": "~5.6.2",
		    "typescript-eslint": "^8.18.2",
		    "vite": "^6.0.5"
		  }
		}]]></file>
	<file path='frontend\postcss.config.cjs'>
		module.exports = {
		  plugins: {
		    tailwindcss: {},
		    autoprefixer: {},
		  },
		};</file>
	<file path='frontend\README.md'><![CDATA[
		## Prerequisites
		Node version manager - [NVM](https://github.com/nvm-sh/nvm) to easily install and manage node versions
		
		## Local Development
		Simply, run `nvm use && npm i && npm run dev` and it will start a local server for you to develop on, it will also watch for changes and reload the page for you. 
		
		## Dependencies
		
		```json
		Node.js >=18.0.0
		npm >=7.0.0
		```
		
		## Building
		Run `npm run build` and it will build the files for you, you can then upload them to your home assistant instance using the deploy script mentioned below.
		
		## Deploy to Home Assistant via SSH
		1. Replace the values in the .env file provided with your `VITE_SSH_USERNAME`, `VITE_SSH_HOSTNAME` and `VITE_SSH_PASSWORD`.
		2. To automatically deploy to your home assistant instance, you can run `npm run deploy` after you've retrieved the SSH information specified [here](https://shannonhochkins.github.io/ha-component-kit/?path=/docs/introduction-deploying--docs), NOTE! The script has already been created for you, you just need to run it after you've updated the .env values.
		3. The `VITE_FOLDER_NAME` is the folder that will be created on your home assistant instance, this is where the files will be uploaded to.
		
		## Folder name & Vite
		The `VITE_FOLDER_NAME` is the folder that will be created on your home assistant instance, this is where the files will be uploaded to. If you change the `VITE_FOLDER_NAME` variable, it will also update the `vite.config.ts` value named `base` to the same value so that when deployed using the deployment script the pathname's are correct.
		
		## Typescript Sync
		
		1. Replace the values in the .env file provided with your own!
		2. The `VITE_HA_URL` should be a https url if you want to sync your types successfully.
		3. The `VITE_HA_TOKEN` instructions can be found [here](https://shannonhochkins.github.io/ha-component-kit/?path=/docs/introduction-typescriptsync--docs) under the pre-requisites section.
		
		Once you have both the above environment variables set, you can run `npm run sync` and it will create a file for you, you then just have to add it to the tsconfig.json.
		
		## Further documentation
		For further documentation, please visit the [documentation website](https://shannonhochkins.github.io/ha-component-kit/) for more information.
		
		
		
		# React + TypeScript + Vite
		
		This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.
		
		Currently, two official plugins are available:
		
		- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
		- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh
		
		## Expanding the ESLint configuration
		
		If you are developing a production application, we recommend updating the configuration to enable type aware lint rules:
		
		- Configure the top-level `parserOptions` property like this:
		
		```js
		export default tseslint.config({
		  languageOptions: {
		    // other options...
		    parserOptions: {
		      project: ['./tsconfig.node.json', './tsconfig.app.json'],
		      tsconfigRootDir: import.meta.dirname,
		    },
		  },
		})
		```
		
		- Replace `tseslint.configs.recommended` to `tseslint.configs.recommendedTypeChecked` or `tseslint.configs.strictTypeChecked`
		- Optionally add `...tseslint.configs.stylisticTypeChecked`
		- Install [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) and update the config:
		
		```js
		// eslint.config.js
		import react from 'eslint-plugin-react'
		
		export default tseslint.config({
		  // Set the react version
		  settings: { react: { version: '18.3' } },
		  plugins: {
		    // Add the react plugin
		    react,
		  },
		  rules: {
		    // other rules...
		    // Enable its recommended rules
		    ...react.configs.recommended.rules,
		    ...react.configs['jsx-runtime'].rules,
		  },
		})
		```]]></file>
	<file path='frontend\scripts\deploy.ts'><![CDATA[
		import { Client as ScpClient } from 'node-scp';
		import { Client as SshClient } from 'ssh2';
		import * as dotenv from 'dotenv';
		import { join } from 'path';
		import chalk from 'chalk';
		import { access, constants } from 'fs/promises';
		
		dotenv.config();
		
		const HA_URL = process.env.VITE_HA_URL;
		const USERNAME = process.env.VITE_SSH_USERNAME;
		const PASSWORD = process.env.VITE_SSH_PASSWORD;
		const HOST_OR_IP_ADDRESS = process.env.VITE_SSH_HOSTNAME;
		const PORT = 22;
		const REMOTE_FOLDER_NAME = process.env.VITE_FOLDER_NAME;
		const LOCAL_DIRECTORY = './dist';
		const TEMP_REMOTE_PATH = `/tmp/${REMOTE_FOLDER_NAME}`; // Temporary upload path
		const FINAL_REMOTE_PATH = `/www/${REMOTE_FOLDER_NAME}`;
		
		async function checkDirectoryExists() {
		  try {
		    await access(LOCAL_DIRECTORY, constants.F_OK);
		    return true;
		  } catch (err) {
		    return false;
		  }
		}
		
		async function uploadFiles() {
		  const client = await ScpClient({
		    host: HOST_OR_IP_ADDRESS,
		    port: PORT,
		    username: USERNAME,
		    password: PASSWORD,
		  });
		
		  console.info(chalk.blue('Uploading', `"${LOCAL_DIRECTORY}"`, 'to', `"${TEMP_REMOTE_PATH}"`));
		  await client.uploadDir(LOCAL_DIRECTORY, TEMP_REMOTE_PATH);
		  client.close();
		  console.info(chalk.green('Files uploaded to temporary directory.'));
		}
		
		async function executeRemoteCommands() {
		  const ssh = new SshClient();
		
		  return new Promise<void>((resolve, reject) => {
		    ssh
		      .on('ready', () => {
		        console.info(chalk.blue('Connected via SSH. Executing commands...'));
		
		        ssh.exec(
		          `echo '${PASSWORD}' | sudo -S mkdir -p ${FINAL_REMOTE_PATH} && sudo -S rm -rf ${FINAL_REMOTE_PATH}/* && sudo -S mv ${TEMP_REMOTE_PATH}/* ${FINAL_REMOTE_PATH}/ && sudo -S rm -rf ${TEMP_REMOTE_PATH}`,
		          (err, stream) => {
		            if (err) {
		              reject(err);
		            }
		            stream
		              .on('close', (code, signal) => {
		                if (code === 0) {
		                  console.info(chalk.green('Files moved successfully with sudo.'));
		                  resolve();
		                } else {
		                  reject(new Error(`Command failed with code ${code}, signal ${signal}`));
		                }
		                ssh.end();
		              })
		              .on('data', data => {
		                console.log('STDOUT:', data.toString());
		              })
		              .stderr.on('data', data => {
		                console.error('STDERR:', data.toString());
		              });
		          }
		        );
		      })
		      .on('error', err => {
		        reject(err);
		      })
		      .connect({
		        host: HOST_OR_IP_ADDRESS,
		        port: PORT,
		        username: USERNAME,
		        password: PASSWORD,
		      });
		  });
		}
		
		async function deploy() {
		  try {
		    if (!HA_URL || !REMOTE_FOLDER_NAME || !USERNAME || !PASSWORD || !HOST_OR_IP_ADDRESS) {
		      throw new Error('Missing required environment variables in .env file.');
		    }
		
		    const exists = await checkDirectoryExists();
		    if (!exists) {
		      throw new Error('Missing ./dist directory, have you run `npm run build`?');
		    }
		
		    await uploadFiles();
		    await executeRemoteCommands();
		
		    console.info(chalk.green('\nSuccessfully deployed!'));
		    const url = join(HA_URL, '/local', REMOTE_FOLDER_NAME, '/index.html');
		    console.info(chalk.blue(`\n\nVISIT the following URL to preview your dashboard:\n`));
		    console.info(chalk.bgCyan(chalk.underline(url)));
		    console.info(
		      chalk.yellow(
		        '\n\nAlternatively, follow the steps in the ha-component-kit repository to install the addon for Home Assistant so you can load your dashboard from the sidebar!\n\n'
		      )
		    );
		    console.info('\n\n');
		  } catch (e: unknown) {
		    if (e instanceof Error) {
		      console.error(chalk.red('Error:', e.message ?? 'unknown error'));
		    }
		  }
		}
		
		deploy();]]></file>
	<file path='frontend\src\App.tsx'><![CDATA[
		import { HassConnect } from '@hakit/core';
		import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
		import Layout from './components/Layout';
		import Dashboard from './pages/Dashboard';
		import Temperature from './pages/Temperature';
		import LogPage from './pages/LogPage';
		
		export default function App() {
		  return (
		    <HassConnect hassUrl={import.meta.env.VITE_HA_URL} hassToken={import.meta.env.VITE_HA_TOKEN}>
		      <Router basename='/local/SafetyHome/'>
		        <Routes>
		          <Route path='/' element={<Layout />}>
		            <Route index element={<Dashboard />} />
		            <Route path='temperature' element={<Temperature />} />
		            <Route path='logs' element={<LogPage />} />
		          </Route>
		        </Routes>
		      </Router>
		    </HassConnect>
		  );
		}]]></file>
	<file path='frontend\src\components\ActionsList.tsx'><![CDATA[
		import React from 'react';
		import { useHass } from '@hakit/core';
		
		interface Action {
		  id: string;
		  title: string;
		  description: string;
		  status: 'pending' | 'in-progress' | 'completed';
		}
		
		const statusColors: Record<Action['status'], string> = {
		  pending: 'background-color: #7c2d12; color: #fde68a;',
		  'in-progress': 'background-color: #1e3a8a; color: #bfdbfe;',
		  completed: 'background-color: #065f46; color: #d1fae5;',
		};
		
		const ActionCard: React.FC<{ action: Action }> = ({ action }) => (
		  <div
		    style={{
		      backgroundColor: '#374151',
		      padding: '15px',
		      borderRadius: '8px',
		      boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
		      marginBottom: '15px',
		      color: '#f3f4f6',
		    }}
		  >
		    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
		      <div>
		        <h3 style={{ margin: 0, fontSize: '1.25rem', fontWeight: 'bold', color: '#f3f4f6' }}>
		          {action.title}
		        </h3>
		        <p style={{ margin: '5px 0 0', color: '#9ca3af' }}>{action.description}</p>
		      </div>
		      <span
		        style={{
		          padding: '5px 10px',
		          borderRadius: '16px',
		          fontSize: '0.875rem',
		          fontWeight: 'bold',
		          whiteSpace: 'nowrap',
		          ...parseStatusStyle(statusColors[action.status]),
		        }}
		      >
		        {action.status}
		      </span>
		    </div>
		  </div>
		);
		
		function parseStatusStyle(style: string) {
		  const styleObj: React.CSSProperties = {};
		  style.split(';').forEach(rule => {
		    const [key, value] = rule.split(':').map(s => s.trim());
		    if (key && value) {
		      styleObj[key as keyof React.CSSProperties] = value;
		    }
		  });
		  return styleObj;
		}
		
		const ActionsList: React.FC = () => {
		  const { getAllEntities } = useHass();
		  const entities = getAllEntities();
		
		  const appHealthEntity = entities['app_health'];
		  const actions: Action[] = appHealthEntity?.recoveryActions || [];
		
		  return (
		    <div style={{ padding: '20px', backgroundColor: '#1e293b', borderRadius: '8px' }}>
		      <h1 style={{ marginBottom: '20px', fontSize: '1.5rem', color: '#3b82f6' }}>Actions</h1>
		      {actions.length > 0 ? (
		        actions.map(action => <ActionCard key={action.id} action={action} />)
		      ) : (
		        <p style={{ color: '#9ca3af' }}>No recovery actions available.</p>
		      )}
		    </div>
		  );
		};
		
		export default ActionsList;]]></file>
	<file path='frontend\src\components\FaultSection.tsx'><![CDATA[
		import React, { useState } from 'react';
		import { useEntity } from '@hakit/core';
		
		const FaultSection: React.FC = () => {
		  const [openLevels, setOpenLevels] = useState<string[]>([]); // Track multiple opened levels
		  const healthEntity = useEntity('sensor.safety_app_health');
		  const faultsConfig = healthEntity?.attributes?.configuration?.faults || {};
		
		  const faultEntities = Object.keys(faultsConfig).map(faultKey => `sensor.fault_${faultKey.toLowerCase()}`);
		
		  const faultData = faultEntities.map(entityId => {
		    return {
		      id: entityId,
		      state: (useEntity(entityId) || {}).state || 'Unknown',
		      friendlyName: ((useEntity(entityId) || {}).attributes || {}).friendly_name || entityId.replace('sensor.fault_', ''),
		      description: ((useEntity(entityId) || {}).attributes || {}).description || '',
		      location: ((useEntity(entityId) || {}).attributes || {}).location || '',
		      level: ((useEntity(entityId) || {}).attributes || {}).level || 'level_4',
		    };
		  });
		
		  const groupedFaults = faultData.reduce<Record<string, typeof faultData>>((acc, fault) => {
		    if (!acc[fault.level]) acc[fault.level] = [];
		    acc[fault.level].push(fault);
		    return acc;
		  }, {});
		
		  const levelOrder = ['level_1', 'level_2', 'level_3', 'level_4'];
		  const levelTitles: Record<string, string> = {
		    level_1: 'Immediate Emergency',
		    level_2: 'Hazard',
		    level_3: 'Warning',
		    level_4: 'Notice',
		  };
		
		  const levelColors: Record<string, string> = {
		    level_1: '#EF4444', // red
		    level_2: '#F97316', // orange
		    level_3: '#EAB308', // yellow
		    level_4: '#3B82F6', // blue
		  };
		
		  const toggleLevel = (level: string) => {
		    setOpenLevels(prev => (prev.includes(level) ? prev.filter(l => l !== level) : [...prev, level]));
		  };
		
		  return (
		    <div className='w-full max-w-4xl mx-auto bg-gray-800 shadow-lg rounded-lg overflow-hidden'>
		      <div className='p-6 text-gray-100'>
		        <h2 className='text-2xl font-bold mb-6'>System Faults</h2>
		        <div>
		          {levelOrder.map(level => {
		            if (!groupedFaults[level]) return null;
		
		            return (
		              <div key={level} className='mb-4'>
		                <button
		                  onClick={() => toggleLevel(level)}
		                  className='w-full text-left p-4 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors duration-200 focus:outline-none'
		                >
		                  <div className='flex items-center justify-between'>
		                    <span className='text-lg font-semibold text-gray-100'>{levelTitles[level]}</span>
		                    <span className='bg-gray-600 text-gray-100 px-2 py-1 rounded-full text-sm'>{groupedFaults[level].length}</span>
		                  </div>
		                </button>
		                {openLevels.includes(level) && (
		                  <div className='mt-2 space-y-4'>
		                    {groupedFaults[level].map((fault, index) => (
		                      <div key={index} className='border rounded-lg overflow-hidden bg-gray-700'>
		                        <div style={{ backgroundColor: levelColors[fault.level] }} className='text-white p-4'>
		                          <h3 className='text-lg font-semibold'>{fault.friendlyName}</h3>
		                        </div>
		                        <div className='p-4 text-gray-100'>
		                          <p className='text-sm mb-2'>{fault.description}</p>
		                          <div className='flex justify-between items-center'>
		                            <span className='text-sm font-medium'>Location: {fault.location || 'None'}</span>
		                            <span
		                              style={{ backgroundColor: levelColors[fault.level] }}
		                              className='text-white font-bold px-3 py-1 rounded-full text-sm'
		                            >
		                              {fault.state}
		                            </span>
		                          </div>
		                        </div>
		                      </div>
		                    ))}
		                  </div>
		                )}
		              </div>
		            );
		          })}
		        </div>
		      </div>
		    </div>
		  );
		};
		
		export default FaultSection;]]></file>
	<file path='frontend\src\components\Layout.tsx'><![CDATA[
		import { Outlet, useNavigate, useLocation } from 'react-router-dom';
		import Topbar from './Topbar';
		import { useState, useEffect } from 'react';
		
		export default function Layout() {
		  const navigate = useNavigate();
		  const location = useLocation();
		
		  // Menu Items
		  const menuItems = [
		    {
		      title: 'Dashboard',
		      path: '/',
		      icon: 'mdi-view-dashboard',
		    },
		    {
		      title: 'Temperature',
		      path: '/temperature',
		      icon: 'mdi-thermometer',
		    },
		    {
		      title: 'Logs',
		      path: '/logs',
		      icon: 'mdi-clipboard-text',
		    },
		  ];
		
		  // Current Time
		  const [currentTime, setCurrentTime] = useState(new Date().toLocaleTimeString());
		
		  useEffect(() => {
		    const interval = setInterval(() => {
		      setCurrentTime(new Date().toLocaleTimeString());
		    }, 1000);
		    return () => clearInterval(interval);
		  }, []);
		
		  return (
		    <div style={{ display: 'flex', height: '100vh', backgroundColor: '#1e293b' }}>
		      {/* Sidebar */}
		      <div
		        style={{
		          width: '250px',
		          backgroundColor: '#111827',
		          color: '#fff',
		          display: 'flex',
		          flexDirection: 'column',
		          padding: '20px',
		          borderRight: '1px solid #334155',
		        }}
		      >
		        {/* Menu Items */}
		        {menuItems.map(item => (
		          <div
		            key={item.path}
		            onClick={() => navigate(item.path)}
		            style={{
		              display: 'flex',
		              alignItems: 'center',
		              gap: '10px',
		              padding: '10px 15px',
		              marginBottom: '10px',
		              borderRadius: '8px',
		              cursor: 'pointer',
		              backgroundColor: location.pathname === item.path ? '#2563eb' : 'transparent',
		              color: location.pathname === item.path ? '#fff' : '#9ca3af',
		              transition: 'background-color 0.2s, color 0.2s',
		            }}
		            onMouseEnter={e => {
		              if (location.pathname !== item.path) {
		                e.currentTarget.style.backgroundColor = '#1e293b';
		                e.currentTarget.style.color = '#fff';
		              }
		            }}
		            onMouseLeave={e => {
		              if (location.pathname !== item.path) {
		                e.currentTarget.style.backgroundColor = 'transparent';
		                e.currentTarget.style.color = '#9ca3af';
		              }
		            }}
		          >
		            {/* Icon */}
		            <span
		              className={`mdi ${item.icon}`}
		              style={{
		                fontSize: '20px',
		              }}
		            ></span>
		            {/* Title */}
		            <span style={{ fontSize: '16px' }}>{item.title}</span>
		          </div>
		        ))}
		
		        {/* Current Time */}
		        <div
		          style={{
		            marginTop: 'auto',
		            fontSize: '14px',
		            color: '#9ca3af',
		            textAlign: 'center',
		            padding: '10px 0',
		            borderTop: '1px solid #334155',
		          }}
		        >
		          <p>Current Time</p>
		          <p style={{ fontSize: '18px', color: '#fff', margin: 0 }}>{currentTime}</p>
		        </div>
		      </div>
		
		      {/* Main Content */}
		      <div
		        style={{
		          flex: 1,
		          display: 'flex',
		          flexDirection: 'column',
		          padding: '20px',
		          backgroundColor: '#0f172a',
		          color: '#fff',
		        }}
		      >
		        <Topbar />
		        <div
		          style={{
		            marginTop: '20px',
		            flex: 1,
		            backgroundColor: '#1e293b',
		            padding: '20px',
		            borderRadius: '8px',
		            boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
		          }}
		        >
		          <Outlet />
		        </div>
		      </div>
		    </div>
		  );
		}]]></file>
	<file path='frontend\src\components\LogList.tsx'><![CDATA[
		import React from 'react';
		
		interface Log {
		  timestamp: string;
		  type: 'info' | 'warning' | 'error';
		  message: string;
		  category: string;
		}
		
		const typeStyles: Record<Log['type'], string> = {
		  info: 'text-blue-400',
		  warning: 'text-yellow-400',
		  error: 'text-red-400',
		};
		
		interface LogListProps {
		  logs: Log[];
		  limit?: number; // Optional limit on the number of logs to display
		}
		
		const LogList: React.FC<LogListProps> = ({ logs, limit }) => {
		  // Optionally limit the number of logs
		  const displayedLogs = limit ? logs.slice(0, limit) : logs;
		
		  return (
		    <div>
		      {displayedLogs.map((log, index) => (
		        <div
		          key={index}
		          style={{
		            borderLeft: '4px solid #334155',
		            padding: '10px 15px',
		            marginBottom: '15px',
		            backgroundColor: '#111827',
		            borderRadius: '4px',
		          }}
		        >
		          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
		            {/* Log Type and Timestamp */}
		            <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>
		              <span className={`${typeStyles[log.type]} text-sm`} style={{ fontWeight: 'bold' }}>
		                {log.type.toUpperCase()}
		              </span>
		              <span className='text-gray-400 text-sm'>{new Date(log.timestamp).toLocaleString()}</span>
		            </div>
		            {/* Category */}
		            <span className='text-gray-500 text-sm'>{log.category}</span>
		          </div>
		          {/* Message */}
		          <p className='text-gray-200 mt-2' style={{ marginTop: '10px' }}>
		            {log.message}
		          </p>
		        </div>
		      ))}
		    </div>
		  );
		};
		
		export default LogList;]]></file>
	<file path='frontend\src\components\Topbar.tsx'><![CDATA[
		import { useEntity } from '@hakit/core';
		
		export default function Topbar() {
		  const safetyState = useEntity('sensor.safetysystem_state');
		  const healthState = useEntity('sensor.safety_app_health');
		
		  // Configuration for Safety Status
		  const statusConfig = {
		    level_4: {
		      label: 'Critical Alert',
		      bgColor: 'from-red-500 to-red-700',
		      textColor: 'text-white',
		      animation: 'animate-pulse', // Pulsating animation for critical state
		    },
		    level_3: {
		      label: 'High Alert',
		      bgColor: 'from-orange-500 to-orange-700',
		      textColor: 'text-white',
		      animation: 'animate-pulse', // Pulsating animation for high alert
		    },
		    level_2: {
		      label: 'Warning',
		      bgColor: 'from-yellow-400 to-yellow-600',
		      textColor: 'text-black',
		      animation: '', // No animation
		    },
		    level_1: {
		      label: 'Caution',
		      bgColor: 'from-blue-400 to-blue-600',
		      textColor: 'text-white',
		      animation: '', // No animation
		    },
		    cleared: {
		      label: 'System Safe',
		      bgColor: 'from-green-500 to-green-700',
		      textColor: 'text-white',
		      animation: '', // No animation
		    },
		  };
		
		  // Configuration for System Health
		  const healthConfig = {
		    running: {
		      label: 'System Running',
		      bgColor: 'from-green-400 to-green-600',
		      textColor: 'text-white',
		      animation: '', // No animation
		    },
		    stopped: {
		      label: 'System Stopped',
		      bgColor: 'from-red-500 to-red-700',
		      textColor: 'text-white',
		      animation: 'animate-pulse', // Pulsating animation for stopped state
		    },
		  };
		
		  // Current configurations
		  const currentStatus = statusConfig[safetyState] || statusConfig.cleared;
		  const currentHealth = healthConfig[healthState] || healthConfig.running;
		
		  return (
		    <div
		      style={{
		        display: 'flex',
		        justifyContent: 'flex-start',
		        alignItems: 'center',
		        padding: '15px 20px',
		        background: 'linear-gradient(to right, #0f172a, #1e293b)',
		        borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
		        gap: '40px',
		      }}
		    >
		      {/* Left Section: Title */}
		      <div>
		        <h1
		          style={{
		            margin: 0,
		            fontSize: '2rem',
		            fontFamily: 'Poppins, sans-serif',
		            color: '#3b82f6',
		            fontWeight: 'bold',
		            textShadow: '1px 1px 4px rgba(0, 0, 0, 0.5)',
		          }}
		        >
		          Home Safety System
		        </h1>
		        <p
		          style={{
		            margin: 0,
		            fontSize: '1rem',
		            color: '#94a3b8',
		            fontFamily: 'Roboto, sans-serif',
		          }}
		        >
		          Comprehensive Monitoring & Protection
		        </p>
		      </div>
		
		      {/* Safety Status */}
		      <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
		        <h3 style={{ margin: 0, fontSize: '1rem', color: '#94a3b8' }}>Safety Status:</h3>
		        <div
		          className={`px-4 py-2 rounded-full text-sm font-medium inline-flex items-center bg-gradient-to-r ${currentStatus.bgColor} ${currentStatus.textColor} ${currentStatus.animation}`}
		          style={{
		            boxShadow: '0px 4px 8px rgba(0, 0, 0, 0.2)',
		            cursor: 'pointer',
		          }}
		        >
		          <span>{currentStatus.label}</span>
		        </div>
		      </div>
		
		      {/* System Health */}
		      <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
		        <h3 style={{ margin: 0, fontSize: '1rem', color: '#94a3b8' }}>System Health:</h3>
		        <div
		          className={`px-4 py-2 rounded-full text-sm font-medium inline-flex items-center bg-gradient-to-r ${currentHealth.bgColor} ${currentHealth.textColor} ${currentHealth.animation}`}
		          style={{
		            boxShadow: '0px 4px 8px rgba(0, 0, 0, 0.2)',
		            cursor: 'pointer',
		          }}
		        >
		          <span>{currentHealth.label}</span>
		        </div>
		      </div>
		    </div>
		  );
		}]]></file>
	<file path='frontend\src\main.tsx'><![CDATA[
		import { StrictMode } from 'react';
		import { createRoot } from 'react-dom/client';
		import './styles/index.css';
		import App from './App.tsx';
		
		createRoot(document.getElementById('root')!).render(
		  <StrictMode>
		    <App />
		  </StrictMode>
		);]]></file>
	<file path='frontend\src\pages\Dashboard.tsx'><![CDATA[
		import React from 'react';
		import { Column } from '@hakit/components';
		import FaultSection from '../components/FaultSection'; // FaultSection component
		import ActionsList from '../components/ActionsList'; // ActionsList component
		import LogList from '../components/LogList'; // Reusable LogList component
		
		// Sample logs
		const logs = [
		  {
		    timestamp: '2025-01-14T12:00:00Z',
		    type: 'info',
		    message: 'System started successfully.',
		    category: 'System',
		  },
		  {
		    timestamp: '2025-01-14T12:05:00Z',
		    type: 'warning',
		    message: 'Temperature threshold exceeded in Living Room.',
		    category: 'Temperature',
		  },
		  {
		    timestamp: '2025-01-14T12:10:00Z',
		    type: 'error',
		    message: 'Gas leak detected in Kitchen!',
		    category: 'Safety',
		  },
		  {
		    timestamp: '2025-01-14T12:20:00Z',
		    type: 'info',
		    message: 'New sensor added to the system.',
		    category: 'System',
		  },
		  {
		    timestamp: '2025-01-14T12:30:00Z',
		    type: 'warning',
		    message: 'Humidity levels are above normal in Basement.',
		    category: 'Environment',
		  },
		];
		
		export default function Dashboard() {
		  return (
		    <div
		      style={{
		        display: 'flex',
		        flexDirection: 'column',
		        height: '100%',
		        padding: '20px',
		        backgroundColor: '#0f172a',
		        color: '#fff',
		      }}
		    >
		      {/* Dashboard Header */}
		      <h1 style={{ marginBottom: '20px', fontSize: '2rem', color: '#3b82f6' }}>Dashboard</h1>
		
		      {/* Main Content: Active Faults and Recovery Actions */}
		      <div
		        style={{
		          display: 'flex',
		          flex: 1,
		          gap: '20px',
		        }}
		      >
		        {/* Fault Section */}
		        <FaultSection />
		
		        {/* Recovery Actions */}
		        <div style={{ flex: 1, overflowY: 'auto' }}>
		          <h2 style={{ fontSize: '1.5rem', color: '#94a3b8', marginBottom: '10px' }}>Recovery Actions</h2>
		          <ActionsList />
		        </div>
		      </div>
		
		      {/* Recent Activity */}
		      <div style={{ marginTop: '20px' }}>
		        <h2 style={{ fontSize: '1.5rem', color: '#94a3b8', marginBottom: '10px' }}>Recent Activity</h2>
		        <div
		          style={{
		            backgroundColor: '#1e293b',
		            padding: '15px',
		            borderRadius: '8px',
		            overflowY: 'auto',
		            maxHeight: '200px',
		          }}
		        >
		          <LogList logs={logs} limit={5} /> {/* Display latest 5 logs */}
		        </div>
		      </div>
		    </div>
		  );
		}]]></file>
	<file path='frontend\src\pages\LogPage.tsx'><![CDATA[
		import React from 'react';
		import LogList from '../components/LogList'; // Reusable LogList component
		
		// Sample logs
		const logs = [
		  {
		    timestamp: '2025-01-14T12:00:00Z',
		    type: 'info',
		    message: 'System started successfully.',
		    category: 'System',
		  },
		  {
		    timestamp: '2025-01-14T12:05:00Z',
		    type: 'warning',
		    message: 'Temperature threshold exceeded in Living Room.',
		    category: 'Temperature',
		  },
		  {
		    timestamp: '2025-01-14T12:10:00Z',
		    type: 'error',
		    message: 'Gas leak detected in Kitchen!',
		    category: 'Safety',
		  },
		  {
		    timestamp: '2025-01-14T12:20:00Z',
		    type: 'info',
		    message: 'New sensor added to the system.',
		    category: 'System',
		  },
		  {
		    timestamp: '2025-01-14T12:30:00Z',
		    type: 'warning',
		    message: 'Humidity levels are above normal in Basement.',
		    category: 'Environment',
		  },
		];
		
		const LogPage: React.FC = () => {
		  return (
		    <div style={{ padding: '20px', backgroundColor: '#1e293b', borderRadius: '8px', color: '#fff' }}>
		      <h1 style={{ marginBottom: '20px', fontSize: '1.5rem', color: '#3b82f6' }}>System Logs</h1>
		      <LogList logs={logs} /> {/* Display all logs */}
		    </div>
		  );
		};
		
		export default LogPage;]]></file>
	<file path='frontend\src\pages\Temperature.tsx'><![CDATA[
		import React from 'react';
		
		const Temperature: React.FC = () => {
		  // Stubbed data for testing
		  const temperatureReadings = [
		    {
		      location: 'Living Room',
		      value: 28,
		      status: 'High',
		      timestamp: '2025-01-14T12:00:00Z',
		    },
		    {
		      location: 'Bedroom',
		      value: 22,
		      status: 'Normal',
		      timestamp: '2025-01-14T12:05:00Z',
		    },
		    {
		      location: 'Kitchen',
		      value: 35,
		      status: 'Critical',
		      timestamp: '2025-01-14T12:10:00Z',
		    },
		  ];
		
		  // Style configuration based on status
		  const statusStyles: Record<string, React.CSSProperties> = {
		    Normal: { color: '#10b981' }, // Green
		    High: { color: '#facc15' }, // Yellow
		    Critical: { color: '#ef4444' }, // Red
		  };
		
		  return (
		    <div style={{ padding: '20px', backgroundColor: '#0f172a', borderRadius: '8px', color: '#fff' }}>
		      <h1 style={{ marginBottom: '20px', fontSize: '2rem', color: '#3b82f6' }}>Temperature Monitoring</h1>
		
		      {/* Temperature Readings */}
		      <div style={{ marginBottom: '20px' }}>
		        <h2 style={{ fontSize: '1.5rem', color: '#94a3b8', marginBottom: '10px' }}>Current Readings</h2>
		        {temperatureReadings.map((reading, index) => (
		          <div
		            key={index}
		            style={{
		              borderLeft: `4px solid ${statusStyles[reading.status]?.color || '#94a3b8'}`,
		              padding: '10px 15px',
		              marginBottom: '15px',
		              backgroundColor: '#1e293b',
		              borderRadius: '4px',
		            }}
		          >
		            <div style={{ display: 'flex', justifyContent: 'space-between' }}>
		              <div>
		                <h3 style={{ margin: 0, fontSize: '1.25rem', fontWeight: 'bold', color: '#fff' }}>{reading.location}</h3>
		                <p style={{ margin: 0, color: '#9ca3af' }}>{new Date(reading.timestamp).toLocaleString()}</p>
		              </div>
		              <p
		                style={{
		                  margin: 0,
		                  fontSize: '1.25rem',
		                  fontWeight: 'bold',
		                  ...statusStyles[reading.status],
		                }}
		              >
		                {reading.value}°C
		              </p>
		            </div>
		            <p style={{ margin: '5px 0', color: '#9ca3af' }}>Status: {reading.status}</p>
		          </div>
		        ))}
		      </div>
		
		      {/* Summary */}
		      <div>
		        <h2 style={{ fontSize: '1.5rem', color: '#94a3b8', marginBottom: '10px' }}>Summary</h2>
		        <p style={{ color: '#d1d5db' }}>
		          Monitoring temperature levels across key locations. Alerts will be issued for critical or high readings.
		        </p>
		      </div>
		    </div>
		  );
		};
		
		export default Temperature;]]></file>
	<file path='frontend\src\styles\index.css'>
		@tailwind base;
		@tailwind components;
		@tailwind utilities;
		
		#root { width: 100%; height: 100%; }</file>
	<file path='frontend\src\vite-env.d.ts'><![CDATA[
		/// <reference types="vite/client" />]]></file>
	<file path='frontend\sync-types.ts'>
		import { typeSync } from '@hakit/core/sync';
		import { config } from 'dotenv';
		config();
		
		(async function () {
		  await typeSync({
		    url: process.env.VITE_HA_URL!,
		    token: process.env.VITE_HA_TOKEN!,
		  });
		})();</file>
	<file path='frontend\tailwind.config.js'>
		module.exports = {
		  content: ['./index.html', './src/**/*.{js,jsx,ts,tsx}'], // Include your source files
		  theme: {
		    extend: {},
		  },
		  plugins: [],
		};</file>
	<file path='frontend\tsconfig.app.json'>
		{
		  "compilerOptions": {
		    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
		    "target": "ES2020",
		    "useDefineForClassFields": true,
		    "lib": ["ES2020", "DOM", "DOM.Iterable"],
		    "module": "ESNext",
		    "skipLibCheck": true,
		
		    /* Bundler mode */
		    "moduleResolution": "bundler",
		    "allowImportingTsExtensions": true,
		    "isolatedModules": true,
		    "moduleDetection": "force",
		    "noEmit": true,
		    "jsx": "react-jsx",
		
		    /* Linting */
		    "strict": true,
		    "noUnusedLocals": true,
		    "noUnusedParameters": true,
		    "noFallthroughCasesInSwitch": true,
		    "noUncheckedSideEffectImports": true
		  },
		  "include": ["src"]
		}</file>
	<file path='frontend\tsconfig.json'>
		{
		  "files": [],
		  "references": [{ "path": "./tsconfig.app.json" }, { "path": "./tsconfig.node.json" }]
		}</file>
	<file path='frontend\tsconfig.node.json'>
		{
		  "compilerOptions": {
		    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
		    "target": "ES2022",
		    "lib": ["ES2023"],
		    "module": "ESNext",
		    "skipLibCheck": true,
		
		    /* Bundler mode */
		    "moduleResolution": "bundler",
		    "allowImportingTsExtensions": true,
		    "isolatedModules": true,
		    "moduleDetection": "force",
		    "noEmit": true,
		
		    /* Linting */
		    "strict": true,
		    "noUnusedLocals": true,
		    "noUnusedParameters": true,
		    "noFallthroughCasesInSwitch": true,
		    "noUncheckedSideEffectImports": true
		  },
		  "include": ["vite.config.ts"]
		}</file>
	<file path='frontend\vite.config.ts'>
		import { defineConfig } from 'vite';
		import react from '@vitejs/plugin-react';
		
		import dotenv from 'dotenv';
		dotenv.config();
		
		const VITE_FOLDER_NAME = process.env.VITE_FOLDER_NAME;
		
		// Check if the environment variable is set
		if (typeof VITE_FOLDER_NAME === 'undefined' || VITE_FOLDER_NAME === '') {
		  console.error(
		    'VITE_FOLDER_NAME environment variable is not set, update your .env file with a value naming your dashboard, eg "VITE_FOLDER_NAME=ha-dashboard"'
		  );
		  process.exit(1);
		}
		
		// https://vite.dev/config/
		export default defineConfig({
		  base: `/local/${VITE_FOLDER_NAME}/`,
		  plugins: [react()],
		  css: {
		    postcss: './postcss.config.js',
		  },
		});</file>
	<file path='LICENSE'>
		MIT License
		
		Copyright (c) 2023 Arkaqius
		
		Permission is hereby granted, free of charge, to any person obtaining a copy
		of this software and associated documentation files (the "Software"), to deal
		in the Software without restriction, including without limitation the rights
		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		copies of the Software, and to permit persons to whom the Software is
		furnished to do so, subject to the following conditions:
		
		The above copyright notice and this permission notice shall be included in all
		copies or substantial portions of the Software.
		
		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
		SOFTWARE.</file>
	<file path='README.md'>
		# Safety Component for Home Assistant
		
		This repository is dedicated to developing a Safety Component for the Home Assistant system. The component is designed to monitor, assess, and mitigate safety and security risks in a home environment. The repository includes documentation on hazard analysis, risk assessment, safety goals, and risk mitigation strategies for a wide range of potential hazards.  
		
		## Features
		**SafetyConcept**: Please refer to the full documentation for a comprehensive understanding of our hazard analysis and risk assessment process, as well as the risk mitigation strategies we employ.
		
		## Installation
		TODO
		
		## Usage
		TODO
		
		## Contributing
		We appreciate your contributions! Please feel free to submit pull requests, create issues, and contribute to discussions.
		
		## Fork the Project
		Create your Feature Branch (git checkout -b feature/AmazingFeature)
		Commit your Changes (git commit -m 'Add some AmazingFeature')
		Push to the Branch (git push origin feature/AmazingFeature)
		Open a Pull Request
		
		## License
		Distributed under the MIT License. See LICENSE for more information.
		
		## Contact
		TODO
		
		
		
		## Acknowledgments
		We would like to express our gratitude to the community for their continuous support and valuable feedback. This project wouldn't be where it is today without your help.</file>
</files>
